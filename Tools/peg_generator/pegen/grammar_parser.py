#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser, cut_sentinel
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    Args,
    Cut,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NamedItem,
    NamedItems,
    NegativeLookahead,
    Opt,
    Params,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    TypedName,
    Grammar,
    StringLeaf,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    def start(self) -> ParseResult[Grammar]:
        # start: grammar $
        def _alt():
            # grammar
            def _item_grammar():
                return self.grammar()
            grammar: Grammar; _result_grammar: ParseResult[Grammar]
            _result_grammar = _item_grammar()
            if not _result_grammar: return None
            grammar, = _result_grammar
            # $
            def _item__endmarker():
                return self._expect('ENDMARKER')
            _endmarker: Token; _result__endmarker: ParseResult[Token]
            _result__endmarker = _item__endmarker()
            if not _result__endmarker: return None
            _endmarker, = _result__endmarker
            # parse succeeded
            return (grammar),
        return self._alt(_alt)

    def grammar(self) -> ParseResult[Grammar]:
        # grammar: meta* rule+
        def _alt():
            # meta*
            def _item_metas():
                def _atom():
                    return self.meta()
                return self._repeat0(_atom)
            metas: List[Meta]
            metas, = _item_metas()
            # rule+
            def _item_rules():
                def _atom():
                    return self.rule()
                return self._repeat1(_atom)
            rules: List[Rule]; _result_rules: ParseResult[List[Rule]]
            _result_rules = _item_rules()
            if not _result_rules: return None
            rules, = _result_rules
            # parse succeeded
            return (Grammar (rules , metas)),
        return self._alt(_alt)

    def meta(self) -> ParseResult[Meta]:
        # meta: "@" NAME metavalue? NEWLINE
        def _alt():
            # "@"
            def _item__literal():
                return self._expect("@")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # NAME
            def _item_name():
                return self._name()
            name: Token; _result_name: ParseResult[Token]
            _result_name = _item_name()
            if not _result_name: return None
            name, = _result_name
            # metavalue?
            def _item_val():
                def _atom():
                    return self.metavalue()
                return self._opt(_atom)
            val: Optional[str]
            val, = _item_val()
            # NEWLINE
            def _item__newline():
                return self._expect('NEWLINE')
            _newline: Token; _result__newline: ParseResult[Token]
            _result__newline = _item__newline()
            if not _result__newline: return None
            _newline, = _result__newline
            # parse succeeded
            return (Meta (name . string , val)),
        return self._alt(_alt)

    def metavalue(self) -> ParseResult[str]:
        # metavalue: NAME | STRING | <always>
        def _alt_1():
            # NAME
            def _item_val():
                return self._name()
            val: Token; _result_val: ParseResult[Token]
            _result_val = _item_val()
            if not _result_val: return None
            val, = _result_val
            # parse succeeded
            return (val . string),
        def _alt_2():
            # STRING
            def _item_val():
                return self._string()
            val: Token; _result_val: ParseResult[Token]
            _result_val = _item_val()
            if not _result_val: return None
            val, = _result_val
            # parse succeeded
            return (literal_eval (val . string)),
        def _alt_3():
            # parse succeeded
            return (None),
        return self._alts(_alt_1, _alt_2, _alt_3)

    def rule(self) -> ParseResult[Rule]:
        # rule: typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
        def _alt():
            # typed_name
            def _item_n():
                return self.typed_name()
            n: TypedName; _result_n: ParseResult[TypedName]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # memoflag?
            def _item_m():
                def _atom():
                    return self.memoflag()
                return self._opt(_atom)
            m: Optional[str]
            m, = _item_m()
            # ":"
            def _item__literal():
                return self._expect(":")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # maybe_alts?
            def _item_a():
                def _atom():
                    return self.maybe_alts()
                return self._opt(_atom)
            a: Optional[Rhs]
            a, = _item_a()
            # NEWLINE
            def _item__newline():
                return self._expect('NEWLINE')
            _newline: Token; _result__newline: ParseResult[Token]
            _result__newline = _item__newline()
            if not _result__newline: return None
            _newline, = _result__newline
            # more_alts?
            def _item_aa():
                def _atom():
                    return self.more_alts()
                return self._opt(_atom)
            aa: Optional[Rhs]
            aa, = _item_aa()
            # parse succeeded
            return (Rule (n , Rhs (a + aa) , memo = m)),
        return self._alt(_alt)

    def params(self) -> ParseResult[Params]:
        # params: !memoflag '(' ','.typed_name+ [','] ')' | '(' ')'
        def _alt_1():
            # !memoflag
            def _item__lookahead():
                def _atom():
                    return self.memoflag()
                return self._negative_lookahead(_atom)
            _lookahead: bool; _result__lookahead: ParseResult[bool]
            _result__lookahead = _item__lookahead()
            if not _result__lookahead: return None
            _lookahead, = _result__lookahead
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ','.typed_name+
            def _item_n():
                def _elem():
                    return self.typed_name()
                def _sep():
                    return self._expect(',')
                return self._gather(_elem, _sep)
            n: List[TypedName]; _result_n: ParseResult[List[TypedName]]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # [',']
            def _item_opt():
                def _atom():
                    def _alt():
                        # ','
                        def _item__literal():
                            return self._expect(',')
                        _literal: Token; _result__literal: ParseResult[Token]
                        _result__literal = _item__literal()
                        if not _result__literal: return None
                        _literal, = _result__literal
                        # parse succeeded
                        return (_literal),
                    return self._alt(_alt)
                return self._opt(_atom)
            opt: Optional[Any]
            opt, = _item_opt()
            # ')'
            def _item__literal_1():
                return self._expect(')')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Params (n)),
        def _alt_2():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ')'
            def _item__literal_1():
                return self._expect(')')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Params ([])),
        return self._alts(_alt_1, _alt_2)

    def typed_name(self) -> ParseResult[TypedName]:
        # typed_name: NAME params? annotation?
        def _alt():
            # NAME
            def _item_n():
                return self._name()
            n: Token; _result_n: ParseResult[Token]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # params?
            def _item_p():
                def _atom():
                    return self.params()
                return self._opt(_atom)
            p: Optional[Params]
            p, = _item_p()
            # annotation?
            def _item_a():
                def _atom():
                    return self.annotation()
                return self._opt(_atom)
            a: Optional[str]
            a, = _item_a()
            # parse succeeded
            return (TypedName (n . string , p , a)),
        return self._alt(_alt)

    def memoflag(self) -> ParseResult[str]:
        # memoflag: '(' "memo" ')'
        def _alt():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # "memo"
            def _item__literal_1():
                return self._expect("memo")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # ')'
            def _item__literal_2():
                return self._expect(')')
            _literal_2: Token; _result__literal_2: ParseResult[Token]
            _result__literal_2 = _item__literal_2()
            if not _result__literal_2: return None
            _literal_2, = _result__literal_2
            # parse succeeded
            return ("memo"),
        return self._alt(_alt)

    def alts(self) -> ParseResult[Rhs]:
        # alts: "|".alt+
        def _alt():
            # "|".alt+
            def _item_a():
                def _elem():
                    return self.alt()
                def _sep():
                    return self._expect("|")
                return self._gather(_elem, _sep)
            a: List[Alt]; _result_a: ParseResult[List[Alt]]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (Rhs (a)),
        return self._alt(_alt)

    @memoize
    def maybe_alts(self) -> ParseResult[Rhs]:
        # maybe_alts: !NEWLINE "|".alt+ | <always>
        def _alt_1():
            # !NEWLINE
            def _item__lookahead():
                def _atom():
                    return self._expect('NEWLINE')
                return self._negative_lookahead(_atom)
            _lookahead: bool; _result__lookahead: ParseResult[bool]
            _result__lookahead = _item__lookahead()
            if not _result__lookahead: return None
            _lookahead, = _result__lookahead
            # "|".alt+
            def _item_a():
                def _elem():
                    return self.alt()
                def _sep():
                    return self._expect("|")
                return self._gather(_elem, _sep)
            a: List[Alt]; _result_a: ParseResult[List[Alt]]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (Rhs (a)),
        def _alt_2():
            # parse succeeded
            return (Rhs ([])),
        return self._alts(_alt_1, _alt_2)

    @memoize
    def more_alts(self) -> ParseResult[Rhs]:
        # more_alts: INDENT (("|" alts NEWLINE))+ DEDENT | <always>
        def _alt_1():
            # INDENT
            def _item__indent():
                return self._expect('INDENT')
            _indent: Token; _result__indent: ParseResult[Token]
            _result__indent = _item__indent()
            if not _result__indent: return None
            _indent, = _result__indent
            # (("|" alts NEWLINE))+
            def _item_a():
                def _atom():
                    def _alt():
                        # "|"
                        def _item__literal():
                            return self._expect("|")
                        _literal: Token; _result__literal: ParseResult[Token]
                        _result__literal = _item__literal()
                        if not _result__literal: return None
                        _literal, = _result__literal
                        # alts
                        def _item_b():
                            return self.alts()
                        b: Rhs; _result_b: ParseResult[Rhs]
                        _result_b = _item_b()
                        if not _result_b: return None
                        b, = _result_b
                        # NEWLINE
                        def _item__newline():
                            return self._expect('NEWLINE')
                        _newline: Token; _result__newline: ParseResult[Token]
                        _result__newline = _item__newline()
                        if not _result__newline: return None
                        _newline, = _result__newline
                        # parse succeeded
                        return (b),
                    return self._alt(_alt)
                return self._repeat1(_atom)
            a: List[Any]; _result_a: ParseResult[List[Any]]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # DEDENT
            def _item__dedent():
                return self._expect('DEDENT')
            _dedent: Token; _result__dedent: ParseResult[Token]
            _result__dedent = _item__dedent()
            if not _result__dedent: return None
            _dedent, = _result__dedent
            # parse succeeded
            return (Rhs (chain (* a))),
        def _alt_2():
            # parse succeeded
            return (Rhs ()),
        return self._alts(_alt_1, _alt_2)

    def alt(self) -> ParseResult[Alt]:
        # alt: items endmarker action?
        def _alt():
            # items
            def _item_i():
                return self.items()
            i: NamedItems; _result_i: ParseResult[NamedItems]
            _result_i = _item_i()
            if not _result_i: return None
            i, = _result_i
            # endmarker
            def _item_e():
                return self.endmarker()
            e: NamedItems; _result_e: ParseResult[NamedItems]
            _result_e = _item_e()
            if not _result_e: return None
            e, = _result_e
            # action?
            def _item_a():
                def _atom():
                    return self.action()
                return self._opt(_atom)
            a: Optional[str]
            a, = _item_a()
            # parse succeeded
            return (Alt (i + e , action = a)),
        return self._alt(_alt)

    def items(self) -> ParseResult[NamedItems]:
        # items: named_item*
        def _alt():
            # named_item*
            def _item_n():
                def _atom():
                    return self.named_item()
                return self._repeat0(_atom)
            n: List[NamedItem]
            n, = _item_n()
            # parse succeeded
            return (NamedItems (n)),
        return self._alt(_alt)

    @memoize
    def named_item(self) -> ParseResult[NamedItem]:
        # named_item: typed_name '=' ~ item | item | forced_atom | lookahead | cut
        def _alt_1():
            # typed_name
            def _item_n():
                return self.typed_name()
            n: TypedName; _result_n: ParseResult[TypedName]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # '='
            def _item__literal():
                return self._expect('=')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ~
            # item
            def _item_item():
                return self.item()
            item: Item; _result_item: ParseResult[Item]
            _result_item = _item_item()
            if not _result_item: return cut_sentinel
            item, = _result_item
            # parse succeeded
            return (NamedItem (n , item)),
        def _alt_2():
            # item
            def _item_it():
                return self.item()
            it: Item; _result_it: ParseResult[Item]
            _result_it = _item_it()
            if not _result_it: return None
            it, = _result_it
            # parse succeeded
            return (NamedItem (None , it)),
        def _alt_3():
            # forced_atom
            def _item_forced():
                return self.forced_atom()
            forced: Forced; _result_forced: ParseResult[Forced]
            _result_forced = _item_forced()
            if not _result_forced: return None
            forced, = _result_forced
            # parse succeeded
            return (NamedItem (None , forced)),
        def _alt_4():
            # lookahead
            def _item_it():
                return self.lookahead()
            it: Lookahead; _result_it: ParseResult[Lookahead]
            _result_it = _item_it()
            if not _result_it: return None
            it, = _result_it
            # parse succeeded
            return (NamedItem (None , it)),
        def _alt_5():
            # cut
            def _item_cut():
                return self.cut()
            cut: Cut; _result_cut: ParseResult[Cut]
            _result_cut = _item_cut()
            if not _result_cut: return None
            cut, = _result_cut
            # parse succeeded
            return (NamedItem (None , cut)),
        return self._alts(_alt_1, _alt_2, _alt_3, _alt_4, _alt_5)

    def forced_atom(self) -> ParseResult[Forced]:
        # forced_atom: '&' '&' ~ atom
        def _alt():
            # '&'
            def _item__literal():
                return self._expect('&')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # '&'
            def _item__literal_1():
                return self._expect('&')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # ~
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return cut_sentinel
            a, = _result_a
            # parse succeeded
            return (Forced (a)),
        return self._alt(_alt)

    def lookahead(self) -> ParseResult[Lookahead]:
        # lookahead: '&' ~ atom | '!' ~ atom
        def _alt_1():
            # '&'
            def _item__literal():
                return self._expect('&')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ~
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return cut_sentinel
            a, = _result_a
            # parse succeeded
            return (PositiveLookahead (a)),
        def _alt_2():
            # '!'
            def _item__literal():
                return self._expect('!')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ~
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return cut_sentinel
            a, = _result_a
            # parse succeeded
            return (NegativeLookahead (a)),
        return self._alts(_alt_1, _alt_2)

    def cut(self) -> ParseResult[Cut]:
        # cut: '~'
        def _alt():
            # '~'
            def _item__literal():
                return self._expect('~')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (Cut ()),
        return self._alt(_alt)

    @memoize
    def item(self) -> ParseResult[Item]:
        # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+' | atom
        def _alt_1():
            # '['
            def _item__literal():
                return self._expect('[')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ~
            # alts
            def _item_alts():
                return self.alts()
            alts: Rhs; _result_alts: ParseResult[Rhs]
            _result_alts = _item_alts()
            if not _result_alts: return cut_sentinel
            alts, = _result_alts
            # ']'
            def _item__literal_1():
                return self._expect(']')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return cut_sentinel
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Opt (alts)),
        def _alt_2():
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # '?'
            def _item__literal():
                return self._expect('?')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (Opt (a)),
        def _alt_3():
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # '*'
            def _item__literal():
                return self._expect('*')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (Repeat0 (a)),
        def _alt_4():
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # '+'
            def _item__literal():
                return self._expect('+')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (Repeat1 (a)),
        def _alt_5():
            # atom
            def _item_sep():
                return self.atom()
            sep: Plain; _result_sep: ParseResult[Plain]
            _result_sep = _item_sep()
            if not _result_sep: return None
            sep, = _result_sep
            # '.'
            def _item__literal():
                return self._expect('.')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # atom
            def _item_node():
                return self.atom()
            node: Plain; _result_node: ParseResult[Plain]
            _result_node = _item_node()
            if not _result_node: return None
            node, = _result_node
            # '+'
            def _item__literal_1():
                return self._expect('+')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Gather (sep , node)),
        def _alt_6():
            # atom
            def _item_a():
                return self.atom()
            a: Plain; _result_a: ParseResult[Plain]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (a),
        return self._alts(_alt_1, _alt_2, _alt_3, _alt_4, _alt_5, _alt_6)

    def endmarker(self) -> ParseResult[NamedItems]:
        # endmarker: '$' | <always>
        def _alt_1():
            # '$'
            def _item__literal():
                return self._expect('$')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (NamedItems ([NamedItem (None , NameLeaf ('ENDMARKER'))])),
        def _alt_2():
            # parse succeeded
            return (NamedItems ()),
        return self._alts(_alt_1, _alt_2)

    @memoize
    def atom(self) -> ParseResult[Plain]:
        # atom: '(' ~ alts ')' | NAME arguments? | STRING
        def _alt_1():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ~
            # alts
            def _item_alts():
                return self.alts()
            alts: Rhs; _result_alts: ParseResult[Rhs]
            _result_alts = _item_alts()
            if not _result_alts: return cut_sentinel
            alts, = _result_alts
            # ')'
            def _item__literal_1():
                return self._expect(')')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return cut_sentinel
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Group ((alts))),
        def _alt_2():
            # NAME
            def _item_n():
                return self._name()
            n: Token; _result_n: ParseResult[Token]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # arguments?
            def _item_a():
                def _atom():
                    return self.arguments()
                return self._opt(_atom)
            a: Optional[Args]
            a, = _item_a()
            # parse succeeded
            return (NameLeaf (n . string , a)),
        def _alt_3():
            # STRING
            def _item_s():
                return self._string()
            s: Token; _result_s: ParseResult[Token]
            _result_s = _item_s()
            if not _result_s: return None
            s, = _result_s
            # parse succeeded
            return (StringLeaf (s . string)),
        return self._alts(_alt_1, _alt_2, _alt_3)

    def action(self) -> ParseResult[str]:
        # action: "{" target_atoms "}"
        def _alt():
            # "{"
            def _item__literal():
                return self._expect("{")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # target_atoms
            def _item_t():
                return self.target_atoms()
            t: str; _result_t: ParseResult[str]
            _result_t = _item_t()
            if not _result_t: return None
            t, = _result_t
            # "}"
            def _item__literal_1():
                return self._expect("}")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (t),
        return self._alt(_alt)

    def annotation(self) -> ParseResult[str]:
        # annotation: "[" target_atoms "]"
        def _alt():
            # "["
            def _item__literal():
                return self._expect("[")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # target_atoms
            def _item_t():
                return self.target_atoms()
            t: str; _result_t: ParseResult[str]
            _result_t = _item_t()
            if not _result_t: return None
            t, = _result_t
            # "]"
            def _item__literal_1():
                return self._expect("]")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (t),
        return self._alt(_alt)

    def arguments(self) -> ParseResult[Args]:
        # arguments: '(' arg "," ",".arg+ [","] ')' | '(' arg "," ')' | '(' ')'
        def _alt_1():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # arg
            def _item_a():
                return self.arg()
            a: Any; _result_a: ParseResult[Any]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # ","
            def _item__literal_1():
                return self._expect(",")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # ",".arg+
            def _item_b():
                def _elem():
                    return self.arg()
                def _sep():
                    return self._expect(",")
                return self._gather(_elem, _sep)
            b: List[Any]; _result_b: ParseResult[List[Any]]
            _result_b = _item_b()
            if not _result_b: return None
            b, = _result_b
            # [","]
            def _item_c():
                def _atom():
                    def _alt():
                        # ","
                        def _item__literal():
                            return self._expect(",")
                        _literal: Token; _result__literal: ParseResult[Token]
                        _result__literal = _item__literal()
                        if not _result__literal: return None
                        _literal, = _result__literal
                        # parse succeeded
                        return (_literal),
                    return self._alt(_alt)
                return self._opt(_atom)
            c: Optional[Any]
            c, = _item_c()
            # ')'
            def _item__literal_2():
                return self._expect(')')
            _literal_2: Token; _result__literal_2: ParseResult[Token]
            _result__literal_2 = _item__literal_2()
            if not _result__literal_2: return None
            _literal_2, = _result__literal_2
            # parse succeeded
            return (Args ([a] + b , comma = c and c . string)),
        def _alt_2():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # arg
            def _item_a():
                return self.arg()
            a: Any; _result_a: ParseResult[Any]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # ","
            def _item__literal_1():
                return self._expect(",")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # ')'
            def _item__literal_2():
                return self._expect(')')
            _literal_2: Token; _result__literal_2: ParseResult[Token]
            _result__literal_2 = _item__literal_2()
            if not _result__literal_2: return None
            _literal_2, = _result__literal_2
            # parse succeeded
            return (Args ([a] , comma = ",")),
        def _alt_3():
            # '('
            def _item__literal():
                return self._expect('(')
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # ')'
            def _item__literal_1():
                return self._expect(')')
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return (Args ()),
        return self._alts(_alt_1, _alt_2, _alt_3)

    def arg(self) -> ParseResult[Any]:
        # arg: arg_atom+
        def _alt():
            # arg_atom+
            def _item_a():
                def _atom():
                    return self.arg_atom()
                return self._repeat1(_atom)
            a: List[Any]; _result_a: ParseResult[List[Any]]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (" " . join (a)),
        return self._alt(_alt)

    def arg_atom(self) -> ParseResult[Any]:
        # arg_atom: !"," target_atom
        def _alt():
            # !","
            def _item__lookahead():
                def _atom():
                    return self._expect(",")
                return self._negative_lookahead(_atom)
            _lookahead: bool; _result__lookahead: ParseResult[bool]
            _result__lookahead = _item__lookahead()
            if not _result__lookahead: return None
            _lookahead, = _result__lookahead
            # target_atom
            def _item_a():
                return self.target_atom()
            a: str; _result_a: ParseResult[str]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (a),
        return self._alt(_alt)

    def target_atoms(self) -> ParseResult[str]:
        # target_atoms: target_atom+
        def _alt():
            # target_atom+
            def _item_a():
                def _atom():
                    return self.target_atom()
                return self._repeat1(_atom)
            a: List[str]; _result_a: ParseResult[List[str]]
            _result_a = _item_a()
            if not _result_a: return None
            a, = _result_a
            # parse succeeded
            return (" " . join (a)),
        return self._alt(_alt)

    @memoize
    def target_atom(self) -> ParseResult[str]:
        # target_atom: "(" target_atoms? ")" | "{" target_atoms? "}" | "[" target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" | !")" !"}" !"]" OP
        def _alt_1():
            # "("
            def _item__literal():
                return self._expect("(")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # target_atoms?
            def _item_atoms():
                def _atom():
                    return self.target_atoms()
                return self._opt(_atom)
            atoms: Optional[str]
            atoms, = _item_atoms()
            # ")"
            def _item__literal_1():
                return self._expect(")")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return ("(" + (atoms or "") + ")"),
        def _alt_2():
            # "{"
            def _item__literal():
                return self._expect("{")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # target_atoms?
            def _item_atoms():
                def _atom():
                    return self.target_atoms()
                return self._opt(_atom)
            atoms: Optional[str]
            atoms, = _item_atoms()
            # "}"
            def _item__literal_1():
                return self._expect("}")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return ("{" + (atoms or "") + "}"),
        def _alt_3():
            # "["
            def _item__literal():
                return self._expect("[")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # target_atoms?
            def _item_atoms():
                def _atom():
                    return self.target_atoms()
                return self._opt(_atom)
            atoms: Optional[str]
            atoms, = _item_atoms()
            # "]"
            def _item__literal_1():
                return self._expect("]")
            _literal_1: Token; _result__literal_1: ParseResult[Token]
            _result__literal_1 = _item__literal_1()
            if not _result__literal_1: return None
            _literal_1, = _result__literal_1
            # parse succeeded
            return ("[" + (atoms or "") + "]"),
        def _alt_4():
            # NAME
            def _item_n():
                return self._name()
            n: Token; _result_n: ParseResult[Token]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # "*"
            def _item__literal():
                return self._expect("*")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (n . string + "*"),
        def _alt_5():
            # NAME
            def _item_n():
                return self._name()
            n: Token; _result_n: ParseResult[Token]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # parse succeeded
            return (n . string),
        def _alt_6():
            # NUMBER
            def _item_n():
                return self._number()
            n: Token; _result_n: ParseResult[Token]
            _result_n = _item_n()
            if not _result_n: return None
            n, = _result_n
            # parse succeeded
            return (n . string),
        def _alt_7():
            # STRING
            def _item_s():
                return self._string()
            s: Token; _result_s: ParseResult[Token]
            _result_s = _item_s()
            if not _result_s: return None
            s, = _result_s
            # parse succeeded
            return (s . string),
        def _alt_8():
            # "?"
            def _item__literal():
                return self._expect("?")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return ("?"),
        def _alt_9():
            # ":"
            def _item__literal():
                return self._expect(":")
            _literal: Token; _result__literal: ParseResult[Token]
            _result__literal = _item__literal()
            if not _result__literal: return None
            _literal, = _result__literal
            # parse succeeded
            return (":"),
        def _alt_10():
            # !")"
            def _item__lookahead():
                def _atom():
                    return self._expect(")")
                return self._negative_lookahead(_atom)
            _lookahead: bool; _result__lookahead: ParseResult[bool]
            _result__lookahead = _item__lookahead()
            if not _result__lookahead: return None
            _lookahead, = _result__lookahead
            # !"}"
            def _item__lookahead_1():
                def _atom():
                    return self._expect("}")
                return self._negative_lookahead(_atom)
            _lookahead_1: bool; _result__lookahead_1: ParseResult[bool]
            _result__lookahead_1 = _item__lookahead_1()
            if not _result__lookahead_1: return None
            _lookahead_1, = _result__lookahead_1
            # !"]"
            def _item__lookahead_2():
                def _atom():
                    return self._expect("]")
                return self._negative_lookahead(_atom)
            _lookahead_2: bool; _result__lookahead_2: ParseResult[bool]
            _result__lookahead_2 = _item__lookahead_2()
            if not _result__lookahead_2: return None
            _lookahead_2, = _result__lookahead_2
            # OP
            def _item_op():
                return self._op()
            op: Token; _result_op: ParseResult[Token]
            _result_op = _item_op()
            if not _result_op: return None
            op, = _result_op
            # parse succeeded
            return (op . string),
        return self._alts(_alt_1, _alt_2, _alt_3, _alt_4, _alt_5, _alt_6, _alt_7, _alt_8, _alt_9, _alt_10)

    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
