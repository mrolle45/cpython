#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional, Callable, cast

from pegen.parser import (
    memoize, memoize_left_rec, logger, Parser, ParseResult
    )
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    AltItem,
    AltItems,
    Arg,
    Args,
    Cut,
    Forced,
    Gather0,
    Gather1,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NegativeLookahead,
    ObjName,
    Opt,
    OptGroup,
    Param,
    Params,
    PositiveLookahead,
    Primary,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
    VarItem,
)

from pegen.target_code import Code

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    # start() [Grammar]: grammar $
    def start(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:

            # grammar $
            def _alt() -> ParseResult[Grammar]:

                # g=grammar
                def _item_g() -> ParseResult[Grammar]:
                    return self.grammar()
                g: Grammar; _result_g: ParseResult[Grammar]
                _result_g = _item_g()
                if not _result_g: return None
                g, = _result_g

                # $
                def _item__ENDMARKER() -> ParseResult[Token]:
                    return self._expect_type(0)
                _ENDMARKER: Token; _result__ENDMARKER: ParseResult[Token]
                _result__ENDMARKER = _item__ENDMARKER()
                if not _result__ENDMARKER: return None
                _ENDMARKER, = _result__ENDMARKER

                # parse succeeded
                return g,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # grammar() [Grammar]: meta* rule+
    def grammar(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:

            # meta* rule+
            def _alt() -> ParseResult[Grammar]:

                # metas=meta*
                def _item_metas() -> ParseResult[list [ Meta ]]:
                    def _meta() -> ParseResult[Meta]:
                        return self.meta()
                    return self._repeat(_meta, False)
                metas: list [ Meta ]
                metas, = _item_metas()

                # rules=rule+
                def _item_rules() -> ParseResult[list [ Rule ]]:
                    def _rule() -> ParseResult[Rule]:
                        return self.rule()
                    return self._repeat(_rule, True)
                rules: list [ Rule ]; _result_rules: ParseResult[list [ Rule ]]
                _result_rules = _item_rules()
                if not _result_rules: return None
                rules, = _result_rules

                # parse succeeded
                return Grammar (rules , metas),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # meta() [Meta]: "@" NAME metavalue NEWLINE
    def meta(self) -> ParseResult[Meta]:
        def _rhs() -> ParseResult[Meta]:

            # "@" NAME metavalue NEWLINE
            def _alt() -> ParseResult[Meta]:

                # "@"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(49)   # token = "@"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # name=NAME
                def _item_name() -> ParseResult[Token]:
                    return self._name()
                name: Token; _result_name: ParseResult[Token]
                _result_name = _item_name()
                if not _result_name: return None
                name, = _result_name

                # val=metavalue
                def _item_val() -> ParseResult[str]:
                    return self.metavalue()
                val: str; _result_val: ParseResult[str]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # parse succeeded
                return Meta (name . string , val),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # metavalue() [str]: NAME | STRING | <always>
    def metavalue(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:

            # NAME
            def _alt1() -> ParseResult[str]:

                # val=NAME
                def _item_val() -> ParseResult[Token]:
                    return self._name()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return val . string,

            # STRING
            def _alt2() -> ParseResult[str]:

                # val=STRING
                def _item_val() -> ParseResult[Token]:
                    return self._string()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return literal_eval (val . string),

            # <always>
            def _alt3() -> ParseResult[str]:

                # parse succeeded
                return None,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rule() [Rule]: typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
    def rule(self) -> ParseResult[Rule]:
        def _rhs() -> ParseResult[Rule]:

            # typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
            def _alt() -> ParseResult[Rule]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # m=memoflag?
                def _item_m() -> ParseResult[list [ str ]]:
                    def _memoflag() -> ParseResult[str]:
                        return self.memoflag()
                    return self._opt(_memoflag)
                m: list [ str ]
                m, = _item_m()

                # ":"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(11)   # token = ":"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=maybe_alts?
                def _item_a() -> ParseResult[list[Rhs]]:
                    def _maybe_alts() -> ParseResult[Rhs]:
                        return self.maybe_alts()
                    return self._opt(_maybe_alts)
                a: list[Rhs]
                a, = _item_a()

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # aa=more_alts?
                def _item_aa() -> ParseResult[list[Rhs]]:
                    def _more_alts() -> ParseResult[Rhs]:
                        return self.more_alts()
                    return self._opt(_more_alts)
                aa: list[Rhs]
                aa, = _item_aa()

                # parse succeeded
                return Rule ( n , Rhs ( [ * chain ( * a , * aa ) ] ) , memo = m ),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # params() [Params]: !memoflag '(' ','.param+ [','] ')' | '(' ')'
    def params(self) -> ParseResult[Params]:
        def _rhs() -> ParseResult[Params]:

            # !memoflag '(' ','.param+ [','] ')'
            def _alt1() -> ParseResult[Params]:

                # !memoflag
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[str]:
                        return self.memoflag()
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # n=','.param+
                def _item_n() -> ParseResult[list [Param ]]:
                    def _param() -> ParseResult[Param]:
                        return self.param()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._gather(_param, _sep, True)
                n: list [Param ]; _result_n: ParseResult[list [Param ]]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # [',']
                def _item__opt() -> ParseResult[list [Any ]]:
                    def _rhs() -> ParseResult[Any]:

                        # ','
                        def _alt() -> ParseResult[Any]:

                            # ','
                            def _item__literal() -> ParseResult[Token]:
                                return self._expect_type(12)   # token = ","
                            _literal: Token; _result__literal: ParseResult[Token]
                            _result__literal = _item__literal()
                            if not _result__literal: return None
                            _literal, = _result__literal

                            # parse succeeded
                            return _literal,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return self._opt(_rhs)
                _opt: list [Any ]
                _opt, = _item__opt()

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params (n),

            # '(' ')'
            def _alt2() -> ParseResult[Params]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params ([]),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # param() [Param]: typed_name
    def param(self) -> ParseResult[Param]:
        def _rhs() -> ParseResult[Param]:

            # typed_name
            def _alt() -> ParseResult[Param]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return Param (n),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # typed_name() [TypedName]: NAME params? annotation?
    def typed_name(self) -> ParseResult[TypedName]:
        def _rhs() -> ParseResult[TypedName]:

            # NAME params? annotation?
            def _alt() -> ParseResult[TypedName]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # p=params?
                def _item_p() -> ParseResult[list [Params ]]:
                    def _params() -> ParseResult[Params]:
                        return self.params()
                    return self._opt(_params)
                p: list [Params ]
                p, = _item_p()

                # typ=annotation?
                def _item_typ() -> ParseResult[list[list[Token]]]:
                    def _annotation() -> ParseResult[list[Token]]:
                        return self.annotation()
                    return self._opt(_annotation)
                typ: list[list[Token]]
                typ, = _item_typ()

                # parse succeeded
                return TypedName (n .string ,Code (typ .val ),p.val ),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # memoflag() [str]: '(' "memo" ')'
    def memoflag(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:

            # '(' "memo" ')'
            def _alt() -> ParseResult[str]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # "memo"
                def _item__keyword() -> ParseResult[Token]:
                    return self._expect_name("memo")   # keyword='memo'
                _keyword: Token; _result__keyword: ParseResult[Token]
                _result__keyword = _item__keyword()
                if not _result__keyword: return None
                _keyword, = _result__keyword

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return "memo",

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alts() [Rhs]: "|".alt+
    def alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # "|".alt+
            def _alt() -> ParseResult[Rhs]:

                # a="|".alt+
                def _item_a() -> ParseResult[list [Alt ]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(_alt, _sep, True)
                a: list [Alt ]; _result_a: ParseResult[list [Alt ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs (a),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # maybe_alts() [Rhs]: !NEWLINE "|".alt+ | <always>
    @memoize
    def maybe_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # !NEWLINE "|".alt+
            def _alt1() -> ParseResult[Rhs]:

                # !NEWLINE
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(4)
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # a="|".alt+
                def _item_a() -> ParseResult[list [Alt ]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(_alt, _sep, True)
                a: list [Alt ]; _result_a: ParseResult[list [Alt ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs (a),

            # <always>
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs ([]),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # more_alts() [Rhs]: INDENT ("|" alts NEWLINE)+ DEDENT | <always>
    @memoize
    def more_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # INDENT ("|" alts NEWLINE)+ DEDENT
            def _alt1() -> ParseResult[Rhs]:

                # INDENT
                def _item__INDENT() -> ParseResult[Token]:
                    return self._expect_type(5)
                _INDENT: Token; _result__INDENT: ParseResult[Token]
                _result__INDENT = _item__INDENT()
                if not _result__INDENT: return None
                _INDENT, = _result__INDENT

                # a=("|" alts NEWLINE)+
                def _item_a() -> ParseResult[list [Any ]]:
                    def _group() -> ParseResult[Any]:
                        def _rhs() -> ParseResult[Any]:

                            # "|" alts NEWLINE
                            def _alt() -> ParseResult[Any]:

                                # "|"
                                def _item__literal() -> ParseResult[Token]:
                                    return self._expect_type(18)   # token = "|"
                                _literal: Token; _result__literal: ParseResult[Token]
                                _result__literal = _item__literal()
                                if not _result__literal: return None
                                _literal, = _result__literal

                                # b=alts
                                def _item_b() -> ParseResult[Rhs]:
                                    return self.alts()
                                b: Rhs; _result_b: ParseResult[Rhs]
                                _result_b = _item_b()
                                if not _result_b: return None
                                b, = _result_b

                                # NEWLINE
                                def _item__NEWLINE() -> ParseResult[Token]:
                                    return self._expect_type(4)
                                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                                _result__NEWLINE = _item__NEWLINE()
                                if not _result__NEWLINE: return None
                                _NEWLINE, = _result__NEWLINE

                                # parse succeeded
                                return b,

                            _alts = [
                                _alt,
                            ]
                            return self._alts(_alts)
                        return _rhs()
                    return self._repeat(_group, True)
                a: list [Any ]; _result_a: ParseResult[list [Any ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # DEDENT
                def _item__DEDENT() -> ParseResult[Token]:
                    return self._expect_type(6)
                _DEDENT: Token; _result__DEDENT: ParseResult[Token]
                _result__DEDENT = _item__DEDENT()
                if not _result__DEDENT: return None
                _DEDENT, = _result__DEDENT

                # parse succeeded
                return Rhs (chain (* a)),

            # <always>
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs (()),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt() [Alt]: alt_items action?
    def alt(self) -> ParseResult[Alt]:
        def _rhs() -> ParseResult[Alt]:

            # alt_items action?
            def _alt() -> ParseResult[Alt]:

                # i=alt_items
                def _item_i() -> ParseResult[AltItems]:
                    return self.alt_items()
                i: AltItems; _result_i: ParseResult[AltItems]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # a=action?
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _action() -> ParseResult[list[Token]]:
                        return self.action()
                    return self._opt(_action)
                a: list[list[Token]]
                a, = _item_a()

                # parse succeeded
                return Alt (i , action = Code(a.val)),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt_items() [AltItems]: alt_item*
    def alt_items(self) -> ParseResult[AltItems]:
        def _rhs() -> ParseResult[AltItems]:

            # alt_item*
            def _alt() -> ParseResult[AltItems]:

                # ii=alt_item*
                def _item_ii() -> ParseResult[list [AltItem ]]:
                    def _alt_item() -> ParseResult[AltItem]:
                        return self.alt_item()
                    return self._repeat(_alt_item, False)
                ii: list [AltItem ]
                ii, = _item_ii()

                # parse succeeded
                return AltItems (ii),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt_item() [AltItem]: typed_name '=' ~ item | item
    def alt_item(self) -> ParseResult[AltItem]:
        def _rhs() -> ParseResult[AltItem]:

            # typed_name '=' ~ item
            def _alt1() -> ParseResult[AltItem]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # '='
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(22)   # token = "="
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return VarItem (n ,i ),

            # item
            def _alt2() -> ParseResult[AltItem]:

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return VarItem(None, i),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # item() [Item]: '&' '&' ~ item | '&' ~ item | '!' ~ item | '~' | atom
    @memoize
    def item(self) -> ParseResult[Item]:
        def _rhs() -> ParseResult[Item]:

            # '&' '&' ~ item
            def _alt1() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # '&'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return Forced (i ),

            # '&' ~ item
            def _alt2() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return PositiveLookahead (i ),

            # '!' ~ item
            def _alt3() -> ParseResult[Item]:

                # '!'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('!')   # token = "!"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return NegativeLookahead (i ),

            # '~'
            def _alt4() -> ParseResult[Item]:

                # '~'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(31)   # token = "~"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Cut (),

            # atom
            def _alt5() -> ParseResult[Item]:

                # atom
                def _item__atom() -> ParseResult[Atom]:
                    return self.atom()
                _atom: Atom; _result__atom: ParseResult[Atom]
                _result__atom = _item__atom()
                if not _result__atom: return None
                _atom, = _result__atom

                # parse succeeded
                return _atom,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # atom() [Atom]: atom '?' | atom '*' | atom '+' | atom '.' primary '*' |
    #     atom '.' primary '+' | primary
    # Left-recursive leader
    @memoize_left_rec
    def atom(self) -> ParseResult[Atom]:
        def _rhs() -> ParseResult[Atom]:

            # atom '?'
            def _alt1() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '?'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('?')   # token = "?"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Opt (a),

            # atom '*'
            def _alt2() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '*'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat0 (a),

            # atom '+'
            def _alt3() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '+'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat1 (a),

            # atom '.' primary '*'
            def _alt4() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '*'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather0 (sep , node),

            # atom '.' primary '+'
            def _alt5() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '+'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather1 (sep , node),

            # primary
            def _alt6() -> ParseResult[Atom]:

                # primary
                def _item__primary() -> ParseResult[Primary]:
                    return self.primary()
                _primary: Primary; _result__primary: ParseResult[Primary]
                _result__primary = _item__primary()
                if not _result__primary: return None
                _primary, = _result__primary

                # parse succeeded
                return _primary,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
                _alt6,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # primary() [Primary]: '(' ~ alts ')' annotation? | '[' ~ alts ']'
    #     annotation? | NAME arguments? | STRING
    @memoize
    def primary(self) -> ParseResult[Primary]:
        def _rhs() -> ParseResult[Primary]:

            # '(' ~ alts ')' annotation?
            def _alt1() -> ParseResult[Primary]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # typ=annotation?
                def _item_typ() -> ParseResult[list[list[Token]]]:
                    def _annotation() -> ParseResult[list[Token]]:
                        return self.annotation()
                    return self._opt(_annotation)
                typ: list [list[Token]]
                typ, = _item_typ()

                # parse succeeded
                return Group (Rhs (a, Code(typ.val))),

            # '[' ~ alts ']' annotation?
            def _alt2() -> ParseResult[Primary]:

                # '['
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ']'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # typ=annotation?
                def _item_typ() -> ParseResult[list[list[Token]]]:
                    def _annotation() -> ParseResult[list[Token]]:
                        return self.annotation()
                    return self._opt(_annotation)
                typ: list[list[Token]]
                typ, = _item_typ()

                # parse succeeded
                return OptGroup (Rhs (a, Code(typ.val))),

            # NAME arguments?
            def _alt3() -> ParseResult[Primary]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # a=arguments?
                def _item_a() -> ParseResult[list [Args ]]:
                    def _arguments() -> ParseResult[Args]:
                        return self.arguments()
                    return self._opt(_arguments)
                a: list [Args ]
                a, = _item_a()

                # parse succeeded
                return NameLeaf (n , a.val),

            # STRING
            def _alt4() -> ParseResult[Primary]:

                # s=STRING
                def _item_s() -> ParseResult[Token]:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s

                # parse succeeded
                return StringLeaf (s),

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # action() [list[Token]]: "{" target_atoms "}"
    def action(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # "{" target_atoms "}"
            def _alt() -> ParseResult[list[Token]]:

                # "{"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(25)   # token = "{"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # t=target_atoms
                def _item_t() -> ParseResult[list[Token]]:
                    return self.target_atoms()
                t: list[Token]; _result_t: ParseResult[list[Token]]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t

                # "}"
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(26)   # token = "}"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return t,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # annotation() [list[Token]]: "[" target_atoms "]"
    def annotation(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # "[" target_atoms "]"
            def _alt() -> ParseResult[list[Token]]:

                # "["
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # t=target_atoms
                def _item_t() -> ParseResult[list[Token]]:
                    return self.target_atoms()
                t: list[Token]; _result_t: ParseResult[list[Token]]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t

                # "]"
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return t,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arguments() [Args]: '(' arg "," ",".arg+ ","? ')' | '(' arg "," ')' | '('
    #     ')'
    def arguments(self) -> ParseResult[Args]:
        def _rhs() -> ParseResult[Args]:

            # '(' arg "," ",".arg+ ","? ')'
            def _alt1() -> ParseResult[Args]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=arg
                def _item_a() -> ParseResult[Arg]:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ","
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(12)   # token = ","
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # b=",".arg+
                def _item_b() -> ParseResult[list[Arg]]:
                    def _arg() -> ParseResult[Arg]:
                        return self.arg()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._gather(_arg, _sep, True)
                b: list[Arg]; _result_b: ParseResult[list[Arg]]
                _result_b = _item_b()
                if not _result_b: return None
                b, = _result_b

                # ","?
                def _item__opt() -> ParseResult[list[Token]]:
                    def _literal() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._opt(_literal)
                _opt: list[Token]
                _opt, = _item__opt()

                # ')'
                def _item__literal_2() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_2: Token; _result__literal_2: ParseResult[Token]
                _result__literal_2 = _item__literal_2()
                if not _result__literal_2: return None
                _literal_2, = _result__literal_2

                # parse succeeded
                return Args ([a] + b),

            # '(' arg "," ')'
            def _alt2() -> ParseResult[Args]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=arg
                def _item_a() -> ParseResult[Arg]:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ","
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(12)   # token = ","
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # ')'
                def _item__literal_2() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_2: Token; _result__literal_2: ParseResult[Token]
                _result__literal_2 = _item__literal_2()
                if not _result__literal_2: return None
                _literal_2, = _result__literal_2

                # parse succeeded
                return Args ([a]),

            # '(' ')'
            def _alt3() -> ParseResult[Args]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Args (),

            _alts = [
                _alt1,
                _alt2,
                _alt3,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arg() [Arg]: arg_atom+
    def arg(self) -> ParseResult[Arg]:
        def _rhs() -> ParseResult[Arg]:

            # arg_atom+
            def _alt() -> ParseResult[Arg]:

                # a=arg_atom+
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _arg_atom() -> ParseResult[list[Token]]:
                        return self.arg_atom()
                    return self._repeat(_arg_atom, True)
                a: list[list[Token]]; _result_a: ParseResult[list[list[Token]]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Arg (Code([*chain(*a)])),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arg_atom() [list[Token]]: !"," target_atom
    def arg_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # !"," target_atom
            def _alt() -> ParseResult[list[Token]]:

                # !","
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # a=target_atom
                def _item_a() -> ParseResult[list[Token]]:
                    return self.target_atom()
                a: list[Token]; _result_a: ParseResult[list[Token]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return a,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # target_atoms() [list[Token]]: target_atom+
    def target_atoms(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # target_atom+
            def _alt() -> ParseResult[list[Token]]:

                # a=target_atom+
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _target_atom() -> ParseResult[list[Token]]:
                        return self.target_atom()
                    return self._repeat(_target_atom, True)
                a: list[list[Token]]; _result_a: ParseResult[list[list[Token]]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return [*chain.from_iterable(a)],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # target_atom() [list[Token]]: "(" target_atoms? ")" | "{" target_atoms? "}"
    #     | "[" target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" |
    #     ":" | !")" !"}" !"]" OP
    @memoize
    def target_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # "(" target_atoms? ")"
            def _alt1() -> ParseResult[list[Token]]:

                # l="("
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r=")"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # "{" target_atoms? "}"
            def _alt2() -> ParseResult[list[Token]]:

                # l="{"
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(25)   # token = "{"
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r="}"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(26)   # token = "}"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # "[" target_atoms? "]"
            def _alt3() -> ParseResult[list[Token]]:

                # l="["
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r="]"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # NAME "*"
            def _alt4() -> ParseResult[list[Token]]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # star="*"
                def _item_star() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                star: Token; _result_star: ParseResult[Token]
                _result_star = _item_star()
                if not _result_star: return None
                star, = _result_star

                # parse succeeded
                return [n, star],

            # NAME
            def _alt5() -> ParseResult[list[Token]]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return [n],

            # NUMBER
            def _alt6() -> ParseResult[list[Token]]:

                # n=NUMBER
                def _item_n() -> ParseResult[Token]:
                    return self._number()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return [n],

            # STRING
            def _alt7() -> ParseResult[list[Token]]:

                # s=STRING
                def _item_s() -> ParseResult[Token]:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s

                # parse succeeded
                return [s],

            # "?"
            def _alt8() -> ParseResult[list[Token]]:

                # c="?"
                def _item_c() -> ParseResult[Token]:
                    return self._expect_char('?')   # token = "?"
                c: Token; _result_c: ParseResult[Token]
                _result_c = _item_c()
                if not _result_c: return None
                c, = _result_c

                # parse succeeded
                return [c],

            # ":"
            def _alt9() -> ParseResult[list[Token]]:

                # c=":"
                def _item_c() -> ParseResult[Token]:
                    return self._expect_type(11)   # token = ":"
                c: Token; _result_c: ParseResult[Token]
                _result_c = _item_c()
                if not _result_c: return None
                c, = _result_c

                # parse succeeded
                return [c],

            # !")" !"}" !"]" OP
            def _alt10() -> ParseResult[list[Token]]:

                # !")"
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(8)   # token = ")"
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # !"}"
                def _item__lookahead_1() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(26)   # token = "}"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_1(): return None

                # !"]"
                def _item__lookahead_2() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(10)   # token = "]"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_2(): return None

                # op=OP
                def _item_op() -> ParseResult[Token]:
                    return self._op()
                op: Token; _result_op: ParseResult[Token]
                _result_op = _item_op()
                if not _result_op: return None
                op, = _result_op

                # parse succeeded
                return [op],

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
                _alt6,
                _alt7,
                _alt8,
                _alt9,
                _alt10,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
