#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional, Callable, cast

from pegen.parser import (
    memoize, memoize_left_rec, logger, Parser, ParseResult, RuleDescr, RuleAltDescr, cut_sentinel
    )
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    AltItem,
    AltItems,
    Arg,
    Args,
    Cut,
    Forced,
    Gather0,
    Gather1,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NegativeLookahead,
    ObjName,
    Opt,
    OptGroup,
    Param,
    Params,
    PositiveLookahead,
    Primary,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
    VarItem,
)

from pegen.target_code import Code

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    # start() [Grammar]: g=grammar $
    def start(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:
            def _alt() -> ParseResult[Grammar]:

                # g=grammar
                def _item_g() -> ParseResult[Grammar]:
                    return self.grammar()
                g: Grammar; _result_g: ParseResult[Grammar]
                _result_g = _item_g()
                if not _result_g: return None
                g, = _result_g

                # $
                def _item__ENDMARKER() -> ParseResult[Token]:
                    return self._expect_type(0)
                _ENDMARKER: Token; _result__ENDMARKER: ParseResult[Token]
                _result__ENDMARKER = _item__ENDMARKER()
                if not _result__ENDMARKER: return None
                _ENDMARKER, = _result__ENDMARKER

                # parse succeeded
                return g,

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'g=grammar $'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'start', 'g=grammar $')
        return self._rule(_rule_descriptor)

    # grammar() [Grammar]: metas=meta* rules=rule+
    def grammar(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:
            def _alt() -> ParseResult[Grammar]:

                # metas=meta*
                def _item_metas() -> ParseResult[list [ Meta ]]:
                    def _meta() -> ParseResult[Meta]:
                        return self.meta()
                    return self._repeat(cast(Callable [ [ ] , ParseResult ], _meta), False)
                metas: list [ Meta ]
                metas, = _item_metas()

                # rules=rule+
                def _item_rules() -> ParseResult[list [ Rule ]]:
                    def _rule() -> ParseResult[Rule]:
                        return self.rule()
                    return self._repeat(cast(Callable [ [ ] , ParseResult ], _rule), True)
                rules: list [ Rule ]; _result_rules: ParseResult[list [ Rule ]]
                _result_rules = _item_rules()
                if not _result_rules: return None
                rules, = _result_rules

                # parse succeeded
                return Grammar (rules , metas),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'metas=meta* rules=rule+'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'grammar', 'metas=meta* rules=rule+')
        return self._rule(_rule_descriptor)

    # meta() [Meta]: "@" name=NAME val=metavalue NEWLINE
    def meta(self) -> ParseResult[Meta]:
        def _rhs() -> ParseResult[Meta]:
            def _alt() -> ParseResult[Meta]:

                # "@"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(49)   # token = "@"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # name=NAME
                def _item_name() -> ParseResult[Token]:
                    return self._name()
                name: Token; _result_name: ParseResult[Token]
                _result_name = _item_name()
                if not _result_name: return None
                name, = _result_name

                # val=metavalue
                def _item_val() -> ParseResult[str]:
                    return self.metavalue()
                val: str; _result_val: ParseResult[str]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # parse succeeded
                return Meta (name . string , val),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', '"@" name=NAME val=metavalue NEWLINE'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'meta', '"@" name=NAME val=metavalue NEWLINE')
        return self._rule(_rule_descriptor)

    # metavalue() [str]: val=NAME | val=STRING | <always>
    def metavalue(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:
            def _alt1() -> ParseResult[str]:

                # val=NAME
                def _item_val() -> ParseResult[Token]:
                    return self._name()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return val . string,
            def _alt2() -> ParseResult[str]:

                # val=STRING
                def _item_val() -> ParseResult[Token]:
                    return self._string()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return literal_eval (val . string),
            def _alt3() -> ParseResult[str]:

                # parse succeeded
                return None,

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', 'val=NAME'),
                RuleAltDescr(_alt2, '_alt2', 'val=STRING'),
                RuleAltDescr(_alt3, '_alt3', '<always>'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'metavalue', 'val=NAME | val=STRING | <always>')
        return self._rule(_rule_descriptor)

    # rule() [Rule]: n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE
    #     aa=more_alts?
    def rule(self) -> ParseResult[Rule]:
        def _rhs() -> ParseResult[Rule]:
            def _alt() -> ParseResult[Rule]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # m=memoflag?
                def _item_m() -> ParseResult[list [ str ]]:
                    def _memoflag() -> ParseResult[str]:
                        return self.memoflag()
                    return self._opt(cast(Callable [ [ ] , ParseResult ], _memoflag))
                m: list [ str ]
                m, = _item_m()

                # ":"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(11)   # token = ":"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=maybe_alts?
                def _item_a() -> ParseResult[list[Rhs]]:
                    def _maybe_alts() -> ParseResult[Rhs]:
                        return self.maybe_alts()
                    return self._opt(cast(Callable [ [ ] , ParseResult ], _maybe_alts))
                a: list[Rhs]
                a, = _item_a()

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # aa=more_alts?
                def _item_aa() -> ParseResult[list[Rhs]]:
                    def _more_alts() -> ParseResult[Rhs]:
                        return self.more_alts()
                    return self._opt(cast(Callable [ [ ] , ParseResult ], _more_alts))
                aa: list[Rhs]
                aa, = _item_aa()

                # parse succeeded
                return Rule ( n , Rhs ( [ * chain ( * a , * aa ) ] ) , memo = m ),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts?'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'rule', 'n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts?')
        return self._rule(_rule_descriptor)

    # params() [Params]: !memoflag '(' n=','.param+ [','] ')' | '(' ')'
    def params(self) -> ParseResult[Params]:
        def _rhs() -> ParseResult[Params]:
            def _alt1() -> ParseResult[Params]:

                # !memoflag
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[str]:
                        return self.memoflag()
                    return self._lookahead(False, cast(Callable [[],ParseResult ], _atom))
                if not _item__lookahead(): return None

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # n=','.param+
                def _item_n() -> ParseResult[list [Param ]]:
                    def _param() -> ParseResult[Param]:
                        return self.param()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._gather(cast(Callable [[],ParseResult ], _param), cast(Callable [[],ParseResult ], _sep), True)
                n: list [Param ]; _result_n: ParseResult[list [Param ]]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # [',']
                def _item__opt() -> ParseResult[list [Any ]]:
                    def _rhs() -> ParseResult[Any]:
                        def _alt() -> ParseResult[Any]:

                            # ','
                            def _item__literal() -> ParseResult[Token]:
                                return self._expect_type(12)   # token = ","
                            _literal: Token; _result__literal: ParseResult[Token]
                            _result__literal = _item__literal()
                            if not _result__literal: return None
                            _literal, = _result__literal

                            # parse succeeded
                            return _literal,

                        _alt_descriptors = [
                            RuleAltDescr(_alt, '_alt', "','"),
                        ]
                        return self._alts(_alt_descriptors)
                    return self._opt(cast(Callable [[],ParseResult ], _rhs))
                _opt: list [Any ]
                _opt, = _item__opt()

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params (n),
            def _alt2() -> ParseResult[Params]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params ([]),

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', "!memoflag '(' n=','.param+ [','] ')'"),
                RuleAltDescr(_alt2, '_alt2', "'(' ')'"),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'params', "!memoflag '(' n=','.param+ [','] ')' | '(' ')'")
        return self._rule(_rule_descriptor)

    # param() [Param]: n=typed_name
    def param(self) -> ParseResult[Param]:
        def _rhs() -> ParseResult[Param]:
            def _alt() -> ParseResult[Param]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return Param (n),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'n=typed_name'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'param', 'n=typed_name')
        return self._rule(_rule_descriptor)

    # typed_name() [TypedName]: n=NAME p=params? typ=annotation?
    def typed_name(self) -> ParseResult[TypedName]:
        def _rhs() -> ParseResult[TypedName]:
            def _alt() -> ParseResult[TypedName]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # p=params?
                def _item_p() -> ParseResult[list [Params ]]:
                    def _params() -> ParseResult[Params]:
                        return self.params()
                    return self._opt(cast(Callable [[],ParseResult ], _params))
                p: list [Params ]
                p, = _item_p()

                # typ=annotation?
                def _item_typ() -> ParseResult[list [str ]]:
                    def _annotation() -> ParseResult[str]:
                        return self.annotation()
                    return self._opt(cast(Callable [[],ParseResult ], _annotation))
                typ: list [str ]
                typ, = _item_typ()

                # parse succeeded
                return TypedName (n .string ,Code (typ .val ),p ),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'n=NAME p=params? typ=annotation?'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'typed_name', 'n=NAME p=params? typ=annotation?')
        return self._rule(_rule_descriptor)

    # memoflag() [str]: '(' "memo" ')'
    def memoflag(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:
            def _alt() -> ParseResult[str]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # "memo"
                def _item__keyword() -> ParseResult[Token]:
                    return self._expect_name("memo")   # keyword='memo'
                _keyword: Token; _result__keyword: ParseResult[Token]
                _result__keyword = _item__keyword()
                if not _result__keyword: return None
                _keyword, = _result__keyword

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return "memo",

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', '\'(\' "memo" \')\''),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'memoflag', '\'(\' "memo" \')\'')
        return self._rule(_rule_descriptor)

    # alts() [Rhs]: a="|".alt+
    def alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:
            def _alt() -> ParseResult[Rhs]:

                # a="|".alt+
                def _item_a() -> ParseResult[list [Alt ]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(cast(Callable [[],ParseResult ], _alt), cast(Callable [[],ParseResult ], _sep), True)
                a: list [Alt ]; _result_a: ParseResult[list [Alt ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs (a),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'a="|".alt+'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'alts', 'a="|".alt+')
        return self._rule(_rule_descriptor)

    # maybe_alts() [Rhs]: !NEWLINE a="|".alt+ | <always>
    @memoize
    def maybe_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:
            def _alt1() -> ParseResult[Rhs]:

                # !NEWLINE
                def _item__lookahead() -> ParseStatus:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(4)
                    return self._lookahead(False, cast(Callable [[],ParseResult ], _atom))
                if not _item__lookahead(): return None

                # a="|".alt+
                def _item_a() -> ParseResult[list [Alt ]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(cast(Callable [[],ParseResult ], _alt), cast(Callable [[],ParseResult ], _sep), True)
                a: list [Alt ]; _result_a: ParseResult[list [Alt ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs (a),
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs ([]),

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', '!NEWLINE a="|".alt+'),
                RuleAltDescr(_alt2, '_alt2', '<always>'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'maybe_alts', '!NEWLINE a="|".alt+ | <always>')
        return self._rule(_rule_descriptor)

    # more_alts() [Rhs]: INDENT a=("|" b=alts NEWLINE)+ DEDENT | <always>
    @memoize
    def more_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:
            def _alt1() -> ParseResult[Rhs]:

                # INDENT
                def _item__INDENT() -> ParseResult[Token]:
                    return self._expect_type(5)
                _INDENT: Token; _result__INDENT: ParseResult[Token]
                _result__INDENT = _item__INDENT()
                if not _result__INDENT: return None
                _INDENT, = _result__INDENT

                # a=("|" b=alts NEWLINE)+
                def _item_a() -> ParseResult[list [Any ]]:
                    def _group() -> ParseResult[Any]:
                        def _rhs() -> ParseResult[Any]:
                            def _alt() -> ParseResult[Any]:

                                # "|"
                                def _item__literal() -> ParseResult[Token]:
                                    return self._expect_type(18)   # token = "|"
                                _literal: Token; _result__literal: ParseResult[Token]
                                _result__literal = _item__literal()
                                if not _result__literal: return None
                                _literal, = _result__literal

                                # b=alts
                                def _item_b() -> ParseResult[Rhs]:
                                    return self.alts()
                                b: Rhs; _result_b: ParseResult[Rhs]
                                _result_b = _item_b()
                                if not _result_b: return None
                                b, = _result_b

                                # NEWLINE
                                def _item__NEWLINE() -> ParseResult[Token]:
                                    return self._expect_type(4)
                                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                                _result__NEWLINE = _item__NEWLINE()
                                if not _result__NEWLINE: return None
                                _NEWLINE, = _result__NEWLINE

                                # parse succeeded
                                return b,

                            _alt_descriptors = [
                                RuleAltDescr(_alt, '_alt', '"|" b=alts NEWLINE'),
                            ]
                            return self._alts(_alt_descriptors)
                        return _rhs()
                    return self._repeat(cast(Callable [[],ParseResult ], _group), True)
                a: list [Any ]; _result_a: ParseResult[list [Any ]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # DEDENT
                def _item__DEDENT() -> ParseResult[Token]:
                    return self._expect_type(6)
                _DEDENT: Token; _result__DEDENT: ParseResult[Token]
                _result__DEDENT = _item__DEDENT()
                if not _result__DEDENT: return None
                _DEDENT, = _result__DEDENT

                # parse succeeded
                return Rhs (chain (* a)),
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs (()),

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', 'INDENT a=("|" b=alts NEWLINE)+ DEDENT'),
                RuleAltDescr(_alt2, '_alt2', '<always>'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'more_alts', 'INDENT a=("|" b=alts NEWLINE)+ DEDENT | <always>')
        return self._rule(_rule_descriptor)

    # alt() [Alt]: i=alt_items a=action?
    def alt(self) -> ParseResult[Alt]:
        def _rhs() -> ParseResult[Alt]:
            def _alt() -> ParseResult[Alt]:

                # i=alt_items
                def _item_i() -> ParseResult[AltItems]:
                    return self.alt_items()
                i: AltItems; _result_i: ParseResult[AltItems]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # a=action?
                def _item_a() -> ParseResult[list [str ]]:
                    def _action() -> ParseResult[str]:
                        return self.action()
                    return self._opt(cast(Callable [[],ParseResult ], _action))
                a: list [str ]
                a, = _item_a()

                # parse succeeded
                return Alt (i , action = Code(a.val)),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'i=alt_items a=action?'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'alt', 'i=alt_items a=action?')
        return self._rule(_rule_descriptor)

    # alt_items() [AltItems]: ii=alt_item*
    def alt_items(self) -> ParseResult[AltItems]:
        def _rhs() -> ParseResult[AltItems]:
            def _alt() -> ParseResult[AltItems]:

                # ii=alt_item*
                def _item_ii() -> ParseResult[list [AltItem ]]:
                    def _alt_item() -> ParseResult[AltItem]:
                        return self.alt_item()
                    return self._repeat(cast(Callable [[],ParseResult ], _alt_item), False)
                ii: list [AltItem ]
                ii, = _item_ii()

                # parse succeeded
                return AltItems (ii),

            _alt_descriptors = [
                RuleAltDescr(_alt, '_alt', 'ii=alt_item*'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'alt_items', 'ii=alt_item*')
        return self._rule(_rule_descriptor)

    # alt_item() [AltItem]: n=typed_name '=' ~ i=item | item
    def alt_item(self) -> ParseResult[AltItem]:
        def _rhs() -> ParseResult[AltItem]:
            def _alt1() -> ParseResult[AltItem]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # '='
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(22)   # token = "="
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return cut_sentinel
                i, = _result_i

                # parse succeeded
                return VarItem (n ,i ),
            def _alt2() -> ParseResult[AltItem]:

                # item
                def _item__item() -> ParseResult[Item]:
                    return self.item()
                _item: Item; _result__item: ParseResult[Item]
                _result__item = _item__item()
                if not _result__item: return None
                _item, = _result__item

                # parse succeeded
                return _item,

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', "n=typed_name '=' ~ i=item"),
                RuleAltDescr(_alt2, '_alt2', 'item'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'alt_item', "n=typed_name '=' ~ i=item | item")
        return self._rule(_rule_descriptor)

    # item() [Item]: '&' '&' ~ i=item | '&' ~ i=item | '!' ~ i=item | '~' | atom
    @memoize
    def item(self) -> ParseResult[Item]:
        def _rhs() -> ParseResult[Item]:
            def _alt1() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # '&'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # ~

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return cut_sentinel
                i, = _result_i

                # parse succeeded
                return Forced (i ),
            def _alt2() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return cut_sentinel
                i, = _result_i

                # parse succeeded
                return PositiveLookahead (i ),
            def _alt3() -> ParseResult[Item]:

                # '!'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('!')   # token = "!"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return cut_sentinel
                i, = _result_i

                # parse succeeded
                return NegativeLookahead (i ),
            def _alt4() -> ParseResult[Item]:

                # '~'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(31)   # token = "~"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Cut (),
            def _alt5() -> ParseResult[Item]:

                # atom
                def _item__atom() -> ParseResult[Atom]:
                    return self.atom()
                _atom: Atom; _result__atom: ParseResult[Atom]
                _result__atom = _item__atom()
                if not _result__atom: return None
                _atom, = _result__atom

                # parse succeeded
                return _atom,

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', "'&' '&' ~ i=item"),
                RuleAltDescr(_alt2, '_alt2', "'&' ~ i=item"),
                RuleAltDescr(_alt3, '_alt3', "'!' ~ i=item"),
                RuleAltDescr(_alt4, '_alt4', "'~'"),
                RuleAltDescr(_alt5, '_alt5', 'atom'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'item', "'&' '&' ~ i=item | '&' ~ i=item | '!' ~ i=item | '~' | atom")
        return self._rule(_rule_descriptor)

    # atom() [Atom]: a=atom '?' | a=atom '*' | a=atom '+' | sep=atom '.'
    #     node=primary '*' | sep=atom '.' node=primary '+' | primary
    # Left-recursive leader
    @memoize_left_rec
    def atom(self) -> ParseResult[Atom]:
        def _rhs() -> ParseResult[Atom]:
            def _alt1() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '?'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('?')   # token = "?"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Opt (a),
            def _alt2() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '*'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat0 (a),
            def _alt3() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '+'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat1 (a),
            def _alt4() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '*'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather0 (sep , node),
            def _alt5() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '+'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather1 (sep , node),
            def _alt6() -> ParseResult[Atom]:

                # primary
                def _item__primary() -> ParseResult[Primary]:
                    return self.primary()
                _primary: Primary; _result__primary: ParseResult[Primary]
                _result__primary = _item__primary()
                if not _result__primary: return None
                _primary, = _result__primary

                # parse succeeded
                return _primary,

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', "a=atom '?'"),
                RuleAltDescr(_alt2, '_alt2', "a=atom '*'"),
                RuleAltDescr(_alt3, '_alt3', "a=atom '+'"),
                RuleAltDescr(_alt4, '_alt4', "sep=atom '.' node=primary '*'"),
                RuleAltDescr(_alt5, '_alt5', "sep=atom '.' node=primary '+'"),
                RuleAltDescr(_alt6, '_alt6', 'primary'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'atom', "a=atom '?' | a=atom '*' | a=atom '+' | sep=atom '.' node=primary '*' | sep=atom '.' node=primary '+' | primary")
        return self._rule(_rule_descriptor)

    # primary() [Primary]: '(' ~ a=alts ')' typ=annotation? | '[' ~ a=alts ']'
    #     typ=annotation? | n=NAME a=arguments? | s=STRING
    @memoize
    def primary(self) -> ParseResult[Primary]:
        def _rhs() -> ParseResult[Primary]:
            def _alt1() -> ParseResult[Primary]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return cut_sentinel
                _literal_1, = _result__literal_1

                # typ=annotation?
                def _item_typ() -> ParseResult[list [str ]]:
                    def _annotation() -> ParseResult[str]:
                        return self.annotation()
                    return self._opt(cast(Callable [[],ParseResult ], _annotation))
                typ: list [str ]
                typ, = _item_typ()

                # parse succeeded
                return Group (Rhs (a, Code(typ.val))),
            def _alt2() -> ParseResult[Primary]:

                # '['
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a

                # ']'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return cut_sentinel
                _literal_1, = _result__literal_1

                # typ=annotation?
                def _item_typ() -> ParseResult[list [str ]]:
                    def _annotation() -> ParseResult[str]:
                        return self.annotation()
                    return self._opt(cast(Callable [[],ParseResult ], _annotation))
                typ: list [str ]
                typ, = _item_typ()

                # parse succeeded
                return OptGroup (Rhs (a, Code(typ.val))),
            def _alt3() -> ParseResult[Primary]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # a=arguments?
                def _item_a() -> ParseResult[list [Args ]]:
                    def _arguments() -> ParseResult[Args]:
                        return self.arguments()
                    return self._opt(cast(Callable [[],ParseResult ], _arguments))
                a: list [Args ]
                a, = _item_a()

                # parse succeeded
                return NameLeaf (n , a.val),
            def _alt4() -> ParseResult[Primary]:

                # s=STRING
                def _item_s() -> ParseResult[Token]:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s

                # parse succeeded
                return StringLeaf (s),

            _alt_descriptors = [
                RuleAltDescr(_alt1, '_alt1', "'(' ~ a=alts ')' typ=annotation?"),
                RuleAltDescr(_alt2, '_alt2', "'[' ~ a=alts ']' typ=annotation?"),
                RuleAltDescr(_alt3, '_alt3', 'n=NAME a=arguments?'),
                RuleAltDescr(_alt4, '_alt4', 's=STRING'),
            ]
            return self._alts(_alt_descriptors)
        _rule_descriptor = RuleDescr(_rhs, 'primary', "'(' ~ a=alts ')' typ=annotation? | '[' ~ a=alts ']' typ=annotation? | n=NAME a=arguments? | s=STRING")
        return self._rule(_rule_descriptor)

    # action: "{" target_atoms "}"
    def action(self) -> ParseResult[list[Token]]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "{" target_atoms "}"
                # "{"
                def _item__literal_var() -> Token:
                    return self._expect_type(25)   # token={
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # t=target_atoms
                def _item_t() -> str:
                    return self.target_atoms()
                t: list[Token]; _result_t: ParseResult[list[Token]]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t
                # "}"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(26)   # token=}
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return t,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"{" target_atoms "}"'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # annotation: "[" target_atoms "]"
    def annotation(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "[" target_atoms "]"
                # "["
                def _item__literal_var() -> Token:
                    return self._expect_type(9)   # token=[
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms
                def _item_t() -> str:
                    return self.target_atoms()
                t: list[Token]; _result_t: ParseResult[list[Token]]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t
                # "]"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(10)   # token=]
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return t,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"[" target_atoms "]"'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # arguments: '(' arg "," ",".arg+ ","? ')' | '(' arg "," ')' | '(' ')'
    def arguments(self) -> ParseResult[Args]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '(' arg "," ",".arg+ ","? ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # arg
                def _item_a() -> Arg:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # ","
                def _item__literal_var_1() -> Token:
                    return self._expect_type(12)   # token=,
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # ",".arg+
                def _item_b() -> ParseResult[list]:
                    def _node() -> Arg:
                        return self.arg()
                    def sep() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._loop(_node, sep, True)
                b: ParseResult[list]; _result_b: ParseResult[ParseResult[list]]
                _result_b = _item_b()
                if not _result_b: return None
                b, = _result_b
                # ","?
                def _item_opt_var() -> ParseResult[Any]:
                    def _item() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._opt(_item)
                opt_var: ParseResult[Any]
                opt_var, = _item_opt_var()
                # ')'
                def _item__literal_var_2() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_2: Token; _result__literal_var_2: ParseResult[Token]
                _result__literal_var_2 = _item__literal_var_2()
                if not _result__literal_var_2: return None
                _literal_var_2, = _result__literal_var_2
                # parse succeeded
                return Args ([a] + b),
            def _alt_2() -> Any:  # '(' arg "," ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # arg
                def _item_a() -> Arg:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # ","
                def _item__literal_var_1() -> Token:
                    return self._expect_type(12)   # token=,
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # ')'
                def _item__literal_var_2() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_2: Token; _result__literal_var_2: ParseResult[Token]
                _result__literal_var_2 = _item__literal_var_2()
                if not _result__literal_var_2: return None
                _literal_var_2, = _result__literal_var_2
                # parse succeeded
                return Args ([a]),
            def _alt_3() -> Any:  # '(' ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Args (),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, '\'(\' arg "," ",".arg+ ","? \')\''),
                RuleAltDescr(_alt_2, _alt_2, '\'(\' arg "," \')\''),
                RuleAltDescr(_alt_3, _alt_3, "'(' ')'"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # TODO: convert to return a list[Token] instead of a str...

    # arg: arg_atom+
    def arg(self) -> ParseResult[Arg]:
        def _rhs() -> Any:
            def _alt() -> Any:  # arg_atom+
                # arg_atom+
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _node() -> ParseResult[list[Token]]:
                        return self.arg_atom()
                    return self._loop(_node, None, True)
                a: list[list[Token]]; _result_a: ParseResult[list[list[Token]]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return Arg (Code([*chain(*a)])),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'arg_atom+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # arg_atom: !"," target_atom
    def arg_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:
            def _alt() -> ParseResult[list[Token]]:  # !"," target_atom
                # !","
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                # target_atom
                def _item_a() -> ParseResult[list[Token]]:
                    return self.target_atom()
                a: list[Token]; _result_a: ParseResult[list[Token]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return a,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '!"," target_atom'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # target_atoms: target_atom+
    def target_atoms(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:
            def _alt() -> ParseResult[list[Token]]:  # target_atom+
                # target_atom+
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _node() -> ParseResult[list[Token]]:
                        return self.target_atom()
                    return self._repeat(_node, True)
                a: list[list[Token]]; _result_a: ParseResult[list[list[Token]]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return [*chain.from_iterable(a)],
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'target_atom+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    #@memoize
    # target_atom: "(" target_atoms? ")" | "{" target_atoms? "}" | "["
    #     target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" |
    #     !")" !"}" !"]" OP
    def target_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:
            def _alt_1() -> ParseResult[list[Token]]:  # "(" target_atoms? ")"
                # "("
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: list[list[Token]]
                atoms, = _item_atoms()
                # ")"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return [_literal_var, *chain(*(atoms)), _literal_var_1],
            def _alt_2() -> Any:  # "{" target_atoms? "}"
                # "{"
                def _item__literal_var() -> Token:
                    return self._expect_type(25)   # token={
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: ParseResult[Any]
                atoms, = _item_atoms()
                # "}"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(26)   # token=}
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return [_literal_var, *chain(*(atoms)), _literal_var_1],
            def _alt_3() -> Any:  # "[" target_atoms? "]"
                # "["
                def _item__literal_var() -> Token:
                    return self._expect_type(9)   # token=[
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: ParseResult[Any]
                atoms, = _item_atoms()
                # "]"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(10)   # token=]
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return [_literal_var, *chain(*(atoms)), _literal_var_1],
            def _alt_4() -> Any:  # NAME "*"
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # "*"
                def _item__literal_var() -> Token:
                    return self._expect_type(16)   # token=*
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return [n, _literal_var],
            def _alt_5() -> Any:  # NAME
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # parse succeeded
                return [n],
            def _alt_6() -> Any:  # NUMBER
                # NUMBER
                def _item_n() -> Token:
                    return self._number()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # parse succeeded
                return [n],
            def _alt_7() -> Any:  # STRING
                # STRING
                def _item_s() -> Token:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s
                # parse succeeded
                return [s],
            def _alt_8() -> Any:  # "?"
                # "?"
                def _item__literal_var() -> Token:
                    return self._expect_char('?')   # token=?
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return [_literal_var],
            def _alt_9() -> Any:  # ":"
                # ":"
                def _item__literal_var() -> Token:
                    return self._expect_type(11)   # token=:
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return [_literal_var],
            def _alt_10() -> Any:  # !")" !"}" !"]" OP
                # !")"
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(8)   # token=)
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                # !"}"
                def _item__lookahead_var_1() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(26)   # token=}
                    return self._lookahead(False, atom)
                _lookahead_var_1: ParseResult[bool]; _result__lookahead_var_1: ParseResult[ParseResult[bool]]
                _result__lookahead_var_1 = _item__lookahead_var_1()
                if not _result__lookahead_var_1: return None
                # !"]"
                def _item__lookahead_var_2() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(10)   # token=]
                    return self._lookahead(False, atom)
                _lookahead_var_2: ParseResult[bool]; _result__lookahead_var_2: ParseResult[ParseResult[bool]]
                _result__lookahead_var_2 = _item__lookahead_var_2()
                if not _result__lookahead_var_2: return None
                # OP
                def _item_op() -> Token:
                    return self._op()
                op: Token; _result_op: ParseResult[Token]
                _result_op = _item_op()
                if not _result_op: return None
                op, = _result_op
                # parse succeeded
                return [op],
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, '"(" target_atoms? ")"'),
                RuleAltDescr(_alt_2, _alt_2, '"{" target_atoms? "}"'),
                RuleAltDescr(_alt_3, _alt_3, '"[" target_atoms? "]"'),
                RuleAltDescr(_alt_4, _alt_4, 'NAME "*"'),
                RuleAltDescr(_alt_5, _alt_5, 'NAME'),
                RuleAltDescr(_alt_6, _alt_6, 'NUMBER'),
                RuleAltDescr(_alt_7, _alt_7, 'STRING'),
                RuleAltDescr(_alt_8, _alt_8, '"?"'),
                RuleAltDescr(_alt_9, _alt_9, '":"'),
                RuleAltDescr(_alt_10, _alt_10, '!")" !"}" !"]" OP'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()


    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
