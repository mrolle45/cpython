#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser
from ast import literal_eval
from itertools import chain

from pegen.grammar import (
    Alt,
    Alts,
    Args,
    Cut,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NamedItem,
    NamedItems,
    NegativeLookahead,
    Opt,
    Params,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    TypedName,
    Grammar,
    StringLeaf,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    @memoize
    def start(self) -> Optional[Grammar]:
        # start: grammar $
        mark = self._mark()
        if (
            (grammar := self.grammar())
            and
            (_endmarker := self.expect('ENDMARKER'))
        ):
            return grammar
        self._reset(mark)
        return None

    @memoize
    def grammar(self) -> Optional[Grammar]:
        # grammar: meta* rule+
        mark = self._mark()
        if (
            (metas := self._loop0_1(),)
            and
            (rules := self._loop1_2())
        ):
            return Grammar (rules , metas)
        self._reset(mark)
        return None

    @memoize
    def meta(self) -> Optional[Meta]:
        # meta: "@" NAME metavalue? NEWLINE
        mark = self._mark()
        if (
            (literal := self.expect("@"))
            and
            (name := self.name())
            and
            (val := self.metavalue(),)
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return Meta (name . string , val)
        self._reset(mark)
        return None

    @memoize
    def metavalue(self) -> Optional[Optional [str]]:
        # metavalue: NAME | STRING | <always>
        mark = self._mark()
        if (
            (val := self.name())
        ):
            return val . string
        self._reset(mark)
        if (
            (val := self.string())
        ):
            return literal_eval (val . string)
        self._reset(mark)
        if (
            True
        ):
            return None
        self._reset(mark)
        return None

    @memoize
    def rule(self) -> Optional[Rule]:
        # rule: typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
        mark = self._mark()
        if (
            (n := self.typed_name())
            and
            (m := self.memoflag(),)
            and
            (literal := self.expect(":"))
            and
            (a := self.maybe_alts(),)
            and
            (_newline := self.expect('NEWLINE'))
            and
            (aa := self.more_alts(),)
        ):
            return Rule (n , Rhs (a + aa) , memo = m)
        self._reset(mark)
        return None

    @memoize
    def params(self) -> Optional[Params]:
        # params: !memoflag '(' ','.typed_name+ [[Alt([NamedItem(None, StringLeaf("','"))])]] ')' | '(' ')'
        mark = self._mark()
        if (
            (_lookahead := self.negative_lookahead(self.memoflag, ))
            and
            (literal := self.expect('('))
            and
            (n := self._gather_3())
            and
            (opt := self.expect(','),)
            and
            (literal_1 := self.expect(')'))
        ):
            return Params (n)
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (literal_1 := self.expect(')'))
        ):
            return Params ([])
        self._reset(mark)
        return None

    @memoize
    def typed_name(self) -> Optional[TypedName]:
        # typed_name: NAME params? annotation?
        mark = self._mark()
        if (
            (n := self.name())
            and
            (p := self.params(),)
            and
            (a := self.annotation(),)
        ):
            return TypedName (n . string , p , a)
        self._reset(mark)
        return None

    @memoize
    def memoflag(self) -> Optional[str]:
        # memoflag: '(' "memo" ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (literal_1 := self.expect("memo"))
            and
            (literal_2 := self.expect(')'))
        ):
            return "memo"
        self._reset(mark)
        return None

    @memoize
    def alts(self) -> Optional[Alts]:
        # alts: "|".alt+
        mark = self._mark()
        if (
            (a := self._gather_5())
        ):
            return Alts (a)
        self._reset(mark)
        return None

    @memoize
    def maybe_alts(self) -> Optional[Alts]:
        # maybe_alts: !NEWLINE "|".alt+ | <always>
        mark = self._mark()
        if (
            (_lookahead := self.negative_lookahead(self.expect, 'NEWLINE'))
            and
            (a := self._gather_7())
        ):
            return Alts (a)
        self._reset(mark)
        if (
            True
        ):
            return Alts ()
        self._reset(mark)
        return None

    @memoize
    def more_alts(self) -> Optional[Alts]:
        # more_alts: INDENT (("|" alts NEWLINE))+ DEDENT | <always>
        mark = self._mark()
        if (
            (_indent := self.expect('INDENT'))
            and
            (a := self._loop1_9())
            and
            (_dedent := self.expect('DEDENT'))
        ):
            return Alts (chain (* a))
        self._reset(mark)
        if (
            True
        ):
            return Alts ()
        self._reset(mark)
        return None

    @memoize
    def alt(self) -> Optional[Alt]:
        # alt: items endmarker action?
        mark = self._mark()
        if (
            (i := self.items())
            and
            (e := self.endmarker())
            and
            (a := self.action(),)
        ):
            return Alt (i + e , action = a)
        self._reset(mark)
        return None

    @memoize
    def items(self) -> Optional[NamedItems]:
        # items: named_item*
        mark = self._mark()
        if (
            (n := self._loop0_10(),)
        ):
            return NamedItems (n)
        self._reset(mark)
        return None

    @memoize
    def named_item(self) -> Optional[NamedItem]:
        # named_item: typed_name '=' ~ item | item | forced_atom | lookahead | cut
        mark = self._mark()
        cut = False
        if (
            (n := self.typed_name())
            and
            (literal := self.expect('='))
            and
            (cut := True)
            and
            (item := self.item())
        ):
            return NamedItem (n , item)
        self._reset(mark)
        if cut: return None
        if (
            (it := self.item())
        ):
            return NamedItem (None , it)
        self._reset(mark)
        if (
            (forced := self.forced_atom())
        ):
            return NamedItem (None , forced)
        self._reset(mark)
        if (
            (it := self.lookahead())
        ):
            return NamedItem (None , it)
        self._reset(mark)
        if (
            (cut := self.cut())
        ):
            return NamedItem (None , cut)
        self._reset(mark)
        return None

    @memoize
    def forced_atom(self) -> Optional[Forced]:
        # forced_atom: '&' '&' ~ atom
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('&'))
            and
            (literal_1 := self.expect('&'))
            and
            (cut := True)
            and
            (a := self.atom())
        ):
            return Forced (a)
        self._reset(mark)
        if cut: return None
        return None

    @memoize
    def lookahead(self) -> Optional[Lookahead]:
        # lookahead: '&' ~ atom | '!' ~ atom
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('&'))
            and
            (cut := True)
            and
            (a := self.atom())
        ):
            return PositiveLookahead (a)
        self._reset(mark)
        if cut: return None
        cut = False
        if (
            (literal := self.expect('!'))
            and
            (cut := True)
            and
            (a := self.atom())
        ):
            return NegativeLookahead (a)
        self._reset(mark)
        if cut: return None
        return None

    @memoize
    def cut(self) -> Optional[Cut]:
        # cut: '~'
        mark = self._mark()
        if (
            (literal := self.expect('~'))
        ):
            return Cut ()
        self._reset(mark)
        return None

    @memoize
    def item(self) -> Optional[Item]:
        # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+' | atom
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('['))
            and
            (cut := True)
            and
            (alts := self.alts())
            and
            (literal_1 := self.expect(']'))
        ):
            return Opt (alts)
        self._reset(mark)
        if cut: return None
        if (
            (a := self.atom())
            and
            (literal := self.expect('?'))
        ):
            return Opt (a)
        self._reset(mark)
        if (
            (a := self.atom())
            and
            (literal := self.expect('*'))
        ):
            return Repeat0 (a)
        self._reset(mark)
        if (
            (a := self.atom())
            and
            (literal := self.expect('+'))
        ):
            return Repeat1 (a)
        self._reset(mark)
        if (
            (sep := self.atom())
            and
            (literal := self.expect('.'))
            and
            (node := self.atom())
            and
            (literal_1 := self.expect('+'))
        ):
            return Gather (sep , node)
        self._reset(mark)
        if (
            (a := self.atom())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def endmarker(self) -> Optional[NamedItems]:
        # endmarker: '$' | <always>
        mark = self._mark()
        if (
            (literal := self.expect('$'))
        ):
            return NamedItems ([NamedItem (None , NameLeaf ('ENDMARKER'))])
        self._reset(mark)
        if (
            True
        ):
            return NamedItems ()
        self._reset(mark)
        return None

    @memoize
    def atom(self) -> Optional[Plain]:
        # atom: '(' ~ alts ')' | NAME arguments? | STRING
        mark = self._mark()
        cut = False
        if (
            (literal := self.expect('('))
            and
            (cut := True)
            and
            (alts := self.alts())
            and
            (literal_1 := self.expect(')'))
        ):
            return Group (Rhs (alts))
        self._reset(mark)
        if cut: return None
        if (
            (n := self.name())
            and
            (a := self.arguments(),)
        ):
            return NameLeaf (n . string , a)
        self._reset(mark)
        if (
            (s := self.string())
        ):
            return StringLeaf (s . string)
        self._reset(mark)
        return None

    @memoize
    def action(self) -> Optional[str]:
        # action: "{" target_atoms "}"
        mark = self._mark()
        if (
            (literal := self.expect("{"))
            and
            (t := self.target_atoms())
            and
            (literal_1 := self.expect("}"))
        ):
            return t
        self._reset(mark)
        return None

    @memoize
    def annotation(self) -> Optional[str]:
        # annotation: "[" target_atoms "]"
        mark = self._mark()
        if (
            (literal := self.expect("["))
            and
            (t := self.target_atoms())
            and
            (literal_1 := self.expect("]"))
        ):
            return t
        self._reset(mark)
        return None

    @memoize
    def arguments(self) -> Optional[Args]:
        # arguments: '(' arg "," ",".arg+ [[Alt([NamedItem(None, StringLeaf('","'))])]] ')' | '(' arg "," ')' | '(' ')'
        mark = self._mark()
        if (
            (literal := self.expect('('))
            and
            (a := self.arg())
            and
            (literal_1 := self.expect(","))
            and
            (b := self._gather_11())
            and
            (c := self.expect(","),)
            and
            (literal_2 := self.expect(')'))
        ):
            return Args ([a] + b , comma = c and c . string)
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (a := self.arg())
            and
            (literal_1 := self.expect(","))
            and
            (literal_2 := self.expect(')'))
        ):
            return Args ([a] , comma = ",")
        self._reset(mark)
        if (
            (literal := self.expect('('))
            and
            (literal_1 := self.expect(')'))
        ):
            return Args ()
        self._reset(mark)
        return None

    @memoize
    def arg(self) -> Optional[Any]:
        # arg: arg_atom+
        mark = self._mark()
        if (
            (a := self._loop1_13())
        ):
            return " " . join (a)
        self._reset(mark)
        return None

    @memoize
    def arg_atom(self) -> Optional[Any]:
        # arg_atom: !"," target_atom
        mark = self._mark()
        if (
            (_lookahead := self.negative_lookahead(self.expect, ","))
            and
            (a := self.target_atom())
        ):
            return a
        self._reset(mark)
        return None

    @memoize
    def target_atoms(self) -> Optional[str]:
        # target_atoms: target_atom+
        mark = self._mark()
        if (
            (a := self._loop1_14())
        ):
            return " " . join (a)
        self._reset(mark)
        return None

    @memoize
    def target_atom(self) -> Optional[str]:
        # target_atom: "(" target_atoms? ")" | "{" target_atoms? "}" | "[" target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" | !")" !"}" !"]" OP
        mark = self._mark()
        if (
            (literal := self.expect("("))
            and
            (atoms := self.target_atoms(),)
            and
            (literal_1 := self.expect(")"))
        ):
            return "(" + (atoms or "") + ")"
        self._reset(mark)
        if (
            (literal := self.expect("{"))
            and
            (atoms := self.target_atoms(),)
            and
            (literal_1 := self.expect("}"))
        ):
            return "{" + (atoms or "") + "}"
        self._reset(mark)
        if (
            (literal := self.expect("["))
            and
            (atoms := self.target_atoms(),)
            and
            (literal_1 := self.expect("]"))
        ):
            return "[" + (atoms or "") + "]"
        self._reset(mark)
        if (
            (n := self.name())
            and
            (literal := self.expect("*"))
        ):
            return n . string + "*"
        self._reset(mark)
        if (
            (n := self.name())
        ):
            return n . string
        self._reset(mark)
        if (
            (n := self.number())
        ):
            return n . string
        self._reset(mark)
        if (
            (s := self.string())
        ):
            return s . string
        self._reset(mark)
        if (
            (literal := self.expect("?"))
        ):
            return "?"
        self._reset(mark)
        if (
            (literal := self.expect(":"))
        ):
            return ":"
        self._reset(mark)
        if (
            (_lookahead := self.negative_lookahead(self.expect, ")"))
            and
            (_lookahead_1 := self.negative_lookahead(self.expect, "}"))
            and
            (_lookahead_2 := self.negative_lookahead(self.expect, "]"))
            and
            (op := self.op())
        ):
            return op . string
        self._reset(mark)
        return None

    @memoize
    def _loop0_1(self) -> Optional[Any]:
        # _loop0_1: meta
        mark = self._mark()
        children = []
        while (
            (meta := self.meta())
        ):
            children.append(meta)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_2(self) -> Optional[Any]:
        # _loop1_2: rule
        mark = self._mark()
        children = []
        while (
            (rule := self.rule())
        ):
            children.append(rule)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_3(self) -> Optional[Any]:
        # _gather_3: typed_name _loop0_4()
        mark = self._mark()
        if (
            (elem := self.typed_name())
            is not None
            and
            (seq := self._loop0_4())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_4(self) -> Optional[Any]:
        # _loop0_4: ',' typed_name
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(','))
            and
            (elem := self.typed_name())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_5(self) -> Optional[Any]:
        # _gather_5: alt _loop0_6()
        mark = self._mark()
        if (
            (elem := self.alt())
            is not None
            and
            (seq := self._loop0_6())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_6(self) -> Optional[Any]:
        # _loop0_6: "|" alt
        mark = self._mark()
        children = []
        while (
            (literal := self.expect("|"))
            and
            (elem := self.alt())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_7(self) -> Optional[Any]:
        # _gather_7: alt _loop0_8()
        mark = self._mark()
        if (
            (elem := self.alt())
            is not None
            and
            (seq := self._loop0_8())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_8(self) -> Optional[Any]:
        # _loop0_8: "|" alt
        mark = self._mark()
        children = []
        while (
            (literal := self.expect("|"))
            and
            (elem := self.alt())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_9(self) -> Optional[Any]:
        # _loop1_9: ("|" alts NEWLINE)
        mark = self._mark()
        children = []
        while (
            (_group_15 := self._group_15())
        ):
            children.append(_group_15)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop0_10(self) -> Optional[Any]:
        # _loop0_10: named_item
        mark = self._mark()
        children = []
        while (
            (named_item := self.named_item())
        ):
            children.append(named_item)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _gather_11(self) -> Optional[Any]:
        # _gather_11: arg _loop0_12()
        mark = self._mark()
        if (
            (elem := self.arg())
            is not None
            and
            (seq := self._loop0_12())
            is not None
        ):
            return [elem] + seq
        self._reset(mark)
        return None

    @memoize
    def _loop0_12(self) -> Optional[Any]:
        # _loop0_12: "," arg
        mark = self._mark()
        children = []
        while (
            (literal := self.expect(","))
            and
            (elem := self.arg())
        ):
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_13(self) -> Optional[Any]:
        # _loop1_13: arg_atom
        mark = self._mark()
        children = []
        while (
            (arg_atom := self.arg_atom())
        ):
            children.append(arg_atom)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _loop1_14(self) -> Optional[Any]:
        # _loop1_14: target_atom
        mark = self._mark()
        children = []
        while (
            (target_atom := self.target_atom())
        ):
            children.append(target_atom)
            mark = self._mark()
        self._reset(mark)
        return children

    @memoize
    def _group_15(self) -> Optional[Any]:
        # _group_15: "|" alts NEWLINE
        mark = self._mark()
        if (
            (literal := self.expect("|"))
            and
            (b := self.alts())
            and
            (_newline := self.expect('NEWLINE'))
        ):
            return b
        self._reset(mark)
        return None

    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
