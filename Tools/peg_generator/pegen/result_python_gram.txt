// @generated by pegen from Python.gram
#define file_type 1000
#define interactive_type 1001
#define eval_type 1002
#define func_type_type 1003
#define fstring_type 1004
#define statements_type 1005
#define statement_type 1006
#define statement_newline_type 1007
#define simple_stmts_type 1008
#define simple_stmt_type 1009
#define compound_stmt_type 1010
#define assignment_type 1011
#define annotated_rhs_type 1012
#define augassign_type 1013
#define return_stmt_type 1014
#define raise_stmt_type 1015
#define global_stmt_type 1016
#define nonlocal_stmt_type 1017
#define del_stmt_type 1018
#define yield_stmt_type 1019
#define assert_stmt_type 1020
#define import_stmt_type 1021
#define import_name_type 1022
#define import_from_type 1023
#define import_from_targets_type 1024
#define import_from_as_names_type 1025
#define import_from_as_name_type 1026
#define dotted_as_names_type 1027
#define dotted_as_name_type 1028
#define dotted_name_type 1029  // Left-recursive leader
#define block_type 1030
#define decorators_type 1031
#define class_def_type 1032
#define class_def_raw_type 1033
#define function_def_type 1034
#define function_def_raw_type 1035
#define params_type 1036
#define parameters_type 1037
#define slash_no_default_type 1038
#define slash_with_default_type 1039
#define star_etc_type 1040
#define kwds_type 1041
#define param_no_default_type 1042
#define param_no_default_star_annotation_type 1043
#define param_with_default_type 1044
#define param_maybe_default_type 1045
#define param_type 1046
#define param_star_annotation_type 1047
#define annotation_type 1048
#define star_annotation_type 1049
#define default_type 1050
#define if_stmt_type 1051
#define elif_stmt_type 1052
#define else_block_type 1053
#define while_stmt_type 1054
#define for_stmt_type 1055
#define with_stmt_type 1056
#define with_item_type 1057
#define try_stmt_type 1058
#define except_block_type 1059
#define except_star_block_type 1060
#define finally_block_type 1061
#define match_stmt_type 1062
#define subject_expr_type 1063
#define case_block_type 1064
#define guard_type 1065
#define patterns_type 1066
#define pattern_type 1067
#define as_pattern_type 1068
#define or_pattern_type 1069
#define closed_pattern_type 1070
#define literal_pattern_type 1071
#define literal_expr_type 1072
#define complex_number_type 1073
#define signed_number_type 1074
#define signed_real_number_type 1075
#define real_number_type 1076
#define imaginary_number_type 1077
#define capture_pattern_type 1078
#define pattern_capture_target_type 1079
#define wildcard_pattern_type 1080
#define value_pattern_type 1081
#define attr_type 1082  // Left-recursive leader
#define name_or_attr_type 1083  // Left-recursive
#define group_pattern_type 1084
#define sequence_pattern_type 1085
#define open_sequence_pattern_type 1086
#define maybe_sequence_pattern_type 1087
#define maybe_star_pattern_type 1088
#define star_pattern_type 1089
#define mapping_pattern_type 1090
#define items_pattern_type 1091
#define key_value_pattern_type 1092
#define double_star_pattern_type 1093
#define class_pattern_type 1094
#define positional_patterns_type 1095
#define keyword_patterns_type 1096
#define keyword_pattern_type 1097
#define expressions_type 1098
#define expression_type 1099
#define yield_expr_type 1100
#define star_expressions_type 1101
#define star_expression_type 1102
#define star_named_expressions_type 1103
#define star_named_expression_type 1104
#define assignment_expression_type 1105
#define named_expression_type 1106
#define disjunction_type 1107
#define conjunction_type 1108
#define inversion_type 1109
#define comparison_type 1110
#define compare_op_bitwise_or_pair_type 1111
#define eq_bitwise_or_type 1112
#define noteq_bitwise_or_type 1113
#define lte_bitwise_or_type 1114
#define lt_bitwise_or_type 1115
#define gte_bitwise_or_type 1116
#define gt_bitwise_or_type 1117
#define notin_bitwise_or_type 1118
#define in_bitwise_or_type 1119
#define isnot_bitwise_or_type 1120
#define is_bitwise_or_type 1121
#define bitwise_or_type 1122  // Left-recursive leader
#define bitwise_xor_type 1123  // Left-recursive leader
#define bitwise_and_type 1124  // Left-recursive leader
#define shift_expr_type 1125  // Left-recursive leader
#define sum_type 1126  // Left-recursive leader
#define term_type 1127  // Left-recursive leader
#define factor_type 1128
#define power_type 1129
#define await_primary_type 1130
#define primary_type 1131  // Left-recursive leader
#define slices_type 1132
#define slice_type 1133
#define atom_type 1134
#define group_type 1135
#define lambdef_type 1136
#define lambda_params_type 1137
#define lambda_parameters_type 1138
#define lambda_slash_no_default_type 1139
#define lambda_slash_with_default_type 1140
#define lambda_star_etc_type 1141
#define lambda_kwds_type 1142
#define lambda_param_no_default_type 1143
#define lambda_param_with_default_type 1144
#define lambda_param_maybe_default_type 1145
#define lambda_param_type 1146
#define strings_type 1147
#define list_type 1148
#define tuple_type 1149
#define set_type 1150
#define dict_type 1151
#define double_starred_kvpairs_type 1152
#define double_starred_kvpair_type 1153
#define kvpair_type 1154
#define for_if_clauses_type 1155
#define for_if_clause_type 1156
#define listcomp_type 1157
#define setcomp_type 1158
#define genexp_type 1159
#define dictcomp_type 1160
#define arguments_type 1161
#define args_type 1162
#define kwargs_type 1163
#define starred_expression_type 1164
#define kwarg_or_starred_type 1165
#define kwarg_or_double_starred_type 1166
#define star_targets_type 1167
#define star_targets_list_seq_type 1168
#define star_targets_tuple_seq_type 1169
#define star_target_type 1170
#define target_with_star_atom_type 1171
#define star_atom_type 1172
#define single_target_type 1173
#define single_subscript_attribute_target_type 1174
#define t_primary_type 1175  // Left-recursive leader
#define t_lookahead_type 1176
#define del_targets_type 1177
#define del_target_type 1178
#define del_t_atom_type 1179
#define type_expressions_type 1180
#define func_type_comment_type 1181
#define invalid_arguments_type 1182
#define invalid_kwarg_type 1183
#define expression_without_invalid_type 1184
#define invalid_legacy_expression_type 1185
#define invalid_expression_type 1186
#define invalid_named_expression_type 1187
#define invalid_assignment_type 1188
#define invalid_ann_assign_target_type 1189
#define invalid_del_stmt_type 1190
#define invalid_block_type 1191
#define invalid_comprehension_type 1192
#define invalid_dict_comprehension_type 1193
#define invalid_parameters_type 1194
#define invalid_default_type 1195
#define invalid_star_etc_type 1196
#define invalid_kwds_type 1197
#define invalid_parameters_helper_type 1198
#define invalid_lambda_parameters_type 1199
#define invalid_lambda_parameters_helper_type 1200
#define invalid_lambda_star_etc_type 1201
#define invalid_lambda_kwds_type 1202
#define invalid_double_type_comments_type 1203
#define invalid_with_item_type 1204
#define invalid_for_target_type 1205
#define invalid_group_type 1206
#define invalid_import_from_targets_type 1207
#define invalid_with_stmt_type 1208
#define invalid_with_stmt_indent_type 1209
#define invalid_try_stmt_type 1210
#define invalid_except_stmt_type 1211
#define invalid_finally_stmt_type 1212
#define invalid_except_stmt_indent_type 1213
#define invalid_except_star_stmt_indent_type 1214
#define invalid_match_stmt_type 1215
#define invalid_case_block_type 1216
#define invalid_as_pattern_type 1217
#define invalid_class_pattern_type 1218
#define invalid_class_argument_pattern_type 1219
#define invalid_if_stmt_type 1220
#define invalid_elif_stmt_type 1221
#define invalid_else_stmt_type 1222
#define invalid_while_stmt_type 1223
#define invalid_for_stmt_type 1224
#define invalid_def_raw_type 1225
#define invalid_class_def_raw_type 1226
#define invalid_double_starred_kvpairs_type 1227
#define invalid_kvpair_type 1228

static mod_ty _file_rule(Parser *p);
static mod_ty _interactive_rule(Parser *p);
static mod_ty _eval_rule(Parser *p);
static mod_ty _func_type_rule(Parser *p);
static expr_ty _fstring_rule(Parser *p);
static asdl_stmt_seq* _statements_rule(Parser *p);
static asdl_stmt_seq* _statement_rule(Parser *p);
static asdl_stmt_seq* _statement_newline_rule(Parser *p);
static asdl_stmt_seq* _simple_stmts_rule(Parser *p);
static stmt_ty _simple_stmt_rule(Parser *p);
static stmt_ty _compound_stmt_rule(Parser *p);
static stmt_ty _assignment_rule(Parser *p);
static expr_ty _annotated_rhs_rule(Parser *p);
static AugOperator* _augassign_rule(Parser *p);
static stmt_ty _return_stmt_rule(Parser *p);
static stmt_ty _raise_stmt_rule(Parser *p);
static stmt_ty _global_stmt_rule(Parser *p);
static stmt_ty _nonlocal_stmt_rule(Parser *p);
static stmt_ty _del_stmt_rule(Parser *p);
static stmt_ty _yield_stmt_rule(Parser *p);
static stmt_ty _assert_stmt_rule(Parser *p);
static stmt_ty _import_stmt_rule(Parser *p);
static stmt_ty _import_name_rule(Parser *p);
static stmt_ty _import_from_rule(Parser *p);
static asdl_alias_seq* _import_from_targets_rule(Parser *p);
static asdl_alias_seq* _import_from_as_names_rule(Parser *p);
static alias_ty _import_from_as_name_rule(Parser *p);
static asdl_alias_seq* _dotted_as_names_rule(Parser *p);
static alias_ty _dotted_as_name_rule(Parser *p);
static expr_ty _dotted_name_rule(Parser *p);
static asdl_stmt_seq* _block_rule(Parser *p);
static asdl_expr_seq* _decorators_rule(Parser *p);
static stmt_ty _class_def_rule(Parser *p);
static stmt_ty _class_def_raw_rule(Parser *p);
static stmt_ty _function_def_rule(Parser *p);
static stmt_ty _function_def_raw_rule(Parser *p);
static arguments_ty _params_rule(Parser *p);
static arguments_ty _parameters_rule(Parser *p);
static asdl_arg_seq* _slash_no_default_rule(Parser *p);
static SlashWithDefault* _slash_with_default_rule(Parser *p);
static StarEtc* _star_etc_rule(Parser *p);
static arg_ty _kwds_rule(Parser *p);
static arg_ty _param_no_default_rule(Parser *p);
static arg_ty _param_no_default_star_annotation_rule(Parser *p);
static NameDefaultPair* _param_with_default_rule(Parser *p);
static NameDefaultPair* _param_maybe_default_rule(Parser *p);
static arg_ty _param_rule(Parser *p);
static arg_ty _param_star_annotation_rule(Parser *p);
static expr_ty _annotation_rule(Parser *p);
static expr_ty _star_annotation_rule(Parser *p);
static expr_ty _default_rule(Parser *p);
static stmt_ty _if_stmt_rule(Parser *p);
static stmt_ty _elif_stmt_rule(Parser *p);
static asdl_stmt_seq* _else_block_rule(Parser *p);
static stmt_ty _while_stmt_rule(Parser *p);
static stmt_ty _for_stmt_rule(Parser *p);
static stmt_ty _with_stmt_rule(Parser *p);
static withitem_ty _with_item_rule(Parser *p);
static stmt_ty _try_stmt_rule(Parser *p);
static excepthandler_ty _except_block_rule(Parser *p);
static excepthandler_ty _except_star_block_rule(Parser *p);
static asdl_stmt_seq* _finally_block_rule(Parser *p);
static stmt_ty _match_stmt_rule(Parser *p);
static expr_ty _subject_expr_rule(Parser *p);
static match_case_ty _case_block_rule(Parser *p);
static expr_ty _guard_rule(Parser *p);
static pattern_ty _patterns_rule(Parser *p);
static pattern_ty _pattern_rule(Parser *p);
static pattern_ty _as_pattern_rule(Parser *p);
static pattern_ty _or_pattern_rule(Parser *p);
static pattern_ty _closed_pattern_rule(Parser *p);
static pattern_ty _literal_pattern_rule(Parser *p);
static expr_ty _literal_expr_rule(Parser *p);
static expr_ty _complex_number_rule(Parser *p);
static expr_ty _signed_number_rule(Parser *p);
static expr_ty _signed_real_number_rule(Parser *p);
static expr_ty _real_number_rule(Parser *p);
static expr_ty _imaginary_number_rule(Parser *p);
static pattern_ty _capture_pattern_rule(Parser *p);
static expr_ty _pattern_capture_target_rule(Parser *p);
static pattern_ty _wildcard_pattern_rule(Parser *p);
static pattern_ty _value_pattern_rule(Parser *p);
static expr_ty _attr_rule(Parser *p);
static expr_ty _name_or_attr_rule(Parser *p);
static pattern_ty _group_pattern_rule(Parser *p);
static pattern_ty _sequence_pattern_rule(Parser *p);
static asdl_seq* _open_sequence_pattern_rule(Parser *p);
static asdl_seq* _maybe_sequence_pattern_rule(Parser *p);
static pattern_ty _maybe_star_pattern_rule(Parser *p);
static pattern_ty _star_pattern_rule(Parser *p);
static pattern_ty _mapping_pattern_rule(Parser *p);
static asdl_seq* _items_pattern_rule(Parser *p);
static KeyPatternPair* _key_value_pattern_rule(Parser *p);
static expr_ty _double_star_pattern_rule(Parser *p);
static pattern_ty _class_pattern_rule(Parser *p);
static asdl_pattern_seq* _positional_patterns_rule(Parser *p);
static asdl_seq* _keyword_patterns_rule(Parser *p);
static KeyPatternPair* _keyword_pattern_rule(Parser *p);
static expr_ty _expressions_rule(Parser *p);
static expr_ty _expression_rule(Parser *p);
static expr_ty _yield_expr_rule(Parser *p);
static expr_ty _star_expressions_rule(Parser *p);
static expr_ty _star_expression_rule(Parser *p);
static asdl_expr_seq* _star_named_expressions_rule(Parser *p);
static expr_ty _star_named_expression_rule(Parser *p);
static expr_ty _assignment_expression_rule(Parser *p);
static expr_ty _named_expression_rule(Parser *p);
static expr_ty _disjunction_rule(Parser *p);
static expr_ty _conjunction_rule(Parser *p);
static expr_ty _inversion_rule(Parser *p);
static expr_ty _comparison_rule(Parser *p);
static CmpopExprPair* _compare_op_bitwise_or_pair_rule(Parser *p);
static CmpopExprPair* _eq_bitwise_or_rule(Parser *p);
static CmpopExprPair* _noteq_bitwise_or_rule(Parser *p);
static CmpopExprPair* _lte_bitwise_or_rule(Parser *p);
static CmpopExprPair* _lt_bitwise_or_rule(Parser *p);
static CmpopExprPair* _gte_bitwise_or_rule(Parser *p);
static CmpopExprPair* _gt_bitwise_or_rule(Parser *p);
static CmpopExprPair* _notin_bitwise_or_rule(Parser *p);
static CmpopExprPair* _in_bitwise_or_rule(Parser *p);
static CmpopExprPair* _isnot_bitwise_or_rule(Parser *p);
static CmpopExprPair* _is_bitwise_or_rule(Parser *p);
static expr_ty _bitwise_or_rule(Parser *p);
static expr_ty _bitwise_xor_rule(Parser *p);
static expr_ty _bitwise_and_rule(Parser *p);
static expr_ty _shift_expr_rule(Parser *p);
static expr_ty _sum_rule(Parser *p);
static expr_ty _term_rule(Parser *p);
static expr_ty _factor_rule(Parser *p);
static expr_ty _power_rule(Parser *p);
static expr_ty _await_primary_rule(Parser *p);
static expr_ty _primary_rule(Parser *p);
static expr_ty _slices_rule(Parser *p);
static expr_ty _slice_rule(Parser *p);
static expr_ty _atom_rule(Parser *p);
static expr_ty _group_rule(Parser *p);
static expr_ty _lambdef_rule(Parser *p);
static arguments_ty _lambda_params_rule(Parser *p);
static arguments_ty _lambda_parameters_rule(Parser *p);
static asdl_arg_seq* _lambda_slash_no_default_rule(Parser *p);
static SlashWithDefault* _lambda_slash_with_default_rule(Parser *p);
static StarEtc* _lambda_star_etc_rule(Parser *p);
static arg_ty _lambda_kwds_rule(Parser *p);
static arg_ty _lambda_param_no_default_rule(Parser *p);
static NameDefaultPair* _lambda_param_with_default_rule(Parser *p);
static NameDefaultPair* _lambda_param_maybe_default_rule(Parser *p);
static arg_ty _lambda_param_rule(Parser *p);
static expr_ty _strings_rule(Parser *p);
static expr_ty _list_rule(Parser *p);
static expr_ty _tuple_rule(Parser *p);
static expr_ty _set_rule(Parser *p);
static expr_ty _dict_rule(Parser *p);
static asdl_seq* _double_starred_kvpairs_rule(Parser *p);
static KeyValuePair* _double_starred_kvpair_rule(Parser *p);
static KeyValuePair* _kvpair_rule(Parser *p);
static asdl_comprehension_seq* _for_if_clauses_rule(Parser *p);
static comprehension_ty _for_if_clause_rule(Parser *p);
static expr_ty _listcomp_rule(Parser *p);
static expr_ty _setcomp_rule(Parser *p);
static expr_ty _genexp_rule(Parser *p);
static expr_ty _dictcomp_rule(Parser *p);
static expr_ty _arguments_rule(Parser *p);
static expr_ty _args_rule(Parser *p);
static asdl_seq* _kwargs_rule(Parser *p);
static expr_ty _starred_expression_rule(Parser *p);
static KeywordOrStarred* _kwarg_or_starred_rule(Parser *p);
static KeywordOrStarred* _kwarg_or_double_starred_rule(Parser *p);
static expr_ty _star_targets_rule(Parser *p);
static asdl_expr_seq* _star_targets_list_seq_rule(Parser *p);
static asdl_expr_seq* _star_targets_tuple_seq_rule(Parser *p);
static expr_ty _star_target_rule(Parser *p);
static expr_ty _target_with_star_atom_rule(Parser *p);
static expr_ty _star_atom_rule(Parser *p);
static expr_ty _single_target_rule(Parser *p);
static expr_ty _single_subscript_attribute_target_rule(Parser *p);
static expr_ty _t_primary_rule(Parser *p);
static void * _t_lookahead_rule(Parser *p);
static asdl_expr_seq* _del_targets_rule(Parser *p);
static expr_ty _del_target_rule(Parser *p);
static expr_ty _del_t_atom_rule(Parser *p);
static asdl_expr_seq* _type_expressions_rule(Parser *p);
static Token* _func_type_comment_rule(Parser *p);
static void * _invalid_arguments_rule(Parser *p);
static void * _invalid_kwarg_rule(Parser *p);
static expr_ty _expression_without_invalid_rule(Parser *p);
static void * _invalid_legacy_expression_rule(Parser *p);
static void * _invalid_expression_rule(Parser *p);
static void * _invalid_named_expression_rule(Parser *p);
static void * _invalid_assignment_rule(Parser *p);
static expr_ty _invalid_ann_assign_target_rule(Parser *p);
static void * _invalid_del_stmt_rule(Parser *p);
static void * _invalid_block_rule(Parser *p);
static void * _invalid_comprehension_rule(Parser *p);
static void * _invalid_dict_comprehension_rule(Parser *p);
static void * _invalid_parameters_rule(Parser *p);
static void * _invalid_default_rule(Parser *p);
static void * _invalid_star_etc_rule(Parser *p);
static void * _invalid_kwds_rule(Parser *p);
static void * _invalid_parameters_helper_rule(Parser *p);
static void * _invalid_lambda_parameters_rule(Parser *p);
static void * _invalid_lambda_parameters_helper_rule(Parser *p);
static void * _invalid_lambda_star_etc_rule(Parser *p);
static void * _invalid_lambda_kwds_rule(Parser *p);
static void * _invalid_double_type_comments_rule(Parser *p);
static void * _invalid_with_item_rule(Parser *p);
static void * _invalid_for_target_rule(Parser *p);
static void * _invalid_group_rule(Parser *p);
static void * _invalid_import_from_targets_rule(Parser *p);
static void * _invalid_with_stmt_rule(Parser *p);
static void * _invalid_with_stmt_indent_rule(Parser *p);
static void * _invalid_try_stmt_rule(Parser *p);
static void * _invalid_except_stmt_rule(Parser *p);
static void * _invalid_finally_stmt_rule(Parser *p);
static void * _invalid_except_stmt_indent_rule(Parser *p);
static void * _invalid_except_star_stmt_indent_rule(Parser *p);
static void * _invalid_match_stmt_rule(Parser *p);
static void * _invalid_case_block_rule(Parser *p);
static void * _invalid_as_pattern_rule(Parser *p);
static void * _invalid_class_pattern_rule(Parser *p);
static asdl_pattern_seq* _invalid_class_argument_pattern_rule(Parser *p);
static void * _invalid_if_stmt_rule(Parser *p);
static void * _invalid_elif_stmt_rule(Parser *p);
static void * _invalid_else_stmt_rule(Parser *p);
static void * _invalid_while_stmt_rule(Parser *p);
static void * _invalid_for_stmt_rule(Parser *p);
static void * _invalid_def_raw_rule(Parser *p);
static void * _invalid_class_def_raw_rule(Parser *p);
static void * _invalid_double_starred_kvpairs_rule(Parser *p);
static void * _invalid_kvpair_rule(Parser *p);


// file: [statements] $
static void * _file_parse(RuleDescr *);
mod_ty _file_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "file", "[statements] $"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _file_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_a();
    static Token * _item__endmarker_var();
    void * _alt(void) {  // [statements] $
        // [statements]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // $
        Token * _endmarker_var;
        if (!(_endmarker_var = _item__endmarker_var())) return NULL;
        // parse succeeded.
        return _PyPegen_make_module (p , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "[statements] $"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_statements_var();
    void * _alt(void) {  // statements
        // statements
        asdl_stmt_seq* statements_var;
        if (!(statements_var = _item_statements_var())) return NULL;
        // parse succeeded.
        return statements_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "statements"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_statements_var(void) {
    return _statements_rule(p);
}
Token * _item__endmarker_var(void) {
    return _PyPegen_expect_token(p, 0);
}

// interactive: statement_newline
static void * _interactive_parse(RuleDescr *);
mod_ty _interactive_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "interactive", "statement_newline"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _interactive_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_stmt_seq* _item_a();
    void * _alt(void) {  // statement_newline
        // statement_newline
        asdl_stmt_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyAST_Interactive (a , p -> arena);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "statement_newline"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_a(void) {
    return _statement_newline_rule(p);
}

// eval: expressions NEWLINE* $
static void * _eval_parse(RuleDescr *);
mod_ty _eval_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "eval", "expressions NEWLINE* $"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _eval_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item__loop_var();
    static Token * _item__endmarker_var();
    void * _alt(void) {  // expressions NEWLINE* $
        // expressions
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // NEWLINE*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // $
        Token * _endmarker_var;
        if (!(_endmarker_var = _item__endmarker_var())) return NULL;
        // parse succeeded.
        return _PyAST_Expression (a , p -> arena);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expressions NEWLINE* $"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _expressions_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
Token * _node(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__endmarker_var(void) {
    return _PyPegen_expect_token(p, 0);
}

// func_type: '(' [type_expressions] ')' '->' expression NEWLINE* $
static void * _func_type_parse(RuleDescr *);
mod_ty _func_type_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "func_type", "'(' [type_expressions] ')' '->' expression NEWLINE* $"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _func_type_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    static Token * _item__literal_var_2();
    static expr_ty _item_b();
    static asdl_seq * _item__loop_var();
    static Token * _item__endmarker_var();
    void * _alt(void) {  // '(' [type_expressions] ')' '->' expression NEWLINE*
    //     $
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [type_expressions]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // '->'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // NEWLINE*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // $
        Token * _endmarker_var;
        if (!(_endmarker_var = _item__endmarker_var())) return NULL;
        // parse succeeded.
        return _PyAST_FunctionType (a , b , p -> arena);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' [type_expressions] ')' '->' expression NEWLINE* $"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_type_expressions_var();
    void * _alt(void) {  // type_expressions
        // type_expressions
        asdl_expr_seq* type_expressions_var;
        if (!(type_expressions_var = _item_type_expressions_var())) return NULL;
        // parse succeeded.
        return type_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "type_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_type_expressions_var(void) {
    return _type_expressions_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 51);   // token=->
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
Token * _node(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__endmarker_var(void) {
    return _PyPegen_expect_token(p, 0);
}

// fstring: star_expressions
static void * _fstring_parse(RuleDescr *);
expr_ty _fstring_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "fstring", "star_expressions"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _fstring_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_star_expressions_var();
    void * _alt(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}

// statements: statement+
static void * _statements_parse(RuleDescr *);
asdl_stmt_seq* _statements_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "statements", "statement+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _statements_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // statement+
        // statement+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return (asdl_stmt_seq*) _PyPegen_seq_flatten (p , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "statement+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
asdl_stmt_seq* _node(void) {
    return _statement_rule(p);
}

// statement: compound_stmt | simple_stmts
static void * _statement_parse(RuleDescr *);
asdl_stmt_seq* _statement_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "statement", "compound_stmt | simple_stmts"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _statement_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static stmt_ty _item_a();
    void * _alt_1(void) {  // compound_stmt
        // compound_stmt
        stmt_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return (asdl_stmt_seq*) _PyPegen_singleton_seq (p , a);
    }
    static asdl_stmt_seq* _item_a();
    void * _alt_2(void) {  // simple_stmts
        // simple_stmts
        asdl_stmt_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "compound_stmt"},
        {_alt_2, "_alt_2", "simple_stmts"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
stmt_ty _item_a(void) {
    return _compound_stmt_rule(p);
}
asdl_stmt_seq* _item_a(void) {
    return _simple_stmts_rule(p);
}

// statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
static void * _statement_newline_parse(RuleDescr *);
asdl_stmt_seq* _statement_newline_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "statement_newline", "compound_stmt NEWLINE | simple_stmts | NEWLINE | $"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _statement_newline_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static stmt_ty _item_a();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // compound_stmt NEWLINE
        // compound_stmt
        stmt_ty a;
        if (!(a = _item_a())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return (asdl_stmt_seq*) _PyPegen_singleton_seq (p , a);
    }
    static asdl_stmt_seq* _item_simple_stmts_var();
    void * _alt_2(void) {  // simple_stmts
        // simple_stmts
        asdl_stmt_seq* simple_stmts_var;
        if (!(simple_stmts_var = _item_simple_stmts_var())) return NULL;
        // parse succeeded.
        return simple_stmts_var;
    }
    static Token * _item__newline_var();
    void * _alt_3(void) {  // NEWLINE
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return (asdl_stmt_seq*) _PyPegen_singleton_seq (p , CHECK (stmt_ty , _PyAST_Pass (EXTRA)));
    }
    static Token * _item__endmarker_var();
    void * _alt_4(void) {  // $
        // $
        Token * _endmarker_var;
        if (!(_endmarker_var = _item__endmarker_var())) return NULL;
        // parse succeeded.
        return _PyPegen_interactive_exit (p);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "compound_stmt NEWLINE"},
        {_alt_2, "_alt_2", "simple_stmts"},
        {_alt_3, "_alt_3", "NEWLINE"},
        {_alt_4, "_alt_4", "$"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
stmt_ty _item_a(void) {
    return _compound_stmt_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
asdl_stmt_seq* _item_simple_stmts_var(void) {
    return _simple_stmts_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__endmarker_var(void) {
    return _PyPegen_expect_token(p, 0);
}

// simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ [';'] NEWLINE
static void * _simple_stmts_parse(RuleDescr *);
asdl_stmt_seq* _simple_stmts_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "simple_stmts", "simple_stmt !';' NEWLINE | ';'.simple_stmt+ [';'] NEWLINE"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _simple_stmts_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static stmt_ty _item_a();
    static int _item__lookahead_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // simple_stmt !';' NEWLINE
        // simple_stmt
        stmt_ty a;
        if (!(a = _item_a())) return NULL;
        // !';'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return (asdl_stmt_seq*) _PyPegen_singleton_seq (p , a);
    }
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__newline_var();
    void * _alt_2(void) {  // ';'.simple_stmt+ [';'] NEWLINE
        // ';'.simple_stmt+
        asdl_stmt_seq* a;
        if (!(a = _item_a())) return NULL;
        // [';']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "simple_stmt !';' NEWLINE"},
        {_alt_2, "_alt_2", "';'.simple_stmt+ [';'] NEWLINE"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
stmt_ty _item_a(void) {
    return _simple_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 13);   // token=;
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
stmt_ty _node(void) {
    return _simple_stmt_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 13);   // token=;
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ';'
        // ';'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "';'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 13);   // token=;
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}

// simple_stmt: assignment | star_expressions | &'return' return_stmt |
//     &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del'
//     del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' |
//     'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
static void * _simple_stmt_parse(RuleDescr *);
stmt_ty _simple_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "simple_stmt", "assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, simple_stmt_type);
}
void * _simple_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static stmt_ty _item_assignment_var();
    void * _alt_1(void) {  // assignment
        // assignment
        stmt_ty assignment_var;
        if (!(assignment_var = _item_assignment_var())) return NULL;
        // parse succeeded.
        return assignment_var;
    }
    static expr_ty _item_e();
    void * _alt_2(void) {  // star_expressions
        // star_expressions
        expr_ty e;
        if (!(e = _item_e())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Expr (e , EXTRA);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_return_stmt_var();
    void * _alt_3(void) {  // &'return' return_stmt
        // &'return'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // return_stmt
        stmt_ty return_stmt_var;
        if (!(return_stmt_var = _item_return_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, return_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_import_stmt_var();
    void * _alt_4(void) {  // &('import' | 'from') import_stmt
        // &('import' | 'from')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // import_stmt
        stmt_ty import_stmt_var;
        if (!(import_stmt_var = _item_import_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, import_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_raise_stmt_var();
    void * _alt_5(void) {  // &'raise' raise_stmt
        // &'raise'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // raise_stmt
        stmt_ty raise_stmt_var;
        if (!(raise_stmt_var = _item_raise_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, raise_stmt_var);
    }
    static Token * _item__keyword_var();
    void * _alt_6(void) {  // 'pass'
        // 'pass'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Pass (EXTRA);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_del_stmt_var();
    void * _alt_7(void) {  // &'del' del_stmt
        // &'del'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // del_stmt
        stmt_ty del_stmt_var;
        if (!(del_stmt_var = _item_del_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, del_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_yield_stmt_var();
    void * _alt_8(void) {  // &'yield' yield_stmt
        // &'yield'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // yield_stmt
        stmt_ty yield_stmt_var;
        if (!(yield_stmt_var = _item_yield_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, yield_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_assert_stmt_var();
    void * _alt_9(void) {  // &'assert' assert_stmt
        // &'assert'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // assert_stmt
        stmt_ty assert_stmt_var;
        if (!(assert_stmt_var = _item_assert_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, assert_stmt_var);
    }
    static Token * _item__keyword_var();
    void * _alt_10(void) {  // 'break'
        // 'break'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Break (EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_11(void) {  // 'continue'
        // 'continue'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Continue (EXTRA);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_global_stmt_var();
    void * _alt_12(void) {  // &'global' global_stmt
        // &'global'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // global_stmt
        stmt_ty global_stmt_var;
        if (!(global_stmt_var = _item_global_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, global_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_nonlocal_stmt_var();
    void * _alt_13(void) {  // &'nonlocal' nonlocal_stmt
        // &'nonlocal'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // nonlocal_stmt
        stmt_ty nonlocal_stmt_var;
        if (!(nonlocal_stmt_var = _item_nonlocal_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, nonlocal_stmt_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "assignment"},
        {_alt_2, "_alt_2", "star_expressions"},
        {_alt_3, "_alt_3", "&'return' return_stmt"},
        {_alt_4, "_alt_4", "&('import' | 'from') import_stmt"},
        {_alt_5, "_alt_5", "&'raise' raise_stmt"},
        {_alt_6, "_alt_6", "'pass'"},
        {_alt_7, "_alt_7", "&'del' del_stmt"},
        {_alt_8, "_alt_8", "&'yield' yield_stmt"},
        {_alt_9, "_alt_9", "&'assert' assert_stmt"},
        {_alt_10, "_alt_10", "'break'"},
        {_alt_11, "_alt_11", "'continue'"},
        {_alt_12, "_alt_12", "&'global' global_stmt"},
        {_alt_13, "_alt_13", "&'nonlocal' nonlocal_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
stmt_ty _item_assignment_var(void) {
    return _assignment_rule(p);
}
expr_ty _item_e(void) {
    return _star_expressions_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 519);   // keyword='return'
}
stmt_ty _item_return_stmt_var(void) {
    return _return_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'import'
        // 'import'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_2(void) {  // 'from'
        // 'from'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'import'"},
        {_alt_2, "_alt_2", "'from'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 531);   // keyword='import'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 572);   // keyword='from'
}
stmt_ty _item_import_stmt_var(void) {
    return _import_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 522);   // keyword='raise'
}
stmt_ty _item_raise_stmt_var(void) {
    return _raise_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 504);   // keyword='pass'
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 603);   // keyword='del'
}
stmt_ty _item_del_stmt_var(void) {
    return _del_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 573);   // keyword='yield'
}
stmt_ty _item_yield_stmt_var(void) {
    return _yield_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 526);   // keyword='assert'
}
stmt_ty _item_assert_stmt_var(void) {
    return _assert_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 508);   // keyword='break'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 509);   // keyword='continue'
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 523);   // keyword='global'
}
stmt_ty _item_global_stmt_var(void) {
    return _global_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 524);   // keyword='nonlocal'
}
stmt_ty _item_nonlocal_stmt_var(void) {
    return _nonlocal_stmt_rule(p);
}

// compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt |
//     &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' |
//     ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt | match_stmt
static void * _compound_stmt_parse(RuleDescr *);
stmt_ty _compound_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "compound_stmt", "&('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt | match_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _compound_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static int _item__lookahead_var();
    static stmt_ty _item_function_def_var();
    void * _alt_1(void) {  // &('def' | '@' | ASYNC) function_def
        // &('def' | '@' | ASYNC)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // function_def
        stmt_ty function_def_var;
        if (!(function_def_var = _item_function_def_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, function_def_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_if_stmt_var();
    void * _alt_2(void) {  // &'if' if_stmt
        // &'if'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // if_stmt
        stmt_ty if_stmt_var;
        if (!(if_stmt_var = _item_if_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, if_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_class_def_var();
    void * _alt_3(void) {  // &('class' | '@') class_def
        // &('class' | '@')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // class_def
        stmt_ty class_def_var;
        if (!(class_def_var = _item_class_def_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, class_def_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_with_stmt_var();
    void * _alt_4(void) {  // &('with' | ASYNC) with_stmt
        // &('with' | ASYNC)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // with_stmt
        stmt_ty with_stmt_var;
        if (!(with_stmt_var = _item_with_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, with_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_for_stmt_var();
    void * _alt_5(void) {  // &('for' | ASYNC) for_stmt
        // &('for' | ASYNC)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // for_stmt
        stmt_ty for_stmt_var;
        if (!(for_stmt_var = _item_for_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, for_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_try_stmt_var();
    void * _alt_6(void) {  // &'try' try_stmt
        // &'try'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // try_stmt
        stmt_ty try_stmt_var;
        if (!(try_stmt_var = _item_try_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, try_stmt_var);
    }
    static int _item__lookahead_var();
    static stmt_ty _item_while_stmt_var();
    void * _alt_7(void) {  // &'while' while_stmt
        // &'while'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // while_stmt
        stmt_ty while_stmt_var;
        if (!(while_stmt_var = _item_while_stmt_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, while_stmt_var);
    }
    static stmt_ty _item_match_stmt_var();
    void * _alt_8(void) {  // match_stmt
        // match_stmt
        stmt_ty match_stmt_var;
        if (!(match_stmt_var = _item_match_stmt_var())) return NULL;
        // parse succeeded.
        return match_stmt_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "&('def' | '@' | ASYNC) function_def"},
        {_alt_2, "_alt_2", "&'if' if_stmt"},
        {_alt_3, "_alt_3", "&('class' | '@') class_def"},
        {_alt_4, "_alt_4", "&('with' | ASYNC) with_stmt"},
        {_alt_5, "_alt_5", "&('for' | ASYNC) for_stmt"},
        {_alt_6, "_alt_6", "&'try' try_stmt"},
        {_alt_7, "_alt_7", "&'while' while_stmt"},
        {_alt_8, "_alt_8", "match_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'def'
        // 'def'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '@'
        // '@'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__async_var();
    void * _alt_3(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'def'"},
        {_alt_2, "_alt_2", "'@'"},
        {_alt_3, "_alt_3", "ASYNC"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 649);   // keyword='def'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 49);   // token=@
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
stmt_ty _item_function_def_var(void) {
    return _function_def_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
stmt_ty _item_if_stmt_var(void) {
    return _if_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'class'
        // 'class'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '@'
        // '@'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'class'"},
        {_alt_2, "_alt_2", "'@'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 651);   // keyword='class'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 49);   // token=@
}
stmt_ty _item_class_def_var(void) {
    return _class_def_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'with'
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__async_var();
    void * _alt_2(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'with'"},
        {_alt_2, "_alt_2", "ASYNC"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
stmt_ty _item_with_stmt_var(void) {
    return _with_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'for'
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__async_var();
    void * _alt_2(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'for'"},
        {_alt_2, "_alt_2", "ASYNC"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
stmt_ty _item_for_stmt_var(void) {
    return _for_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
stmt_ty _item_try_stmt_var(void) {
    return _try_stmt_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 644);   // keyword='while'
}
stmt_ty _item_while_stmt_var(void) {
    return _while_stmt_rule(p);
}
stmt_ty _item_match_stmt_var(void) {
    return _match_stmt_rule(p);
}

// assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')'
//     | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] |
//     ((star_targets '='))+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT]
//     | single_target augassign ~ (yield_expr | star_expressions) |
//     invalid_assignment
static void * _assignment_parse(RuleDescr *);
stmt_ty _assignment_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "assignment", "NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT] | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _assignment_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_1(void) {  // NAME ':' expression ['=' annotated_rhs]
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ['=' annotated_rhs]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign (CHECK (expr_ty , _PyPegen_set_expr_context (p , a , Store)) , b , c , 1 , EXTRA));
    }
    static void * _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // ('(' single_target ')' |
    //     single_subscript_attribute_target) ':' expression ['=' annotated_rhs]
        // ('(' single_target ')' | single_subscript_attribute_target)
        void * a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ['=' annotated_rhs]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign (a , b , c , 0 , EXTRA));
    }
    static asdl_seq * _item_a();
    static void * _item_b();
    static int _item__lookahead_var();
    static ParseResult[Any] _item_tc();
    void * _alt_3(void) {  // ((star_targets '='))+ (yield_expr |
    //     star_expressions) !'=' [TYPE_COMMENT]
        // ((star_targets '='))+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // (yield_expr | star_expressions)
        void * b;
        if (!(b = _item_b())) return NULL;
        // !'='
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // [TYPE_COMMENT]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Assign (a , b , NEW_TYPE_COMMENT (p , tc) , EXTRA);
    }
    static expr_ty _item_a();
    static AugOperator* _item_b();
    static void * _item_c();
    void * _alt_4(void) {  // single_target augassign ~ (yield_expr |
    //     star_expressions)
        // single_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // augassign
        AugOperator* b;
        if (!(b = _item_b())) return NULL;
        // ~
        // (yield_expr | star_expressions)
        void * c;
        if (!(c = _item_c())) return _PyPegen_cut_sentinel;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_AugAssign (a , b -> kind , c , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_assignment
    static void * _item_invalid_assignment_var();
    void * _alt_5(void) {  // invalid_assignment
        // invalid_assignment
        void * invalid_assignment_var;
        if (!(invalid_assignment_var = _item_invalid_assignment_var())) return NULL;
        // parse succeeded.
        return invalid_assignment_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NAME ':' expression ['=' annotated_rhs]"},
        {_alt_2, "_alt_2", "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"},
        {_alt_3, "_alt_3", "((star_targets '='))+ (yield_expr | star_expressions) !'=' [TYPE_COMMENT]"},
        {_alt_4, "_alt_4", "single_target augassign ~ (yield_expr | star_expressions)"},
        {_alt_5, "_alt_5", "invalid_assignment"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_d();
    void * _alt(void) {  // '=' annotated_rhs
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // annotated_rhs
        expr_ty d;
        if (!(d = _item_d())) return NULL;
        // parse succeeded.
        return d;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'=' annotated_rhs"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_d(void) {
    return _annotated_rhs_rule(p);
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '(' single_target ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // single_target
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return b;
    }
    static expr_ty _item_single_subscript_attribute_target_var();
    void * _alt_2(void) {  // single_subscript_attribute_target
        // single_subscript_attribute_target
        expr_ty single_subscript_attribute_target_var;
        if (!(single_subscript_attribute_target_var = _item_single_subscript_attribute_target_var())) return NULL;
        // parse succeeded.
        return single_subscript_attribute_target_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'(' single_target ')'"},
        {_alt_2, "_alt_2", "single_subscript_attribute_target"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_b(void) {
    return _single_target_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
expr_ty _item_single_subscript_attribute_target_var(void) {
    return _single_subscript_attribute_target_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_d();
    void * _alt(void) {  // '=' annotated_rhs
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // annotated_rhs
        expr_ty d;
        if (!(d = _item_d())) return NULL;
        // parse succeeded.
        return d;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'=' annotated_rhs"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_d(void) {
    return _annotated_rhs_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_z();
    static Token * _item__literal_var();
    void * _alt(void) {  // star_targets '='
        // star_targets
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_targets '='"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_z(void) {
    return _star_targets_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
void * _item_b(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_yield_expr_var();
    void * _alt_1(void) {  // yield_expr
        // yield_expr
        expr_ty yield_expr_var;
        if (!(yield_expr_var = _item_yield_expr_var())) return NULL;
        // parse succeeded.
        return yield_expr_var;
    }
    static expr_ty _item_star_expressions_var();
    void * _alt_2(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "yield_expr"},
        {_alt_2, "_alt_2", "star_expressions"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_yield_expr_var(void) {
    return _yield_expr_rule(p);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static void * _item_TYPE_COMMENT_var();
    void * _alt(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
expr_ty _item_a(void) {
    return _single_target_rule(p);
}
AugOperator* _item_b(void) {
    return _augassign_rule(p);
}
void * _item_c(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_yield_expr_var();
    void * _alt_1(void) {  // yield_expr
        // yield_expr
        expr_ty yield_expr_var;
        if (!(yield_expr_var = _item_yield_expr_var())) return NULL;
        // parse succeeded.
        return yield_expr_var;
    }
    static expr_ty _item_star_expressions_var();
    void * _alt_2(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "yield_expr"},
        {_alt_2, "_alt_2", "star_expressions"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_yield_expr_var(void) {
    return _yield_expr_rule(p);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}
void * _item_invalid_assignment_var(void) {
    return _invalid_assignment_rule(p);
}

// annotated_rhs: yield_expr | star_expressions
static void * _annotated_rhs_parse(RuleDescr *);
expr_ty _annotated_rhs_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "annotated_rhs", "yield_expr | star_expressions"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _annotated_rhs_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_yield_expr_var();
    void * _alt_1(void) {  // yield_expr
        // yield_expr
        expr_ty yield_expr_var;
        if (!(yield_expr_var = _item_yield_expr_var())) return NULL;
        // parse succeeded.
        return yield_expr_var;
    }
    static expr_ty _item_star_expressions_var();
    void * _alt_2(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "yield_expr"},
        {_alt_2, "_alt_2", "star_expressions"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_yield_expr_var(void) {
    return _yield_expr_rule(p);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}

// augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' |
//     '<<=' | '>>=' | '**=' | '//='
static void * _augassign_parse(RuleDescr *);
AugOperator* _augassign_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "augassign", "'+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _augassign_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '+='
        // '+='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Add);
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '-='
        // '-='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Sub);
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '*='
        // '*='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Mult);
    }
    static Token * _item__literal_var();
    void * _alt_4(void) {  // '@='
        // '@='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return CHECK_VERSION (AugOperator* , 5 , "The '@' operator is" , _PyPegen_augoperator (p , MatMult));
    }
    static Token * _item__literal_var();
    void * _alt_5(void) {  // '/='
        // '/='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Div);
    }
    static Token * _item__literal_var();
    void * _alt_6(void) {  // '%='
        // '%='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Mod);
    }
    static Token * _item__literal_var();
    void * _alt_7(void) {  // '&='
        // '&='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , BitAnd);
    }
    static Token * _item__literal_var();
    void * _alt_8(void) {  // '|='
        // '|='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , BitOr);
    }
    static Token * _item__literal_var();
    void * _alt_9(void) {  // '^='
        // '^='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , BitXor);
    }
    static Token * _item__literal_var();
    void * _alt_10(void) {  // '<<='
        // '<<='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , LShift);
    }
    static Token * _item__literal_var();
    void * _alt_11(void) {  // '>>='
        // '>>='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , RShift);
    }
    static Token * _item__literal_var();
    void * _alt_12(void) {  // '**='
        // '**='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , Pow);
    }
    static Token * _item__literal_var();
    void * _alt_13(void) {  // '//='
        // '//='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_augoperator (p , FloorDiv);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'+='"},
        {_alt_2, "_alt_2", "'-='"},
        {_alt_3, "_alt_3", "'*='"},
        {_alt_4, "_alt_4", "'@='"},
        {_alt_5, "_alt_5", "'/='"},
        {_alt_6, "_alt_6", "'%='"},
        {_alt_7, "_alt_7", "'&='"},
        {_alt_8, "_alt_8", "'|='"},
        {_alt_9, "_alt_9", "'^='"},
        {_alt_10, "_alt_10", "'<<='"},
        {_alt_11, "_alt_11", "'>>='"},
        {_alt_12, "_alt_12", "'**='"},
        {_alt_13, "_alt_13", "'//='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 36);   // token=+=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 37);   // token=-=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 38);   // token=*=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 50);   // token=@=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 39);   // token=/=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 40);   // token=%=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 41);   // token=&=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 42);   // token=|=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 43);   // token=^=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 44);   // token=<<=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 45);   // token=>>=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 46);   // token=**=
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 48);   // token=//=
}

// return_stmt: 'return' [star_expressions]
static void * _return_stmt_parse(RuleDescr *);
stmt_ty _return_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "return_stmt", "'return' [star_expressions]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _return_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static ParseResult[Any] _item_a();
    void * _alt(void) {  // 'return' [star_expressions]
        // 'return'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // [star_expressions]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Return (a , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'return' [star_expressions]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 519);   // keyword='return'
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_star_expressions_var();
    void * _alt(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}

// raise_stmt: 'raise' expression ['from' expression] | 'raise'
static void * _raise_stmt_parse(RuleDescr *);
stmt_ty _raise_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "raise_stmt", "'raise' expression ['from' expression] | 'raise'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _raise_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    void * _alt_1(void) {  // 'raise' expression ['from' expression]
        // 'raise'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ['from' expression]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Raise (a , b , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_2(void) {  // 'raise'
        // 'raise'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Raise (NULL , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'raise' expression ['from' expression]"},
        {_alt_2, "_alt_2", "'raise'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 522);   // keyword='raise'
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'from' expression
        // 'from'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // expression
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'from' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 572);   // keyword='from'
}
expr_ty _item_z(void) {
    return _expression_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 522);   // keyword='raise'
}

// global_stmt: 'global' ','.NAME+
static void * _global_stmt_parse(RuleDescr *);
stmt_ty _global_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "global_stmt", "'global' ','.NAME+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _global_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    void * _alt(void) {  // 'global' ','.NAME+
        // 'global'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ','.NAME+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Global (CHECK (asdl_identifier_seq* , _PyPegen_map_names_to_ids (p , a)) , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'global' ','.NAME+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 523);   // keyword='global'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _PyPegen_name_token(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
static void * _nonlocal_stmt_parse(RuleDescr *);
stmt_ty _nonlocal_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "nonlocal_stmt", "'nonlocal' ','.NAME+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _nonlocal_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    void * _alt(void) {  // 'nonlocal' ','.NAME+
        // 'nonlocal'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ','.NAME+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Nonlocal (CHECK (asdl_identifier_seq* , _PyPegen_map_names_to_ids (p , a)) , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'nonlocal' ','.NAME+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 524);   // keyword='nonlocal'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _PyPegen_name_token(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
static void * _del_stmt_parse(RuleDescr *);
stmt_ty _del_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "del_stmt", "'del' del_targets &(';' | NEWLINE) | invalid_del_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _del_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static asdl_expr_seq* _item_a();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // 'del' del_targets &(';' | NEWLINE)
        // 'del'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // del_targets
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // &(';' | NEWLINE)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Delete (a , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_del_stmt
    static void * _item_invalid_del_stmt_var();
    void * _alt_2(void) {  // invalid_del_stmt
        // invalid_del_stmt
        void * invalid_del_stmt_var;
        if (!(invalid_del_stmt_var = _item_invalid_del_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_del_stmt_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'del' del_targets &(';' | NEWLINE)"},
        {_alt_2, "_alt_2", "invalid_del_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 603);   // keyword='del'
}
asdl_expr_seq* _item_a(void) {
    return _del_targets_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ';'
        // ';'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__newline_var();
    void * _alt_2(void) {  // NEWLINE
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return _newline_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "';'"},
        {_alt_2, "_alt_2", "NEWLINE"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 13);   // token=;
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
void * _item_invalid_del_stmt_var(void) {
    return _invalid_del_stmt_rule(p);
}

// yield_stmt: yield_expr
static void * _yield_stmt_parse(RuleDescr *);
stmt_ty _yield_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "yield_stmt", "yield_expr"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _yield_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_y();
    void * _alt(void) {  // yield_expr
        // yield_expr
        expr_ty y;
        if (!(y = _item_y())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Expr (y , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "yield_expr"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_y(void) {
    return _yield_expr_rule(p);
}

// assert_stmt: 'assert' expression [',' expression]
static void * _assert_stmt_parse(RuleDescr *);
stmt_ty _assert_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "assert_stmt", "'assert' expression [',' expression]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _assert_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    void * _alt(void) {  // 'assert' expression [',' expression]
        // 'assert'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // [',' expression]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Assert (a , b , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'assert' expression [',' expression]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 526);   // keyword='assert'
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_z();
    void * _alt(void) {  // ',' expression
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_z(void) {
    return _expression_rule(p);
}

// import_stmt: import_name | import_from
static void * _import_stmt_parse(RuleDescr *);
stmt_ty _import_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_stmt", "import_name | import_from"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static stmt_ty _item_import_name_var();
    void * _alt_1(void) {  // import_name
        // import_name
        stmt_ty import_name_var;
        if (!(import_name_var = _item_import_name_var())) return NULL;
        // parse succeeded.
        return import_name_var;
    }
    static stmt_ty _item_import_from_var();
    void * _alt_2(void) {  // import_from
        // import_from
        stmt_ty import_from_var;
        if (!(import_from_var = _item_import_from_var())) return NULL;
        // parse succeeded.
        return import_from_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "import_name"},
        {_alt_2, "_alt_2", "import_from"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
stmt_ty _item_import_name_var(void) {
    return _import_name_rule(p);
}
stmt_ty _item_import_from_var(void) {
    return _import_from_rule(p);
}

// import_name: 'import' dotted_as_names
static void * _import_name_parse(RuleDescr *);
stmt_ty _import_name_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_name", "'import' dotted_as_names"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_name_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static asdl_alias_seq* _item_a();
    void * _alt(void) {  // 'import' dotted_as_names
        // 'import'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // dotted_as_names
        asdl_alias_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Import (a , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'import' dotted_as_names"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 531);   // keyword='import'
}
asdl_alias_seq* _item_a(void) {
    return _dotted_as_names_rule(p);
}

// import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
static void * _import_from_parse(RuleDescr *);
stmt_ty _import_from_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_from", "'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_from_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    static expr_ty _item_b();
    static Token * _item__keyword_var_1();
    static asdl_alias_seq* _item_c();
    void * _alt_1(void) {  // 'from' (('.' | '...'))* dotted_name 'import'
    //     import_from_targets
        // 'from'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // (('.' | '...'))*
        asdl_seq * a;
        if ((a = (asdl_seq *) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // dotted_name
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // 'import'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // import_from_targets
        asdl_alias_seq* c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ImportFrom (b -> v . Name . id , c , _PyPegen_seq_count_dots (a) , EXTRA);
    }
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    static Token * _item__keyword_var_1();
    static asdl_alias_seq* _item_b();
    void * _alt_2(void) {  // 'from' (('.' | '...'))+ 'import'
    //     import_from_targets
        // 'from'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // (('.' | '...'))+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // 'import'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // import_from_targets
        asdl_alias_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ImportFrom (NULL , b , _PyPegen_seq_count_dots (a) , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"},
        {_alt_2, "_alt_2", "'from' (('.' | '...'))+ 'import' import_from_targets"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 572);   // keyword='from'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '.'
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '...'
        // '...'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'.'"},
        {_alt_2, "_alt_2", "'...'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 52);   // token=...
}
expr_ty _item_b(void) {
    return _dotted_name_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 531);   // keyword='import'
}
asdl_alias_seq* _item_c(void) {
    return _import_from_targets_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 572);   // keyword='from'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '.'
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '...'
        // '...'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'.'"},
        {_alt_2, "_alt_2", "'...'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 52);   // token=...
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 531);   // keyword='import'
}
asdl_alias_seq* _item_b(void) {
    return _import_from_targets_rule(p);
}

// import_from_targets: '(' import_from_as_names [','] ')' |
//     import_from_as_names !',' | '*' | invalid_import_from_targets
static void * _import_from_targets_parse(RuleDescr *);
asdl_alias_seq* _import_from_targets_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_from_targets", "'(' import_from_as_names [','] ')' | import_from_as_names !',' | '*' | invalid_import_from_targets"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_from_targets_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static asdl_alias_seq* _item_a();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '(' import_from_as_names [','] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // import_from_as_names
        asdl_alias_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    static asdl_alias_seq* _item_import_from_as_names_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // import_from_as_names !','
        // import_from_as_names
        asdl_alias_seq* import_from_as_names_var;
        if (!(import_from_as_names_var = _item_import_from_as_names_var())) return NULL;
        // !','
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, import_from_as_names_var, _lookahead_var);
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '*'
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return (asdl_alias_seq*) _PyPegen_singleton_seq (p , CHECK (alias_ty , _PyPegen_alias_for_star (p , EXTRA)));
    }
    if (p->call_invalid_rules) {   // invalid_import_from_targets
    static void * _item_invalid_import_from_targets_var();
    void * _alt_4(void) {  // invalid_import_from_targets
        // invalid_import_from_targets
        void * invalid_import_from_targets_var;
        if (!(invalid_import_from_targets_var = _item_invalid_import_from_targets_var())) return NULL;
        // parse succeeded.
        return invalid_import_from_targets_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'(' import_from_as_names [','] ')'"},
        {_alt_2, "_alt_2", "import_from_as_names !','"},
        {_alt_3, "_alt_3", "'*'"},
        {_alt_4, "_alt_4", "invalid_import_from_targets"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_alias_seq* _item_a(void) {
    return _import_from_as_names_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
asdl_alias_seq* _item_import_from_as_names_var(void) {
    return _import_from_as_names_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item_invalid_import_from_targets_var(void) {
    return _invalid_import_from_targets_rule(p);
}

// import_from_as_names: ','.import_from_as_name+
static void * _import_from_as_names_parse(RuleDescr *);
asdl_alias_seq* _import_from_as_names_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_from_as_names", "','.import_from_as_name+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_from_as_names_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // ','.import_from_as_name+
        // ','.import_from_as_name+
        asdl_alias_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.import_from_as_name+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
alias_ty _node(void) {
    return _import_from_as_name_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// import_from_as_name: NAME ['as' NAME]
static void * _import_from_as_name_parse(RuleDescr *);
alias_ty _import_from_as_name_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "import_from_as_name", "NAME ['as' NAME]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _import_from_as_name_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    void * _alt(void) {  // NAME ['as' NAME]
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ['as' NAME]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_alias (a -> v . Name . id , (b) ? ((expr_ty) b) -> v . Name . id : NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME ['as' NAME]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_z(void) {
    return _PyPegen_name_token(p);
}

// dotted_as_names: ','.dotted_as_name+
static void * _dotted_as_names_parse(RuleDescr *);
asdl_alias_seq* _dotted_as_names_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "dotted_as_names", "','.dotted_as_name+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _dotted_as_names_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // ','.dotted_as_name+
        // ','.dotted_as_name+
        asdl_alias_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.dotted_as_name+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
alias_ty _node(void) {
    return _dotted_as_name_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// dotted_as_name: dotted_name ['as' NAME]
static void * _dotted_as_name_parse(RuleDescr *);
alias_ty _dotted_as_name_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "dotted_as_name", "dotted_name ['as' NAME]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _dotted_as_name_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    void * _alt(void) {  // dotted_name ['as' NAME]
        // dotted_name
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ['as' NAME]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_alias (a -> v . Name . id , (b) ? ((expr_ty) b) -> v . Name . id : NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "dotted_name ['as' NAME]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _dotted_name_rule(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_z(void) {
    return _PyPegen_name_token(p);
}

// Left-recursive leader
// dotted_name: dotted_name '.' NAME | NAME
static void * _dotted_name_parse(RuleDescr *);
expr_ty _dotted_name_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "dotted_name", "dotted_name '.' NAME | NAME"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _dotted_name_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // dotted_name '.' NAME
        // dotted_name
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_join_names_with_dot (p , a , b);
    }
    static expr_ty _item_NAME_var();
    void * _alt_2(void) {  // NAME
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return NAME_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "dotted_name '.' NAME"},
        {_alt_2, "_alt_2", "NAME"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _dotted_name_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}

// block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
static void * _block_parse(RuleDescr *);
asdl_stmt_seq* _block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "block", "NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, block_type);
}
void * _block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__newline_var();
    static Token * _item__indent_var();
    static asdl_stmt_seq* _item_a();
    static Token * _item__dedent_var();
    void * _alt_1(void) {  // NEWLINE INDENT statements DEDENT
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // INDENT
        Token * _indent_var;
        if (!(_indent_var = _item__indent_var())) return NULL;
        // statements
        asdl_stmt_seq* a;
        if (!(a = _item_a())) return NULL;
        // DEDENT
        Token * _dedent_var;
        if (!(_dedent_var = _item__dedent_var())) return NULL;
        // parse succeeded.
        return a;
    }
    static asdl_stmt_seq* _item_simple_stmts_var();
    void * _alt_2(void) {  // simple_stmts
        // simple_stmts
        asdl_stmt_seq* simple_stmts_var;
        if (!(simple_stmts_var = _item_simple_stmts_var())) return NULL;
        // parse succeeded.
        return simple_stmts_var;
    }
    if (p->call_invalid_rules) {   // invalid_block
    static void * _item_invalid_block_var();
    void * _alt_3(void) {  // invalid_block
        // invalid_block
        void * invalid_block_var;
        if (!(invalid_block_var = _item_invalid_block_var())) return NULL;
        // parse succeeded.
        return invalid_block_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NEWLINE INDENT statements DEDENT"},
        {_alt_2, "_alt_2", "simple_stmts"},
        {_alt_3, "_alt_3", "invalid_block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__indent_var(void) {
    return _PyPegen_expect_token(p, 5);
}
asdl_stmt_seq* _item_a(void) {
    return _statements_rule(p);
}
Token * _item__dedent_var(void) {
    return _PyPegen_expect_token(p, 6);
}
asdl_stmt_seq* _item_simple_stmts_var(void) {
    return _simple_stmts_rule(p);
}
void * _item_invalid_block_var(void) {
    return _invalid_block_rule(p);
}

// decorators: (('@' named_expression NEWLINE))+
static void * _decorators_parse(RuleDescr *);
asdl_expr_seq* _decorators_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "decorators", "(('@' named_expression NEWLINE))+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _decorators_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // (('@' named_expression NEWLINE))+
        // (('@' named_expression NEWLINE))+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "(('@' named_expression NEWLINE))+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_f();
    static Token * _item__newline_var();
    void * _alt(void) {  // '@' named_expression NEWLINE
        // '@'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // named_expression
        expr_ty f;
        if (!(f = _item_f())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return f;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'@' named_expression NEWLINE"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 49);   // token=@
}
expr_ty _item_f(void) {
    return _named_expression_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}

// class_def: decorators class_def_raw | class_def_raw
static void * _class_def_parse(RuleDescr *);
stmt_ty _class_def_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "class_def", "decorators class_def_raw | class_def_raw"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _class_def_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_expr_seq* _item_a();
    static stmt_ty _item_b();
    void * _alt_1(void) {  // decorators class_def_raw
        // decorators
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // class_def_raw
        stmt_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_class_def_decorators (p , a , b);
    }
    static stmt_ty _item_class_def_raw_var();
    void * _alt_2(void) {  // class_def_raw
        // class_def_raw
        stmt_ty class_def_raw_var;
        if (!(class_def_raw_var = _item_class_def_raw_var())) return NULL;
        // parse succeeded.
        return class_def_raw_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "decorators class_def_raw"},
        {_alt_2, "_alt_2", "class_def_raw"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_expr_seq* _item_a(void) {
    return _decorators_rule(p);
}
stmt_ty _item_b(void) {
    return _class_def_raw_rule(p);
}
stmt_ty _item_class_def_raw_var(void) {
    return _class_def_raw_rule(p);
}

// class_def_raw: invalid_class_def_raw | 'class' NAME ['(' [arguments] ')'] ':'
//     block
static void * _class_def_raw_parse(RuleDescr *);
stmt_ty _class_def_raw_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "class_def_raw", "invalid_class_def_raw | 'class' NAME ['(' [arguments] ')'] ':' block"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _class_def_raw_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_class_def_raw
    static void * _item_invalid_class_def_raw_var();
    void * _alt_1(void) {  // invalid_class_def_raw
        // invalid_class_def_raw
        void * invalid_class_def_raw_var;
        if (!(invalid_class_def_raw_var = _item_invalid_class_def_raw_var())) return NULL;
        // parse succeeded.
        return invalid_class_def_raw_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_c();
    void * _alt_2(void) {  // 'class' NAME ['(' [arguments] ')'] ':' block
        // 'class'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ['(' [arguments] ')']
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ClassDef (a -> v . Name . id , (b) ? ((expr_ty) b) -> v . Call . args : NULL , (b) ? ((expr_ty) b) -> v . Call . keywords : NULL , c , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_class_def_raw"},
        {_alt_2, "_alt_2", "'class' NAME ['(' [arguments] ')'] ':' block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_class_def_raw_var(void) {
    return _invalid_class_def_raw_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 651);   // keyword='class'
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_z();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '(' [arguments] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [arguments]
        ParseResult[Any] z;
        if ((z = (ParseResult[Any]) _item_z()), p->error_indicator) return NULL;
        z = _item_z();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' [arguments] ')'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_z(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_arguments_var();
    void * _alt(void) {  // arguments
        // arguments
        expr_ty arguments_var;
        if (!(arguments_var = _item_arguments_var())) return NULL;
        // parse succeeded.
        return arguments_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "arguments"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arguments_var(void) {
    return _arguments_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_c(void) {
    return _block_rule(p);
}

// function_def: decorators function_def_raw | function_def_raw
static void * _function_def_parse(RuleDescr *);
stmt_ty _function_def_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "function_def", "decorators function_def_raw | function_def_raw"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _function_def_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_expr_seq* _item_d();
    static stmt_ty _item_f();
    void * _alt_1(void) {  // decorators function_def_raw
        // decorators
        asdl_expr_seq* d;
        if (!(d = _item_d())) return NULL;
        // function_def_raw
        stmt_ty f;
        if (!(f = _item_f())) return NULL;
        // parse succeeded.
        return _PyPegen_function_def_decorators (p , d , f);
    }
    static stmt_ty _item_function_def_raw_var();
    void * _alt_2(void) {  // function_def_raw
        // function_def_raw
        stmt_ty function_def_raw_var;
        if (!(function_def_raw_var = _item_function_def_raw_var())) return NULL;
        // parse succeeded.
        return function_def_raw_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "decorators function_def_raw"},
        {_alt_2, "_alt_2", "function_def_raw"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_expr_seq* _item_d(void) {
    return _decorators_rule(p);
}
stmt_ty _item_f(void) {
    return _function_def_raw_rule(p);
}
stmt_ty _item_function_def_raw_var(void) {
    return _function_def_raw_rule(p);
}

// function_def_raw: invalid_def_raw | 'def' NAME &&'(' [params] ')' ['->'
//     expression] &&':' [func_type_comment] block | ASYNC 'def' NAME &&'('
//     [params] ')' ['->' expression] &&':' [func_type_comment] block
static void * _function_def_raw_parse(RuleDescr *);
stmt_ty _function_def_raw_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "function_def_raw", "invalid_def_raw | 'def' NAME &&'(' [params] ')' ['->' expression] &&':' [func_type_comment] block | ASYNC 'def' NAME &&'(' [params] ')' ['->' expression] &&':' [func_type_comment] block"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _function_def_raw_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_def_raw
    static void * _item_invalid_def_raw_var();
    void * _alt_1(void) {  // invalid_def_raw
        // invalid_def_raw
        void * invalid_def_raw_var;
        if (!(invalid_def_raw_var = _item_invalid_def_raw_var())) return NULL;
        // parse succeeded.
        return invalid_def_raw_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_n();
    static void * _item__forced_var();
    static ParseResult[Any] _item_params();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static void * _item__forced_var_1();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    void * _alt_2(void) {  // 'def' NAME &&'(' [params] ')' ['->' expression]
    //     &&':' [func_type_comment] block
        // 'def'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty n;
        if (!(n = _item_n())) return NULL;
        // &&'('
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // [params]
        ParseResult[Any] params;
        if ((params = (ParseResult[Any]) _item_params()), p->error_indicator) return NULL;
        params = _item_params();
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ['->' expression]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // &&':'
        void * _forced_var_1;
        if (!(_forced_var_1 = _item__forced_var_1())) return NULL;
        // [func_type_comment]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_FunctionDef (n -> v . Name . id , (params) ? params : CHECK (arguments_ty , _PyPegen_empty_arguments (p)) , b , NULL , a , NEW_TYPE_COMMENT (p , tc) , EXTRA);
    }
    static Token * _item__async_var();
    static Token * _item__keyword_var();
    static expr_ty _item_n();
    static void * _item__forced_var();
    static ParseResult[Any] _item_params();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static void * _item__forced_var_1();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    void * _alt_3(void) {  // ASYNC 'def' NAME &&'(' [params] ')' ['->'
    //     expression] &&':' [func_type_comment] block
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // 'def'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty n;
        if (!(n = _item_n())) return NULL;
        // &&'('
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // [params]
        ParseResult[Any] params;
        if ((params = (ParseResult[Any]) _item_params()), p->error_indicator) return NULL;
        params = _item_params();
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ['->' expression]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // &&':'
        void * _forced_var_1;
        if (!(_forced_var_1 = _item__forced_var_1())) return NULL;
        // [func_type_comment]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 5 , "Async functions are" , _PyAST_AsyncFunctionDef (n -> v . Name . id , (params) ? params : CHECK (arguments_ty , _PyPegen_empty_arguments (p)) , b , NULL , a , NEW_TYPE_COMMENT (p , tc) , EXTRA));
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_def_raw"},
        {_alt_2, "_alt_2", "'def' NAME &&'(' [params] ')' ['->' expression] &&':' [func_type_comment] block"},
        {_alt_3, "_alt_3", "ASYNC 'def' NAME &&'(' [params] ')' ['->' expression] &&':' [func_type_comment] block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_def_raw_var(void) {
    return _invalid_def_raw_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 649);   // keyword='def'
}
expr_ty _item_n(void) {
    return _PyPegen_name_token(p);
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_params(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arguments_ty _item_params_var();
    void * _alt(void) {  // params
        // params
        arguments_ty params_var;
        if (!(params_var = _item_params_var())) return NULL;
        // parse succeeded.
        return params_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "params"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arguments_ty _item_params_var(void) {
    return _params_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_z();
    void * _alt(void) {  // '->' expression
        // '->'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'->' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 51);   // token=->
}
expr_ty _item_z(void) {
    return _expression_rule(p);
}
void * _item__forced_var_1(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token* _item_func_type_comment_var();
    void * _alt(void) {  // func_type_comment
        // func_type_comment
        Token* func_type_comment_var;
        if (!(func_type_comment_var = _item_func_type_comment_var())) return NULL;
        // parse succeeded.
        return func_type_comment_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "func_type_comment"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token* _item_func_type_comment_var(void) {
    return _func_type_comment_rule(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 649);   // keyword='def'
}
expr_ty _item_n(void) {
    return _PyPegen_name_token(p);
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_params(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arguments_ty _item_params_var();
    void * _alt(void) {  // params
        // params
        arguments_ty params_var;
        if (!(params_var = _item_params_var())) return NULL;
        // parse succeeded.
        return params_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "params"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arguments_ty _item_params_var(void) {
    return _params_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_z();
    void * _alt(void) {  // '->' expression
        // '->'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'->' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 51);   // token=->
}
expr_ty _item_z(void) {
    return _expression_rule(p);
}
void * _item__forced_var_1(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token* _item_func_type_comment_var();
    void * _alt(void) {  // func_type_comment
        // func_type_comment
        Token* func_type_comment_var;
        if (!(func_type_comment_var = _item_func_type_comment_var())) return NULL;
        // parse succeeded.
        return func_type_comment_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "func_type_comment"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token* _item_func_type_comment_var(void) {
    return _func_type_comment_rule(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}

// params: invalid_parameters | parameters
static void * _params_parse(RuleDescr *);
arguments_ty _params_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "params", "invalid_parameters | parameters"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _params_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_parameters
    static void * _item_invalid_parameters_var();
    void * _alt_1(void) {  // invalid_parameters
        // invalid_parameters
        void * invalid_parameters_var;
        if (!(invalid_parameters_var = _item_invalid_parameters_var())) return NULL;
        // parse succeeded.
        return invalid_parameters_var;
    }
    }
    static arguments_ty _item_parameters_var();
    void * _alt_2(void) {  // parameters
        // parameters
        arguments_ty parameters_var;
        if (!(parameters_var = _item_parameters_var())) return NULL;
        // parse succeeded.
        return parameters_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_parameters"},
        {_alt_2, "_alt_2", "parameters"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_parameters_var(void) {
    return _invalid_parameters_rule(p);
}
arguments_ty _item_parameters_var(void) {
    return _parameters_rule(p);
}

// parameters: slash_no_default param_no_default* param_with_default* [star_etc]
//     | slash_with_default param_with_default* [star_etc] | param_no_default+
//     param_with_default* [star_etc] | param_with_default+ [star_etc] |
//     star_etc
static void * _parameters_parse(RuleDescr *);
arguments_ty _parameters_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "parameters", "slash_no_default param_no_default* param_with_default* [star_etc] | slash_with_default param_with_default* [star_etc] | param_no_default+ param_with_default* [star_etc] | param_with_default+ [star_etc] | star_etc"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _parameters_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_arg_seq* _item_a();
    static asdl_seq * _item_b();
    static asdl_seq * _item_c();
    static ParseResult[Any] _item_d();
    void * _alt_1(void) {  // slash_no_default param_no_default*
    //     param_with_default* [star_etc]
        // slash_no_default
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // param_no_default*
        asdl_arg_seq* b;
        if ((b = (asdl_arg_seq*) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // param_with_default*
        asdl_seq * c;
        if ((c = (asdl_seq *) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // [star_etc]
        ParseResult[Any] d;
        if ((d = (ParseResult[Any]) _item_d()), p->error_indicator) return NULL;
        d = _item_d();
        // parse succeeded.
        return CHECK_VERSION (arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments (p , a , NULL , b , c , d));
    }
    static SlashWithDefault* _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // slash_with_default param_with_default* [star_etc]
        // slash_with_default
        SlashWithDefault* a;
        if (!(a = _item_a())) return NULL;
        // param_with_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [star_etc]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return CHECK_VERSION (arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments (p , NULL , a , NULL , b , c));
    }
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // param_no_default+ param_with_default* [star_etc]
        // param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // param_with_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [star_etc]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , a , b , c);
    }
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_b();
    void * _alt_4(void) {  // param_with_default+ [star_etc]
        // param_with_default+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // [star_etc]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , NULL , a , b);
    }
    static StarEtc* _item_a();
    void * _alt_5(void) {  // star_etc
        // star_etc
        StarEtc* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , NULL , NULL , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slash_no_default param_no_default* param_with_default* [star_etc]"},
        {_alt_2, "_alt_2", "slash_with_default param_with_default* [star_etc]"},
        {_alt_3, "_alt_3", "param_no_default+ param_with_default* [star_etc]"},
        {_alt_4, "_alt_4", "param_with_default+ [star_etc]"},
        {_alt_5, "_alt_5", "star_etc"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_a(void) {
    return _slash_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item_c(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
ParseResult[Any] _item_d(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_star_etc_var();
    void * _alt(void) {  // star_etc
        // star_etc
        StarEtc* star_etc_var;
        if (!(star_etc_var = _item_star_etc_var())) return NULL;
        // parse succeeded.
        return star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_star_etc_var(void) {
    return _star_etc_rule(p);
}
SlashWithDefault* _item_a(void) {
    return _slash_with_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_star_etc_var();
    void * _alt(void) {  // star_etc
        // star_etc
        StarEtc* star_etc_var;
        if (!(star_etc_var = _item_star_etc_var())) return NULL;
        // parse succeeded.
        return star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_star_etc_var(void) {
    return _star_etc_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_star_etc_var();
    void * _alt(void) {  // star_etc
        // star_etc
        StarEtc* star_etc_var;
        if (!(star_etc_var = _item_star_etc_var())) return NULL;
        // parse succeeded.
        return star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_star_etc_var(void) {
    return _star_etc_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_star_etc_var();
    void * _alt(void) {  // star_etc
        // star_etc
        StarEtc* star_etc_var;
        if (!(star_etc_var = _item_star_etc_var())) return NULL;
        // parse succeeded.
        return star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_star_etc_var(void) {
    return _star_etc_rule(p);
}
StarEtc* _item_a(void) {
    return _star_etc_rule(p);
}

// slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
static void * _slash_no_default_parse(RuleDescr *);
asdl_arg_seq* _slash_no_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "slash_no_default", "param_no_default+ '/' ',' | param_no_default+ '/' &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _slash_no_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // param_no_default+ '/' ','
        // param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param_no_default+ '/' &')'
        // param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_no_default+ '/' ','"},
        {_alt_2, "_alt_2", "param_no_default+ '/' &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// slash_with_default: param_no_default* param_with_default+ '/' ',' |
//     param_no_default* param_with_default+ '/' &')'
static void * _slash_with_default_parse(RuleDescr *);
SlashWithDefault* _slash_with_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "slash_with_default", "param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _slash_with_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // param_no_default* param_with_default+ '/' ','
        // param_no_default*
        asdl_seq * a;
        if ((a = (asdl_seq *) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // param_with_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_slash_with_default (p , (asdl_arg_seq*) a , b);
    }
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static Token * _item__literal_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param_no_default* param_with_default+ '/' &')'
        // param_no_default*
        asdl_seq * a;
        if ((a = (asdl_seq *) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // param_with_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_slash_with_default (p , (asdl_arg_seq*) a , b);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_no_default* param_with_default+ '/' ','"},
        {_alt_2, "_alt_2", "param_no_default* param_with_default+ '/' &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// star_etc: invalid_star_etc | '*' param_no_default param_maybe_default* [kwds]
//     | '*' param_no_default_star_annotation param_maybe_default* [kwds] | '*'
//     ',' param_maybe_default+ [kwds] | kwds
static void * _star_etc_parse(RuleDescr *);
StarEtc* _star_etc_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_etc", "invalid_star_etc | '*' param_no_default param_maybe_default* [kwds] | '*' param_no_default_star_annotation param_maybe_default* [kwds] | '*' ',' param_maybe_default+ [kwds] | kwds"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_etc_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_star_etc
    static void * _item_invalid_star_etc_var();
    void * _alt_1(void) {  // invalid_star_etc
        // invalid_star_etc
        void * invalid_star_etc_var;
        if (!(invalid_star_etc_var = _item_invalid_star_etc_var())) return NULL;
        // parse succeeded.
        return invalid_star_etc_var;
    }
    }
    static Token * _item__literal_var();
    static arg_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // '*' param_no_default param_maybe_default* [kwds]
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // param_maybe_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [kwds]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_star_etc (p , a , b , c);
    }
    static Token * _item__literal_var();
    static arg_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // '*' param_no_default_star_annotation
    //     param_maybe_default* [kwds]
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param_no_default_star_annotation
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // param_maybe_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [kwds]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_star_etc (p , a , b , c);
    }
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_4(void) {  // '*' ',' param_maybe_default+ [kwds]
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // param_maybe_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // [kwds]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_star_etc (p , NULL , b , c);
    }
    static arg_ty _item_a();
    void * _alt_5(void) {  // kwds
        // kwds
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_star_etc (p , NULL , NULL , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_star_etc"},
        {_alt_2, "_alt_2", "'*' param_no_default param_maybe_default* [kwds]"},
        {_alt_3, "_alt_3", "'*' param_no_default_star_annotation param_maybe_default* [kwds]"},
        {_alt_4, "_alt_4", "'*' ',' param_maybe_default+ [kwds]"},
        {_alt_5, "_alt_5", "kwds"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_star_etc_var(void) {
    return _invalid_star_etc_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
arg_ty _item_a(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arg_ty _item_kwds_var();
    void * _alt(void) {  // kwds
        // kwds
        arg_ty kwds_var;
        if (!(kwds_var = _item_kwds_var())) return NULL;
        // parse succeeded.
        return kwds_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "kwds"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arg_ty _item_kwds_var(void) {
    return _kwds_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
arg_ty _item_a(void) {
    return _param_no_default_star_annotation_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arg_ty _item_kwds_var();
    void * _alt(void) {  // kwds
        // kwds
        arg_ty kwds_var;
        if (!(kwds_var = _item_kwds_var())) return NULL;
        // parse succeeded.
        return kwds_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "kwds"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arg_ty _item_kwds_var(void) {
    return _kwds_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arg_ty _item_kwds_var();
    void * _alt(void) {  // kwds
        // kwds
        arg_ty kwds_var;
        if (!(kwds_var = _item_kwds_var())) return NULL;
        // parse succeeded.
        return kwds_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "kwds"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arg_ty _item_kwds_var(void) {
    return _kwds_rule(p);
}
arg_ty _item_a(void) {
    return _kwds_rule(p);
}

// kwds: invalid_kwds | '**' param_no_default
static void * _kwds_parse(RuleDescr *);
arg_ty _kwds_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "kwds", "invalid_kwds | '**' param_no_default"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _kwds_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_kwds
    static void * _item_invalid_kwds_var();
    void * _alt_1(void) {  // invalid_kwds
        // invalid_kwds
        void * invalid_kwds_var;
        if (!(invalid_kwds_var = _item_invalid_kwds_var())) return NULL;
        // parse succeeded.
        return invalid_kwds_var;
    }
    }
    static Token * _item__literal_var();
    static arg_ty _item_a();
    void * _alt_2(void) {  // '**' param_no_default
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_kwds"},
        {_alt_2, "_alt_2", "'**' param_no_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_kwds_var(void) {
    return _invalid_kwds_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_a(void) {
    return _param_no_default_rule(p);
}

// param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
static void * _param_no_default_parse(RuleDescr *);
arg_ty _param_no_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param_no_default", "param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_no_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    void * _alt_1(void) {  // param ',' TYPE_COMMENT?
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // parse succeeded.
        return _PyPegen_add_type_comment_to_arg (p , a , tc);
    }
    static arg_ty _item_a();
    static ParseResult[Any] _item_tc();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param TYPE_COMMENT? &')'
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_add_type_comment_to_arg (p , a , tc);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param ',' TYPE_COMMENT?"},
        {_alt_2, "_alt_2", "param TYPE_COMMENT? &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// param_no_default_star_annotation: param_star_annotation ',' TYPE_COMMENT? |
//     param_star_annotation TYPE_COMMENT? &')'
static void * _param_no_default_star_annotation_parse(RuleDescr *);
arg_ty _param_no_default_star_annotation_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param_no_default_star_annotation", "param_star_annotation ',' TYPE_COMMENT? | param_star_annotation TYPE_COMMENT? &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_no_default_star_annotation_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    void * _alt_1(void) {  // param_star_annotation ',' TYPE_COMMENT?
        // param_star_annotation
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // parse succeeded.
        return _PyPegen_add_type_comment_to_arg (p , a , tc);
    }
    static arg_ty _item_a();
    static ParseResult[Any] _item_tc();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param_star_annotation TYPE_COMMENT? &')'
        // param_star_annotation
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_add_type_comment_to_arg (p , a , tc);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_star_annotation ',' TYPE_COMMENT?"},
        {_alt_2, "_alt_2", "param_star_annotation TYPE_COMMENT? &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _param_star_annotation_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
arg_ty _item_a(void) {
    return _param_star_annotation_rule(p);
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// param_with_default: param default ',' TYPE_COMMENT? | param default
//     TYPE_COMMENT? &')'
static void * _param_with_default_parse(RuleDescr *);
NameDefaultPair* _param_with_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param_with_default", "param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_with_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static expr_ty _item_c();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    void * _alt_1(void) {  // param default ',' TYPE_COMMENT?
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , tc);
    }
    static arg_ty _item_a();
    static expr_ty _item_c();
    static ParseResult[Any] _item_tc();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param default TYPE_COMMENT? &')'
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , tc);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param default ',' TYPE_COMMENT?"},
        {_alt_2, "_alt_2", "param default TYPE_COMMENT? &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
expr_ty _item_c(void) {
    return _default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
expr_ty _item_c(void) {
    return _default_rule(p);
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// param_maybe_default: param default? ',' TYPE_COMMENT? | param default?
//     TYPE_COMMENT? &')'
static void * _param_maybe_default_parse(RuleDescr *);
NameDefaultPair* _param_maybe_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param_maybe_default", "param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_maybe_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static ParseResult[Any] _item_c();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    void * _alt_1(void) {  // param default? ',' TYPE_COMMENT?
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default?
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , tc);
    }
    static arg_ty _item_a();
    static ParseResult[Any] _item_c();
    static ParseResult[Any] _item_tc();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // param default? TYPE_COMMENT? &')'
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default?
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // TYPE_COMMENT?
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , tc);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param default? ',' TYPE_COMMENT?"},
        {_alt_2, "_alt_2", "param default? TYPE_COMMENT? &')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _default_rule(p);
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_type_comment_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// param: NAME annotation?
static void * _param_parse(RuleDescr *);
arg_ty _param_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param", "NAME annotation?"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static ParseResult[Any] _item_b();
    void * _alt(void) {  // NAME annotation?
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // annotation?
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_arg (a -> v . Name . id , b , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME annotation?"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _annotation_rule(p);
}

// param_star_annotation: NAME star_annotation
static void * _param_star_annotation_parse(RuleDescr *);
arg_ty _param_star_annotation_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "param_star_annotation", "NAME star_annotation"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _param_star_annotation_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static expr_ty _item_b();
    void * _alt(void) {  // NAME star_annotation
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // star_annotation
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_arg (a -> v . Name . id , b , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME star_annotation"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
expr_ty _item_b(void) {
    return _star_annotation_rule(p);
}

// annotation: ':' expression
static void * _annotation_parse(RuleDescr *);
expr_ty _annotation_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "annotation", "':' expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _annotation_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // ':' expression
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "':' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}

// star_annotation: ':' star_expression
static void * _star_annotation_parse(RuleDescr *);
expr_ty _star_annotation_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_annotation", "':' star_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_annotation_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // ':' star_expression
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "':' star_expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_a(void) {
    return _star_expression_rule(p);
}

// default: '=' expression | invalid_default
static void * _default_parse(RuleDescr *);
expr_ty _default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "default", "'=' expression | invalid_default"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // '=' expression
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    if (p->call_invalid_rules) {   // invalid_default
    static void * _item_invalid_default_var();
    void * _alt_2(void) {  // invalid_default
        // invalid_default
        void * invalid_default_var;
        if (!(invalid_default_var = _item_invalid_default_var())) return NULL;
        // parse succeeded.
        return invalid_default_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'=' expression"},
        {_alt_2, "_alt_2", "invalid_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
void * _item_invalid_default_var(void) {
    return _invalid_default_rule(p);
}

// if_stmt: invalid_if_stmt | 'if' named_expression ':' block elif_stmt | 'if'
//     named_expression ':' block [else_block]
static void * _if_stmt_parse(RuleDescr *);
stmt_ty _if_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "if_stmt", "invalid_if_stmt | 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block [else_block]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _if_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_if_stmt
    static void * _item_invalid_if_stmt_var();
    void * _alt_1(void) {  // invalid_if_stmt
        // invalid_if_stmt
        void * invalid_if_stmt_var;
        if (!(invalid_if_stmt_var = _item_invalid_if_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_if_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    static stmt_ty _item_c();
    void * _alt_2(void) {  // 'if' named_expression ':' block elif_stmt
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // elif_stmt
        stmt_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_If (a , b , CHECK (asdl_stmt_seq* , _PyPegen_singleton_seq (p , c)) , EXTRA);
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // 'if' named_expression ':' block [else_block]
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // [else_block]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_If (a , b , c , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_if_stmt"},
        {_alt_2, "_alt_2", "'if' named_expression ':' block elif_stmt"},
        {_alt_3, "_alt_3", "'if' named_expression ':' block [else_block]"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_if_stmt_var(void) {
    return _invalid_if_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
stmt_ty _item_c(void) {
    return _elif_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}

// elif_stmt: invalid_elif_stmt | 'elif' named_expression ':' block elif_stmt |
//     'elif' named_expression ':' block [else_block]
static void * _elif_stmt_parse(RuleDescr *);
stmt_ty _elif_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "elif_stmt", "invalid_elif_stmt | 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block [else_block]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _elif_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_elif_stmt
    static void * _item_invalid_elif_stmt_var();
    void * _alt_1(void) {  // invalid_elif_stmt
        // invalid_elif_stmt
        void * invalid_elif_stmt_var;
        if (!(invalid_elif_stmt_var = _item_invalid_elif_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_elif_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    static stmt_ty _item_c();
    void * _alt_2(void) {  // 'elif' named_expression ':' block elif_stmt
        // 'elif'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // elif_stmt
        stmt_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_If (a , b , CHECK (asdl_stmt_seq* , _PyPegen_singleton_seq (p , c)) , EXTRA);
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // 'elif' named_expression ':' block [else_block]
        // 'elif'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // [else_block]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_If (a , b , c , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_elif_stmt"},
        {_alt_2, "_alt_2", "'elif' named_expression ':' block elif_stmt"},
        {_alt_3, "_alt_3", "'elif' named_expression ':' block [else_block]"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_elif_stmt_var(void) {
    return _invalid_elif_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 641);   // keyword='elif'
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
stmt_ty _item_c(void) {
    return _elif_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 641);   // keyword='elif'
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}

// else_block: invalid_else_stmt | 'else' &&':' block
static void * _else_block_parse(RuleDescr *);
asdl_stmt_seq* _else_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "else_block", "invalid_else_stmt | 'else' &&':' block"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _else_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_else_stmt
    static void * _item_invalid_else_stmt_var();
    void * _alt_1(void) {  // invalid_else_stmt
        // invalid_else_stmt
        void * invalid_else_stmt_var;
        if (!(invalid_else_stmt_var = _item_invalid_else_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_else_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static void * _item__forced_var();
    static asdl_stmt_seq* _item_b();
    void * _alt_2(void) {  // 'else' &&':' block
        // 'else'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // &&':'
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return b;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_else_stmt"},
        {_alt_2, "_alt_2", "'else' &&':' block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_else_stmt_var(void) {
    return _invalid_else_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 642);   // keyword='else'
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}

// while_stmt: invalid_while_stmt | 'while' named_expression ':' block
//     [else_block]
static void * _while_stmt_parse(RuleDescr *);
stmt_ty _while_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "while_stmt", "invalid_while_stmt | 'while' named_expression ':' block [else_block]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _while_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_while_stmt
    static void * _item_invalid_while_stmt_var();
    void * _alt_1(void) {  // invalid_while_stmt
        // invalid_while_stmt
        void * invalid_while_stmt_var;
        if (!(invalid_while_stmt_var = _item_invalid_while_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_while_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // 'while' named_expression ':' block [else_block]
        // 'while'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // [else_block]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_While (a , b , c , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_while_stmt"},
        {_alt_2, "_alt_2", "'while' named_expression ':' block [else_block]"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_while_stmt_var(void) {
    return _invalid_while_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 644);   // keyword='while'
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}

// for_stmt: invalid_for_stmt | 'for' star_targets 'in' ~ star_expressions ':'
//     [TYPE_COMMENT] block [else_block] | ASYNC 'for' star_targets 'in' ~
//     star_expressions ':' [TYPE_COMMENT] block [else_block] |
//     invalid_for_target
static void * _for_stmt_parse(RuleDescr *);
stmt_ty _for_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "for_stmt", "invalid_for_stmt | 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] | ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block] | invalid_for_target"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _for_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_for_stmt
    static void * _item_invalid_for_stmt_var();
    void * _alt_1(void) {  // invalid_for_stmt
        // invalid_for_stmt
        void * invalid_for_stmt_var;
        if (!(invalid_for_stmt_var = _item_invalid_for_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_for_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_t();
    static Token * _item__keyword_var_1();
    static expr_ty _item_ex();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    static ParseResult[Any] _item_el();
    void * _alt_2(void) {  // 'for' star_targets 'in' ~ star_expressions ':'
    //     [TYPE_COMMENT] block [else_block]
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_targets
        expr_ty t;
        if (!(t = _item_t())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // ~
        // star_expressions
        expr_ty ex;
        if (!(ex = _item_ex())) return _PyPegen_cut_sentinel;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return _PyPegen_cut_sentinel;
        // [TYPE_COMMENT]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return _PyPegen_cut_sentinel;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return _PyPegen_cut_sentinel;
        // [else_block]
        ParseResult[Any] el;
        if ((el = (ParseResult[Any]) _item_el()), p->error_indicator) return _PyPegen_cut_sentinel;
        el = _item_el();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_For (t , ex , b , el , NEW_TYPE_COMMENT (p , tc) , EXTRA);
    }
    static Token * _item__async_var();
    static Token * _item__keyword_var();
    static expr_ty _item_t();
    static Token * _item__keyword_var_1();
    static expr_ty _item_ex();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    static ParseResult[Any] _item_el();
    void * _alt_3(void) {  // ASYNC 'for' star_targets 'in' ~ star_expressions
    //     ':' [TYPE_COMMENT] block [else_block]
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_targets
        expr_ty t;
        if (!(t = _item_t())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // ~
        // star_expressions
        expr_ty ex;
        if (!(ex = _item_ex())) return _PyPegen_cut_sentinel;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return _PyPegen_cut_sentinel;
        // [TYPE_COMMENT]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return _PyPegen_cut_sentinel;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return _PyPegen_cut_sentinel;
        // [else_block]
        ParseResult[Any] el;
        if ((el = (ParseResult[Any]) _item_el()), p->error_indicator) return _PyPegen_cut_sentinel;
        el = _item_el();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor (t , ex , b , el , NEW_TYPE_COMMENT (p , tc) , EXTRA));
    }
    if (p->call_invalid_rules) {   // invalid_for_target
    static void * _item_invalid_for_target_var();
    void * _alt_4(void) {  // invalid_for_target
        // invalid_for_target
        void * invalid_for_target_var;
        if (!(invalid_for_target_var = _item_invalid_for_target_var())) return NULL;
        // parse succeeded.
        return invalid_for_target_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_for_stmt"},
        {_alt_2, "_alt_2", "'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block]"},
        {_alt_3, "_alt_3", "ASYNC 'for' star_targets 'in' ~ star_expressions ':' [TYPE_COMMENT] block [else_block]"},
        {_alt_4, "_alt_4", "invalid_for_target"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_for_stmt_var(void) {
    return _invalid_for_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_t(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_ex(void) {
    return _star_expressions_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static void * _item_TYPE_COMMENT_var();
    void * _alt(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
ParseResult[Any] _item_el(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_t(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_ex(void) {
    return _star_expressions_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static void * _item_TYPE_COMMENT_var();
    void * _alt(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
ParseResult[Any] _item_el(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}
void * _item_invalid_for_target_var(void) {
    return _invalid_for_target_rule(p);
}

// with_stmt: invalid_with_stmt_indent | 'with' '(' ','.with_item+ ','? ')' ':'
//     block | 'with' ','.with_item+ ':' [TYPE_COMMENT] block | ASYNC 'with' '('
//     ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':'
//     [TYPE_COMMENT] block | invalid_with_stmt
static void * _with_stmt_parse(RuleDescr *);
stmt_ty _with_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "with_stmt", "invalid_with_stmt_indent | 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' [TYPE_COMMENT] block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT] block | invalid_with_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _with_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_with_stmt_indent
    static void * _item_invalid_with_stmt_indent_var();
    void * _alt_1(void) {  // invalid_with_stmt_indent
        // invalid_with_stmt_indent
        void * invalid_with_stmt_indent_var;
        if (!(invalid_with_stmt_indent_var = _item_invalid_with_stmt_indent_var())) return NULL;
        // parse succeeded.
        return invalid_with_stmt_indent_var;
    }
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    static Token * _item__literal_var_2();
    static asdl_stmt_seq* _item_b();
    void * _alt_2(void) {  // 'with' '(' ','.with_item+ ','? ')' ':' block
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','.with_item+
        asdl_withitem_seq* a;
        if (!(a = _item_a())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ':'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 9 , "Parenthesized context managers are" , _PyAST_With (a , b , NULL , EXTRA));
    }
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    void * _alt_3(void) {  // 'with' ','.with_item+ ':' [TYPE_COMMENT] block
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ','.with_item+
        asdl_withitem_seq* a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [TYPE_COMMENT]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_With (a , b , NEW_TYPE_COMMENT (p , tc) , EXTRA);
    }
    static Token * _item__async_var();
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    static Token * _item__literal_var_2();
    static asdl_stmt_seq* _item_b();
    void * _alt_4(void) {  // ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','.with_item+
        asdl_withitem_seq* a;
        if (!(a = _item_a())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ':'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith (a , b , NULL , EXTRA));
    }
    static Token * _item__async_var();
    static Token * _item__keyword_var();
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_tc();
    static asdl_stmt_seq* _item_b();
    void * _alt_5(void) {  // ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT]
    //     block
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ','.with_item+
        asdl_withitem_seq* a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [TYPE_COMMENT]
        ParseResult[Any] tc;
        if ((tc = (ParseResult[Any]) _item_tc()), p->error_indicator) return NULL;
        tc = _item_tc();
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith (a , b , NEW_TYPE_COMMENT (p , tc) , EXTRA));
    }
    if (p->call_invalid_rules) {   // invalid_with_stmt
    static void * _item_invalid_with_stmt_var();
    void * _alt_6(void) {  // invalid_with_stmt
        // invalid_with_stmt
        void * invalid_with_stmt_var;
        if (!(invalid_with_stmt_var = _item_invalid_with_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_with_stmt_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_with_stmt_indent"},
        {_alt_2, "_alt_2", "'with' '(' ','.with_item+ ','? ')' ':' block"},
        {_alt_3, "_alt_3", "'with' ','.with_item+ ':' [TYPE_COMMENT] block"},
        {_alt_4, "_alt_4", "ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block"},
        {_alt_5, "_alt_5", "ASYNC 'with' ','.with_item+ ':' [TYPE_COMMENT] block"},
        {_alt_6, "_alt_6", "invalid_with_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_with_stmt_indent_var(void) {
    return _invalid_with_stmt_indent_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
withitem_ty _node(void) {
    return _with_item_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
withitem_ty _node(void) {
    return _with_item_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static void * _item_TYPE_COMMENT_var();
    void * _alt(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
withitem_ty _node(void) {
    return _with_item_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
withitem_ty _node(void) {
    return _with_item_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_tc(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static void * _item_TYPE_COMMENT_var();
    void * _alt(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
void * _item_invalid_with_stmt_var(void) {
    return _invalid_with_stmt_rule(p);
}

// with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item
//     | expression
static void * _with_item_parse(RuleDescr *);
withitem_ty _with_item_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "with_item", "expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _with_item_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_e();
    static Token * _item__keyword_var();
    static expr_ty _item_t();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // expression 'as' star_target &(',' | ')' | ':')
        // expression
        expr_ty e;
        if (!(e = _item_e())) return NULL;
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_target
        expr_ty t;
        if (!(t = _item_t())) return NULL;
        // &(',' | ')' | ':')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyAST_withitem (e , t , p -> arena);
    }
    if (p->call_invalid_rules) {   // invalid_with_item
    static void * _item_invalid_with_item_var();
    void * _alt_2(void) {  // invalid_with_item
        // invalid_with_item
        void * invalid_with_item_var;
        if (!(invalid_with_item_var = _item_invalid_with_item_var())) return NULL;
        // parse succeeded.
        return invalid_with_item_var;
    }
    }
    static expr_ty _item_e();
    void * _alt_3(void) {  // expression
        // expression
        expr_ty e;
        if (!(e = _item_e())) return NULL;
        // parse succeeded.
        return _PyAST_withitem (e , NULL , p -> arena);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "expression 'as' star_target &(',' | ')' | ':')"},
        {_alt_2, "_alt_2", "invalid_with_item"},
        {_alt_3, "_alt_3", "expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_e(void) {
    return _expression_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_t(void) {
    return _star_target_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ')'
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','"},
        {_alt_2, "_alt_2", "')'"},
        {_alt_3, "_alt_3", "':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
void * _item_invalid_with_item_var(void) {
    return _invalid_with_item_rule(p);
}
expr_ty _item_e(void) {
    return _expression_rule(p);
}

// try_stmt: invalid_try_stmt | 'try' &&':' block finally_block | 'try' &&':'
//     block except_block+ [else_block] [finally_block] | 'try' &&':' block
//     except_star_block+ [else_block] [finally_block]
static void * _try_stmt_parse(RuleDescr *);
stmt_ty _try_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "try_stmt", "invalid_try_stmt | 'try' &&':' block finally_block | 'try' &&':' block except_block+ [else_block] [finally_block] | 'try' &&':' block except_star_block+ [else_block] [finally_block]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _try_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_try_stmt
    static void * _item_invalid_try_stmt_var();
    void * _alt_1(void) {  // invalid_try_stmt
        // invalid_try_stmt
        void * invalid_try_stmt_var;
        if (!(invalid_try_stmt_var = _item_invalid_try_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_try_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static void * _item__forced_var();
    static asdl_stmt_seq* _item_b();
    static asdl_stmt_seq* _item_f();
    void * _alt_2(void) {  // 'try' &&':' block finally_block
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // &&':'
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // finally_block
        asdl_stmt_seq* f;
        if (!(f = _item_f())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Try (b , NULL , NULL , f , EXTRA);
    }
    static Token * _item__keyword_var();
    static void * _item__forced_var();
    static asdl_stmt_seq* _item_b();
    static asdl_seq * _item_ex();
    static ParseResult[Any] _item_el();
    static ParseResult[Any] _item_f();
    void * _alt_3(void) {  // 'try' &&':' block except_block+ [else_block]
    //     [finally_block]
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // &&':'
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // except_block+
        asdl_excepthandler_seq* ex;
        if (!(ex = _item_ex())) return NULL;
        // [else_block]
        ParseResult[Any] el;
        if ((el = (ParseResult[Any]) _item_el()), p->error_indicator) return NULL;
        el = _item_el();
        // [finally_block]
        ParseResult[Any] f;
        if ((f = (ParseResult[Any]) _item_f()), p->error_indicator) return NULL;
        f = _item_f();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Try (b , ex , el , f , EXTRA);
    }
    static Token * _item__keyword_var();
    static void * _item__forced_var();
    static asdl_stmt_seq* _item_b();
    static asdl_seq * _item_ex();
    static ParseResult[Any] _item_el();
    static ParseResult[Any] _item_f();
    void * _alt_4(void) {  // 'try' &&':' block except_star_block+ [else_block]
    //     [finally_block]
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // &&':'
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // except_star_block+
        asdl_excepthandler_seq* ex;
        if (!(ex = _item_ex())) return NULL;
        // [else_block]
        ParseResult[Any] el;
        if ((el = (ParseResult[Any]) _item_el()), p->error_indicator) return NULL;
        el = _item_el();
        // [finally_block]
        ParseResult[Any] f;
        if ((f = (ParseResult[Any]) _item_f()), p->error_indicator) return NULL;
        f = _item_f();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 11 , "Exception groups are" , _PyAST_TryStar (b , ex , el , f , EXTRA));
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_try_stmt"},
        {_alt_2, "_alt_2", "'try' &&':' block finally_block"},
        {_alt_3, "_alt_3", "'try' &&':' block except_block+ [else_block] [finally_block]"},
        {_alt_4, "_alt_4", "'try' &&':' block except_star_block+ [else_block] [finally_block]"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_try_stmt_var(void) {
    return _invalid_try_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
asdl_stmt_seq* _item_f(void) {
    return _finally_block_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
asdl_seq * _item_ex(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
excepthandler_ty _node(void) {
    return _except_block_rule(p);
}
ParseResult[Any] _item_el(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}
ParseResult[Any] _item_f(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_finally_block_var();
    void * _alt(void) {  // finally_block
        // finally_block
        asdl_stmt_seq* finally_block_var;
        if (!(finally_block_var = _item_finally_block_var())) return NULL;
        // parse succeeded.
        return finally_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "finally_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_finally_block_var(void) {
    return _finally_block_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
asdl_seq * _item_ex(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
excepthandler_ty _node(void) {
    return _except_star_block_rule(p);
}
ParseResult[Any] _item_el(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_else_block_var();
    void * _alt(void) {  // else_block
        // else_block
        asdl_stmt_seq* else_block_var;
        if (!(else_block_var = _item_else_block_var())) return NULL;
        // parse succeeded.
        return else_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "else_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_else_block_var(void) {
    return _else_block_rule(p);
}
ParseResult[Any] _item_f(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_stmt_seq* _item_finally_block_var();
    void * _alt(void) {  // finally_block
        // finally_block
        asdl_stmt_seq* finally_block_var;
        if (!(finally_block_var = _item_finally_block_var())) return NULL;
        // parse succeeded.
        return finally_block_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "finally_block"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_stmt_seq* _item_finally_block_var(void) {
    return _finally_block_rule(p);
}

// except_block: invalid_except_stmt_indent | 'except' expression ['as' NAME]
//     ':' block | 'except' ':' block | invalid_except_stmt
static void * _except_block_parse(RuleDescr *);
excepthandler_ty _except_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "except_block", "invalid_except_stmt_indent | 'except' expression ['as' NAME] ':' block | 'except' ':' block | invalid_except_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _except_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_except_stmt_indent
    static void * _item_invalid_except_stmt_indent_var();
    void * _alt_1(void) {  // invalid_except_stmt_indent
        // invalid_except_stmt_indent
        void * invalid_except_stmt_indent_var;
        if (!(invalid_except_stmt_indent_var = _item_invalid_except_stmt_indent_var())) return NULL;
        // parse succeeded.
        return invalid_except_stmt_indent_var;
    }
    }
    static Token * _item__keyword_var();
    static expr_ty _item_e();
    static ParseResult[Any] _item_t();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    void * _alt_2(void) {  // 'except' expression ['as' NAME] ':' block
        // 'except'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // expression
        expr_ty e;
        if (!(e = _item_e())) return NULL;
        // ['as' NAME]
        ParseResult[Any] t;
        if ((t = (ParseResult[Any]) _item_t()), p->error_indicator) return NULL;
        t = _item_t();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ExceptHandler (e , (t) ? ((expr_ty) t) -> v . Name . id : NULL , b , EXTRA);
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_b();
    void * _alt_3(void) {  // 'except' ':' block
        // 'except'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ExceptHandler (NULL , NULL , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_except_stmt
    static void * _item_invalid_except_stmt_var();
    void * _alt_4(void) {  // invalid_except_stmt
        // invalid_except_stmt
        void * invalid_except_stmt_var;
        if (!(invalid_except_stmt_var = _item_invalid_except_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_except_stmt_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_except_stmt_indent"},
        {_alt_2, "_alt_2", "'except' expression ['as' NAME] ':' block"},
        {_alt_3, "_alt_3", "'except' ':' block"},
        {_alt_4, "_alt_4", "invalid_except_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_except_stmt_indent_var(void) {
    return _invalid_except_stmt_indent_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
expr_ty _item_e(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_t(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_z(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
void * _item_invalid_except_stmt_var(void) {
    return _invalid_except_stmt_rule(p);
}

// except_star_block: invalid_except_star_stmt_indent | 'except' '*' expression
//     ['as' NAME] ':' block | invalid_except_stmt
static void * _except_star_block_parse(RuleDescr *);
excepthandler_ty _except_star_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "except_star_block", "invalid_except_star_stmt_indent | 'except' '*' expression ['as' NAME] ':' block | invalid_except_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _except_star_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_except_star_stmt_indent
    static void * _item_invalid_except_star_stmt_indent_var();
    void * _alt_1(void) {  // invalid_except_star_stmt_indent
        // invalid_except_star_stmt_indent
        void * invalid_except_star_stmt_indent_var;
        if (!(invalid_except_star_stmt_indent_var = _item_invalid_except_star_stmt_indent_var())) return NULL;
        // parse succeeded.
        return invalid_except_star_stmt_indent_var;
    }
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static expr_ty _item_e();
    static ParseResult[Any] _item_t();
    static Token * _item__literal_var_1();
    static asdl_stmt_seq* _item_b();
    void * _alt_2(void) {  // 'except' '*' expression ['as' NAME] ':' block
        // 'except'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty e;
        if (!(e = _item_e())) return NULL;
        // ['as' NAME]
        ParseResult[Any] t;
        if ((t = (ParseResult[Any]) _item_t()), p->error_indicator) return NULL;
        t = _item_t();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // block
        asdl_stmt_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ExceptHandler (e , (t) ? ((expr_ty) t) -> v . Name . id : NULL , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_except_stmt
    static void * _item_invalid_except_stmt_var();
    void * _alt_3(void) {  // invalid_except_stmt
        // invalid_except_stmt
        void * invalid_except_stmt_var;
        if (!(invalid_except_stmt_var = _item_invalid_except_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_except_stmt_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_except_star_stmt_indent"},
        {_alt_2, "_alt_2", "'except' '*' expression ['as' NAME] ':' block"},
        {_alt_3, "_alt_3", "invalid_except_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_except_star_stmt_indent_var(void) {
    return _invalid_except_star_stmt_indent_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_e(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_t(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_z(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_b(void) {
    return _block_rule(p);
}
void * _item_invalid_except_stmt_var(void) {
    return _invalid_except_stmt_rule(p);
}

// finally_block: invalid_finally_stmt | 'finally' &&':' block
static void * _finally_block_parse(RuleDescr *);
asdl_stmt_seq* _finally_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "finally_block", "invalid_finally_stmt | 'finally' &&':' block"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _finally_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_finally_stmt
    static void * _item_invalid_finally_stmt_var();
    void * _alt_1(void) {  // invalid_finally_stmt
        // invalid_finally_stmt
        void * invalid_finally_stmt_var;
        if (!(invalid_finally_stmt_var = _item_invalid_finally_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_finally_stmt_var;
    }
    }
    static Token * _item__keyword_var();
    static void * _item__forced_var();
    static asdl_stmt_seq* _item_a();
    void * _alt_2(void) {  // 'finally' &&':' block
        // 'finally'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // &&':'
        void * _forced_var;
        if (!(_forced_var = _item__forced_var())) return NULL;
        // block
        asdl_stmt_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_finally_stmt"},
        {_alt_2, "_alt_2", "'finally' &&':' block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_finally_stmt_var(void) {
    return _invalid_finally_stmt_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 630);   // keyword='finally'
}
void * _item__forced_var(void) {
    return _PyPegen_expect_forced_result(p, _atom);
}
Token * _atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_a(void) {
    return _block_rule(p);
}

// match_stmt: "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT |
//     invalid_match_stmt
static void * _match_stmt_parse(RuleDescr *);
stmt_ty _match_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "match_stmt", "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT | invalid_match_stmt"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _match_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item__keyword_var();
    static expr_ty _item_subject();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static Token * _item__indent_var();
    static asdl_seq * _item_cases();
    static Token * _item__dedent_var();
    void * _alt_1(void) {  // "match" subject_expr ':' NEWLINE INDENT
    //     case_block+ DEDENT
        // "match"
        expr_ty _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // subject_expr
        expr_ty subject;
        if (!(subject = _item_subject())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // INDENT
        Token * _indent_var;
        if (!(_indent_var = _item__indent_var())) return NULL;
        // case_block+
        asdl_match_case_seq* cases;
        if (!(cases = _item_cases())) return NULL;
        // DEDENT
        Token * _dedent_var;
        if (!(_dedent_var = _item__dedent_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (stmt_ty , 10 , "Pattern matching is" , _PyAST_Match (subject , cases , EXTRA));
    }
    if (p->call_invalid_rules) {   // invalid_match_stmt
    static void * _item_invalid_match_stmt_var();
    void * _alt_2(void) {  // invalid_match_stmt
        // invalid_match_stmt
        void * invalid_match_stmt_var;
        if (!(invalid_match_stmt_var = _item_invalid_match_stmt_var())) return NULL;
        // parse succeeded.
        return invalid_match_stmt_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"},
        {_alt_2, "_alt_2", "invalid_match_stmt"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item__keyword_var(void) {
    return _PyPegen_expect_soft_keyword(p, "match");   // keyword='match'
}
expr_ty _item_subject(void) {
    return _subject_expr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__indent_var(void) {
    return _PyPegen_expect_token(p, 5);
}
asdl_seq * _item_cases(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
match_case_ty _node(void) {
    return _case_block_rule(p);
}
Token * _item__dedent_var(void) {
    return _PyPegen_expect_token(p, 6);
}
void * _item_invalid_match_stmt_var(void) {
    return _invalid_match_stmt_rule(p);
}

// subject_expr: star_named_expression ',' star_named_expressions? |
//     named_expression
static void * _subject_expr_parse(RuleDescr *);
expr_ty _subject_expr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "subject_expr", "star_named_expression ',' star_named_expressions? | named_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _subject_expr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_value();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_values();
    void * _alt_1(void) {  // star_named_expression ',' star_named_expressions?
        // star_named_expression
        expr_ty value;
        if (!(value = _item_value())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_named_expressions?
        ParseResult[Any] values;
        if ((values = (ParseResult[Any]) _item_values()), p->error_indicator) return NULL;
        values = _item_values();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , value , values)) , Load , EXTRA);
    }
    static expr_ty _item_named_expression_var();
    void * _alt_2(void) {  // named_expression
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // parse succeeded.
        return named_expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "star_named_expression ',' star_named_expressions?"},
        {_alt_2, "_alt_2", "named_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_value(void) {
    return _star_named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_values(void) {
    return _PyPegen_opt(p, _item);
}
asdl_expr_seq* _item(void) {
    return _star_named_expressions_rule(p);
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}

// case_block: invalid_case_block | "case" patterns guard? ':' block
static void * _case_block_parse(RuleDescr *);
match_case_ty _case_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "case_block", "invalid_case_block | \"case\" patterns guard? ':' block"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _case_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_case_block
    static void * _item_invalid_case_block_var();
    void * _alt_1(void) {  // invalid_case_block
        // invalid_case_block
        void * invalid_case_block_var;
        if (!(invalid_case_block_var = _item_invalid_case_block_var())) return NULL;
        // parse succeeded.
        return invalid_case_block_var;
    }
    }
    static expr_ty _item__keyword_var();
    static pattern_ty _item_pattern();
    static ParseResult[Any] _item_guard();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_body();
    void * _alt_2(void) {  // "case" patterns guard? ':' block
        // "case"
        expr_ty _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // patterns
        pattern_ty pattern;
        if (!(pattern = _item_pattern())) return NULL;
        // guard?
        ParseResult[Any] guard;
        if ((guard = (ParseResult[Any]) _item_guard()), p->error_indicator) return NULL;
        guard = _item_guard();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* body;
        if (!(body = _item_body())) return NULL;
        // parse succeeded.
        return _PyAST_match_case (pattern , guard , body , p -> arena);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_case_block"},
        {_alt_2, "_alt_2", "\"case\" patterns guard? ':' block"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_case_block_var(void) {
    return _invalid_case_block_rule(p);
}
expr_ty _item__keyword_var(void) {
    return _PyPegen_expect_soft_keyword(p, "case");   // keyword='case'
}
pattern_ty _item_pattern(void) {
    return _patterns_rule(p);
}
ParseResult[Any] _item_guard(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _guard_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_body(void) {
    return _block_rule(p);
}

// guard: 'if' named_expression
static void * _guard_parse(RuleDescr *);
expr_ty _guard_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "guard", "'if' named_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _guard_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_guard();
    void * _alt(void) {  // 'if' named_expression
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty guard;
        if (!(guard = _item_guard())) return NULL;
        // parse succeeded.
        return guard;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'if' named_expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_guard(void) {
    return _named_expression_rule(p);
}

// patterns: open_sequence_pattern | pattern
static void * _patterns_parse(RuleDescr *);
pattern_ty _patterns_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "patterns", "open_sequence_pattern | pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _patterns_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq* _item_patterns();
    void * _alt_1(void) {  // open_sequence_pattern
        // open_sequence_pattern
        asdl_pattern_seq* patterns;
        if (!(patterns = _item_patterns())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSequence (patterns , EXTRA);
    }
    static pattern_ty _item_pattern_var();
    void * _alt_2(void) {  // pattern
        // pattern
        pattern_ty pattern_var;
        if (!(pattern_var = _item_pattern_var())) return NULL;
        // parse succeeded.
        return pattern_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "open_sequence_pattern"},
        {_alt_2, "_alt_2", "pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq* _item_patterns(void) {
    return _open_sequence_pattern_rule(p);
}
pattern_ty _item_pattern_var(void) {
    return _pattern_rule(p);
}

// pattern: as_pattern | or_pattern
static void * _pattern_parse(RuleDescr *);
pattern_ty _pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "pattern", "as_pattern | or_pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_as_pattern_var();
    void * _alt_1(void) {  // as_pattern
        // as_pattern
        pattern_ty as_pattern_var;
        if (!(as_pattern_var = _item_as_pattern_var())) return NULL;
        // parse succeeded.
        return as_pattern_var;
    }
    static pattern_ty _item_or_pattern_var();
    void * _alt_2(void) {  // or_pattern
        // or_pattern
        pattern_ty or_pattern_var;
        if (!(or_pattern_var = _item_or_pattern_var())) return NULL;
        // parse succeeded.
        return or_pattern_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "as_pattern"},
        {_alt_2, "_alt_2", "or_pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
pattern_ty _item_as_pattern_var(void) {
    return _as_pattern_rule(p);
}
pattern_ty _item_or_pattern_var(void) {
    return _or_pattern_rule(p);
}

// as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
static void * _as_pattern_parse(RuleDescr *);
pattern_ty _as_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "as_pattern", "or_pattern 'as' pattern_capture_target | invalid_as_pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _as_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_pattern();
    static Token * _item__keyword_var();
    static expr_ty _item_target();
    void * _alt_1(void) {  // or_pattern 'as' pattern_capture_target
        // or_pattern
        pattern_ty pattern;
        if (!(pattern = _item_pattern())) return NULL;
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // pattern_capture_target
        expr_ty target;
        if (!(target = _item_target())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchAs (pattern , target -> v . Name . id , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_as_pattern
    static void * _item_invalid_as_pattern_var();
    void * _alt_2(void) {  // invalid_as_pattern
        // invalid_as_pattern
        void * invalid_as_pattern_var;
        if (!(invalid_as_pattern_var = _item_invalid_as_pattern_var())) return NULL;
        // parse succeeded.
        return invalid_as_pattern_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "or_pattern 'as' pattern_capture_target"},
        {_alt_2, "_alt_2", "invalid_as_pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
pattern_ty _item_pattern(void) {
    return _or_pattern_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_target(void) {
    return _pattern_capture_target_rule(p);
}
void * _item_invalid_as_pattern_var(void) {
    return _invalid_as_pattern_rule(p);
}

// or_pattern: '|'.closed_pattern+
static void * _or_pattern_parse(RuleDescr *);
pattern_ty _or_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "or_pattern", "'|'.closed_pattern+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _or_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_patterns();
    void * _alt(void) {  // '|'.closed_pattern+
        // '|'.closed_pattern+
        asdl_pattern_seq* patterns;
        if (!(patterns = _item_patterns())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return asdl_seq_LEN (patterns) == 1 ? asdl_seq_GET (patterns , 0) : _PyAST_MatchOr (patterns , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'|'.closed_pattern+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_patterns(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
pattern_ty _node(void) {
    return _closed_pattern_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 18);   // token=|
}

// closed_pattern: literal_pattern | capture_pattern | wildcard_pattern |
//     value_pattern | group_pattern | sequence_pattern | mapping_pattern |
//     class_pattern
static void * _closed_pattern_parse(RuleDescr *);
pattern_ty _closed_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "closed_pattern", "literal_pattern | capture_pattern | wildcard_pattern | value_pattern | group_pattern | sequence_pattern | mapping_pattern | class_pattern"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, closed_pattern_type);
}
void * _closed_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_literal_pattern_var();
    void * _alt_1(void) {  // literal_pattern
        // literal_pattern
        pattern_ty literal_pattern_var;
        if (!(literal_pattern_var = _item_literal_pattern_var())) return NULL;
        // parse succeeded.
        return literal_pattern_var;
    }
    static pattern_ty _item_capture_pattern_var();
    void * _alt_2(void) {  // capture_pattern
        // capture_pattern
        pattern_ty capture_pattern_var;
        if (!(capture_pattern_var = _item_capture_pattern_var())) return NULL;
        // parse succeeded.
        return capture_pattern_var;
    }
    static pattern_ty _item_wildcard_pattern_var();
    void * _alt_3(void) {  // wildcard_pattern
        // wildcard_pattern
        pattern_ty wildcard_pattern_var;
        if (!(wildcard_pattern_var = _item_wildcard_pattern_var())) return NULL;
        // parse succeeded.
        return wildcard_pattern_var;
    }
    static pattern_ty _item_value_pattern_var();
    void * _alt_4(void) {  // value_pattern
        // value_pattern
        pattern_ty value_pattern_var;
        if (!(value_pattern_var = _item_value_pattern_var())) return NULL;
        // parse succeeded.
        return value_pattern_var;
    }
    static pattern_ty _item_group_pattern_var();
    void * _alt_5(void) {  // group_pattern
        // group_pattern
        pattern_ty group_pattern_var;
        if (!(group_pattern_var = _item_group_pattern_var())) return NULL;
        // parse succeeded.
        return group_pattern_var;
    }
    static pattern_ty _item_sequence_pattern_var();
    void * _alt_6(void) {  // sequence_pattern
        // sequence_pattern
        pattern_ty sequence_pattern_var;
        if (!(sequence_pattern_var = _item_sequence_pattern_var())) return NULL;
        // parse succeeded.
        return sequence_pattern_var;
    }
    static pattern_ty _item_mapping_pattern_var();
    void * _alt_7(void) {  // mapping_pattern
        // mapping_pattern
        pattern_ty mapping_pattern_var;
        if (!(mapping_pattern_var = _item_mapping_pattern_var())) return NULL;
        // parse succeeded.
        return mapping_pattern_var;
    }
    static pattern_ty _item_class_pattern_var();
    void * _alt_8(void) {  // class_pattern
        // class_pattern
        pattern_ty class_pattern_var;
        if (!(class_pattern_var = _item_class_pattern_var())) return NULL;
        // parse succeeded.
        return class_pattern_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "literal_pattern"},
        {_alt_2, "_alt_2", "capture_pattern"},
        {_alt_3, "_alt_3", "wildcard_pattern"},
        {_alt_4, "_alt_4", "value_pattern"},
        {_alt_5, "_alt_5", "group_pattern"},
        {_alt_6, "_alt_6", "sequence_pattern"},
        {_alt_7, "_alt_7", "mapping_pattern"},
        {_alt_8, "_alt_8", "class_pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
pattern_ty _item_literal_pattern_var(void) {
    return _literal_pattern_rule(p);
}
pattern_ty _item_capture_pattern_var(void) {
    return _capture_pattern_rule(p);
}
pattern_ty _item_wildcard_pattern_var(void) {
    return _wildcard_pattern_rule(p);
}
pattern_ty _item_value_pattern_var(void) {
    return _value_pattern_rule(p);
}
pattern_ty _item_group_pattern_var(void) {
    return _group_pattern_rule(p);
}
pattern_ty _item_sequence_pattern_var(void) {
    return _sequence_pattern_rule(p);
}
pattern_ty _item_mapping_pattern_var(void) {
    return _mapping_pattern_rule(p);
}
pattern_ty _item_class_pattern_var(void) {
    return _class_pattern_rule(p);
}

// literal_pattern: signed_number !('+' | '-') | complex_number | strings |
//     'None' | 'True' | 'False'
static void * _literal_pattern_parse(RuleDescr *);
pattern_ty _literal_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "literal_pattern", "signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _literal_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_value();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // signed_number !('+' | '-')
        // signed_number
        expr_ty value;
        if (!(value = _item_value())) return NULL;
        // !('+' | '-')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchValue (value , EXTRA);
    }
    static expr_ty _item_value();
    void * _alt_2(void) {  // complex_number
        // complex_number
        expr_ty value;
        if (!(value = _item_value())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchValue (value , EXTRA);
    }
    static expr_ty _item_value();
    void * _alt_3(void) {  // strings
        // strings
        expr_ty value;
        if (!(value = _item_value())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchValue (value , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_4(void) {  // 'None'
        // 'None'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSingleton (Py_None , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_5(void) {  // 'True'
        // 'True'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSingleton (Py_True , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_6(void) {  // 'False'
        // 'False'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSingleton (Py_False , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "signed_number !('+' | '-')"},
        {_alt_2, "_alt_2", "complex_number"},
        {_alt_3, "_alt_3", "strings"},
        {_alt_4, "_alt_4", "'None'"},
        {_alt_5, "_alt_5", "'True'"},
        {_alt_6, "_alt_6", "'False'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_value(void) {
    return _signed_number_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '+'
        // '+'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '-'
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'+'"},
        {_alt_2, "_alt_2", "'-'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 14);   // token=+
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_value(void) {
    return _complex_number_rule(p);
}
expr_ty _item_value(void) {
    return _strings_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 601);   // keyword='None'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 600);   // keyword='True'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 602);   // keyword='False'
}

// literal_expr: signed_number !('+' | '-') | complex_number | strings | 'None'
//     | 'True' | 'False'
static void * _literal_expr_parse(RuleDescr *);
expr_ty _literal_expr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "literal_expr", "signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _literal_expr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_signed_number_var();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // signed_number !('+' | '-')
        // signed_number
        expr_ty signed_number_var;
        if (!(signed_number_var = _item_signed_number_var())) return NULL;
        // !('+' | '-')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, signed_number_var, _lookahead_var);
    }
    static expr_ty _item_complex_number_var();
    void * _alt_2(void) {  // complex_number
        // complex_number
        expr_ty complex_number_var;
        if (!(complex_number_var = _item_complex_number_var())) return NULL;
        // parse succeeded.
        return complex_number_var;
    }
    static expr_ty _item_strings_var();
    void * _alt_3(void) {  // strings
        // strings
        expr_ty strings_var;
        if (!(strings_var = _item_strings_var())) return NULL;
        // parse succeeded.
        return strings_var;
    }
    static Token * _item__keyword_var();
    void * _alt_4(void) {  // 'None'
        // 'None'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_None , NULL , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_5(void) {  // 'True'
        // 'True'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_True , NULL , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_6(void) {  // 'False'
        // 'False'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_False , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "signed_number !('+' | '-')"},
        {_alt_2, "_alt_2", "complex_number"},
        {_alt_3, "_alt_3", "strings"},
        {_alt_4, "_alt_4", "'None'"},
        {_alt_5, "_alt_5", "'True'"},
        {_alt_6, "_alt_6", "'False'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_signed_number_var(void) {
    return _signed_number_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '+'
        // '+'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '-'
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'+'"},
        {_alt_2, "_alt_2", "'-'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 14);   // token=+
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_complex_number_var(void) {
    return _complex_number_rule(p);
}
expr_ty _item_strings_var(void) {
    return _strings_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 601);   // keyword='None'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 600);   // keyword='True'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 602);   // keyword='False'
}

// complex_number: signed_real_number '+' imaginary_number | signed_real_number
//     '-' imaginary_number
static void * _complex_number_parse(RuleDescr *);
expr_ty _complex_number_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "complex_number", "signed_real_number '+' imaginary_number | signed_real_number '-' imaginary_number"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _complex_number_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_real();
    static Token * _item__literal_var();
    static expr_ty _item_imag();
    void * _alt_1(void) {  // signed_real_number '+' imaginary_number
        // signed_real_number
        expr_ty real;
        if (!(real = _item_real())) return NULL;
        // '+'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // imaginary_number
        expr_ty imag;
        if (!(imag = _item_imag())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (real , Add , imag , EXTRA);
    }
    static expr_ty _item_real();
    static Token * _item__literal_var();
    static expr_ty _item_imag();
    void * _alt_2(void) {  // signed_real_number '-' imaginary_number
        // signed_real_number
        expr_ty real;
        if (!(real = _item_real())) return NULL;
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // imaginary_number
        expr_ty imag;
        if (!(imag = _item_imag())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (real , Sub , imag , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "signed_real_number '+' imaginary_number"},
        {_alt_2, "_alt_2", "signed_real_number '-' imaginary_number"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_real(void) {
    return _signed_real_number_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 14);   // token=+
}
expr_ty _item_imag(void) {
    return _imaginary_number_rule(p);
}
expr_ty _item_real(void) {
    return _signed_real_number_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_imag(void) {
    return _imaginary_number_rule(p);
}

// signed_number: NUMBER | '-' NUMBER
static void * _signed_number_parse(RuleDescr *);
expr_ty _signed_number_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "signed_number", "NUMBER | '-' NUMBER"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _signed_number_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_NUMBER_var();
    void * _alt_1(void) {  // NUMBER
        // NUMBER
        expr_ty NUMBER_var;
        if (!(NUMBER_var = _item_NUMBER_var())) return NULL;
        // parse succeeded.
        return NUMBER_var;
    }
    static Token * _item__literal_var();
    static expr_ty _item_number();
    void * _alt_2(void) {  // '-' NUMBER
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NUMBER
        expr_ty number;
        if (!(number = _item_number())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (USub , number , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NUMBER"},
        {_alt_2, "_alt_2", "'-' NUMBER"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_NUMBER_var(void) {
    return _PyPegen_number_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_number(void) {
    return _PyPegen_number_token(p);
}

// signed_real_number: real_number | '-' real_number
static void * _signed_real_number_parse(RuleDescr *);
expr_ty _signed_real_number_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "signed_real_number", "real_number | '-' real_number"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _signed_real_number_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_real_number_var();
    void * _alt_1(void) {  // real_number
        // real_number
        expr_ty real_number_var;
        if (!(real_number_var = _item_real_number_var())) return NULL;
        // parse succeeded.
        return real_number_var;
    }
    static Token * _item__literal_var();
    static expr_ty _item_real();
    void * _alt_2(void) {  // '-' real_number
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // real_number
        expr_ty real;
        if (!(real = _item_real())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (USub , real , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "real_number"},
        {_alt_2, "_alt_2", "'-' real_number"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_real_number_var(void) {
    return _real_number_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_real(void) {
    return _real_number_rule(p);
}

// real_number: NUMBER
static void * _real_number_parse(RuleDescr *);
expr_ty _real_number_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "real_number", "NUMBER"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _real_number_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_real();
    void * _alt(void) {  // NUMBER
        // NUMBER
        expr_ty real;
        if (!(real = _item_real())) return NULL;
        // parse succeeded.
        return _PyPegen_ensure_real (p , real);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NUMBER"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_real(void) {
    return _PyPegen_number_token(p);
}

// imaginary_number: NUMBER
static void * _imaginary_number_parse(RuleDescr *);
expr_ty _imaginary_number_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "imaginary_number", "NUMBER"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _imaginary_number_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_imag();
    void * _alt(void) {  // NUMBER
        // NUMBER
        expr_ty imag;
        if (!(imag = _item_imag())) return NULL;
        // parse succeeded.
        return _PyPegen_ensure_imaginary (p , imag);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NUMBER"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_imag(void) {
    return _PyPegen_number_token(p);
}

// capture_pattern: pattern_capture_target
static void * _capture_pattern_parse(RuleDescr *);
pattern_ty _capture_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "capture_pattern", "pattern_capture_target"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _capture_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_target();
    void * _alt(void) {  // pattern_capture_target
        // pattern_capture_target
        expr_ty target;
        if (!(target = _item_target())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchAs (NULL , target -> v . Name . id , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "pattern_capture_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_target(void) {
    return _pattern_capture_target_rule(p);
}

// pattern_capture_target: !"_" NAME !('.' | '(' | '=')
static void * _pattern_capture_target_parse(RuleDescr *);
expr_ty _pattern_capture_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "pattern_capture_target", "!\"_\" NAME !('.' | '(' | '=')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _pattern_capture_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static int _item__lookahead_var();
    static expr_ty _item_name();
    static int _item__lookahead_var_1();
    void * _alt(void) {  // !"_" NAME !('.' | '(' | '=')
        // !"_"
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // NAME
        expr_ty name;
        if (!(name = _item_name())) return NULL;
        // !('.' | '(' | '=')
        int _lookahead_var_1;
        if (!(_lookahead_var_1 = _item__lookahead_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , name , Store);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "!"_" NAME !('.' | '(' | '=')"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
expr_ty atom(void) {
    return _PyPegen_expect_soft_keyword(p, "_");   // keyword='_'
}
expr_ty _item_name(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var_1(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '.'
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '('
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '='
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'.'"},
        {_alt_2, "_alt_2", "'('"},
        {_alt_3, "_alt_3", "'='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}

// wildcard_pattern: "_"
static void * _wildcard_pattern_parse(RuleDescr *);
pattern_ty _wildcard_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "wildcard_pattern", "\"_\""};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _wildcard_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item__keyword_var();
    void * _alt(void) {  // "_"
        // "_"
        expr_ty _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchAs (NULL , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", ""_""};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item__keyword_var(void) {
    return _PyPegen_expect_soft_keyword(p, "_");   // keyword='_'
}

// value_pattern: attr !('.' | '(' | '=')
static void * _value_pattern_parse(RuleDescr *);
pattern_ty _value_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "value_pattern", "attr !('.' | '(' | '=')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _value_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_attr();
    static int _item__lookahead_var();
    void * _alt(void) {  // attr !('.' | '(' | '=')
        // attr
        expr_ty attr;
        if (!(attr = _item_attr())) return NULL;
        // !('.' | '(' | '=')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchValue (attr , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "attr !('.' | '(' | '=')"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_attr(void) {
    return _attr_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '.'
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '('
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '='
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'.'"},
        {_alt_2, "_alt_2", "'('"},
        {_alt_3, "_alt_3", "'='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}

// Left-recursive leader
// attr: name_or_attr '.' NAME
static void * _attr_parse(RuleDescr *);
expr_ty _attr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "attr", "name_or_attr '.' NAME"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _attr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_value();
    static Token * _item__literal_var();
    static expr_ty _item_attr();
    void * _alt(void) {  // name_or_attr '.' NAME
        // name_or_attr
        expr_ty value;
        if (!(value = _item_value())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty attr;
        if (!(attr = _item_attr())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (value , attr -> v . Name . id , Load , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "name_or_attr '.' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_value(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_attr(void) {
    return _PyPegen_name_token(p);
}

// Left-recursive
// name_or_attr: attr | NAME
static void * _name_or_attr_parse(RuleDescr *);
expr_ty _name_or_attr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "name_or_attr", "attr | NAME"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _name_or_attr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_attr_var();
    void * _alt_1(void) {  // attr
        // attr
        expr_ty attr_var;
        if (!(attr_var = _item_attr_var())) return NULL;
        // parse succeeded.
        return attr_var;
    }
    static expr_ty _item_NAME_var();
    void * _alt_2(void) {  // NAME
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return NAME_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "attr"},
        {_alt_2, "_alt_2", "NAME"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_attr_var(void) {
    return _attr_rule(p);
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}

// group_pattern: '(' pattern ')'
static void * _group_pattern_parse(RuleDescr *);
pattern_ty _group_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "group_pattern", "'(' pattern ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _group_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static pattern_ty _item_pattern();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '(' pattern ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // pattern
        pattern_ty pattern;
        if (!(pattern = _item_pattern())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return pattern;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' pattern ')'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
pattern_ty _item_pattern(void) {
    return _pattern_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// sequence_pattern: '[' maybe_sequence_pattern? ']' | '('
//     open_sequence_pattern? ')'
static void * _sequence_pattern_parse(RuleDescr *);
pattern_ty _sequence_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "sequence_pattern", "'[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _sequence_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_patterns();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '[' maybe_sequence_pattern? ']'
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // maybe_sequence_pattern?
        ParseResult[Any] patterns;
        if ((patterns = (ParseResult[Any]) _item_patterns()), p->error_indicator) return NULL;
        patterns = _item_patterns();
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSequence (patterns , EXTRA);
    }
    static Token * _item__literal_var();
    static ParseResult[Any] _item_patterns();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '(' open_sequence_pattern? ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // open_sequence_pattern?
        ParseResult[Any] patterns;
        if ((patterns = (ParseResult[Any]) _item_patterns()), p->error_indicator) return NULL;
        patterns = _item_patterns();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchSequence (patterns , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'[' maybe_sequence_pattern? ']'"},
        {_alt_2, "_alt_2", "'(' open_sequence_pattern? ')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
ParseResult[Any] _item_patterns(void) {
    return _PyPegen_opt(p, _item);
}
asdl_seq* _item(void) {
    return _maybe_sequence_pattern_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_patterns(void) {
    return _PyPegen_opt(p, _item);
}
asdl_seq* _item(void) {
    return _open_sequence_pattern_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?
static void * _open_sequence_pattern_parse(RuleDescr *);
asdl_seq* _open_sequence_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "open_sequence_pattern", "maybe_star_pattern ',' maybe_sequence_pattern?"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _open_sequence_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_pattern();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_patterns();
    void * _alt(void) {  // maybe_star_pattern ',' maybe_sequence_pattern?
        // maybe_star_pattern
        pattern_ty pattern;
        if (!(pattern = _item_pattern())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // maybe_sequence_pattern?
        ParseResult[Any] patterns;
        if ((patterns = (ParseResult[Any]) _item_patterns()), p->error_indicator) return NULL;
        patterns = _item_patterns();
        // parse succeeded.
        return _PyPegen_seq_insert_in_front (p , pattern , patterns);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "maybe_star_pattern ',' maybe_sequence_pattern?"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
pattern_ty _item_pattern(void) {
    return _maybe_star_pattern_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_patterns(void) {
    return _PyPegen_opt(p, _item);
}
asdl_seq* _item(void) {
    return _maybe_sequence_pattern_rule(p);
}

// maybe_sequence_pattern: ','.maybe_star_pattern+ ','?
static void * _maybe_sequence_pattern_parse(RuleDescr *);
asdl_seq* _maybe_sequence_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "maybe_sequence_pattern", "','.maybe_star_pattern+ ','?"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _maybe_sequence_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_patterns();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // ','.maybe_star_pattern+ ','?
        // ','.maybe_star_pattern+
        asdl_seq * patterns;
        if (!(patterns = _item_patterns())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return patterns;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.maybe_star_pattern+ ','?"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_patterns(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
pattern_ty _node(void) {
    return _maybe_star_pattern_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// maybe_star_pattern: star_pattern | pattern
static void * _maybe_star_pattern_parse(RuleDescr *);
pattern_ty _maybe_star_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "maybe_star_pattern", "star_pattern | pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _maybe_star_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_star_pattern_var();
    void * _alt_1(void) {  // star_pattern
        // star_pattern
        pattern_ty star_pattern_var;
        if (!(star_pattern_var = _item_star_pattern_var())) return NULL;
        // parse succeeded.
        return star_pattern_var;
    }
    static pattern_ty _item_pattern_var();
    void * _alt_2(void) {  // pattern
        // pattern
        pattern_ty pattern_var;
        if (!(pattern_var = _item_pattern_var())) return NULL;
        // parse succeeded.
        return pattern_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "star_pattern"},
        {_alt_2, "_alt_2", "pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
pattern_ty _item_star_pattern_var(void) {
    return _star_pattern_rule(p);
}
pattern_ty _item_pattern_var(void) {
    return _pattern_rule(p);
}

// star_pattern: '*' pattern_capture_target | '*' wildcard_pattern
static void * _star_pattern_parse(RuleDescr *);
pattern_ty _star_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_pattern", "'*' pattern_capture_target | '*' wildcard_pattern"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, star_pattern_type);
}
void * _star_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_target();
    void * _alt_1(void) {  // '*' pattern_capture_target
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // pattern_capture_target
        expr_ty target;
        if (!(target = _item_target())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchStar (target -> v . Name . id , EXTRA);
    }
    static Token * _item__literal_var();
    static pattern_ty _item_wildcard_pattern_var();
    void * _alt_2(void) {  // '*' wildcard_pattern
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // wildcard_pattern
        pattern_ty wildcard_pattern_var;
        if (!(wildcard_pattern_var = _item_wildcard_pattern_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchStar (NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' pattern_capture_target"},
        {_alt_2, "_alt_2", "'*' wildcard_pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_target(void) {
    return _pattern_capture_target_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
pattern_ty _item_wildcard_pattern_var(void) {
    return _wildcard_pattern_rule(p);
}

// mapping_pattern: '{' '}' | '{' double_star_pattern ','? '}' | '{'
//     items_pattern ',' double_star_pattern ','? '}' | '{' items_pattern ','?
//     '}'
static void * _mapping_pattern_parse(RuleDescr *);
pattern_ty _mapping_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "mapping_pattern", "'{' '}' | '{' double_star_pattern ','? '}' | '{' items_pattern ',' double_star_pattern ','? '}' | '{' items_pattern ','? '}'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _mapping_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '{' '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchMapping (NULL , NULL , NULL , EXTRA);
    }
    static Token * _item__literal_var();
    static expr_ty _item_rest();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '{' double_star_pattern ','? '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // double_star_pattern
        expr_ty rest;
        if (!(rest = _item_rest())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchMapping (NULL , NULL , rest -> v . Name . id , EXTRA);
    }
    static Token * _item__literal_var();
    static asdl_seq* _item_items();
    static Token * _item__literal_var_1();
    static expr_ty _item_rest();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_2();
    void * _alt_3(void) {  // '{' items_pattern ',' double_star_pattern ','? '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // items_pattern
        asdl_seq* items;
        if (!(items = _item_items())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // double_star_pattern
        expr_ty rest;
        if (!(rest = _item_rest())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // '}'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchMapping (CHECK (asdl_expr_seq* , _PyPegen_get_pattern_keys (p , items)) , CHECK (asdl_pattern_seq* , _PyPegen_get_patterns (p , items)) , rest -> v . Name . id , EXTRA);
    }
    static Token * _item__literal_var();
    static asdl_seq* _item_items();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_4(void) {  // '{' items_pattern ','? '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // items_pattern
        asdl_seq* items;
        if (!(items = _item_items())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchMapping (CHECK (asdl_expr_seq* , _PyPegen_get_pattern_keys (p , items)) , CHECK (asdl_pattern_seq* , _PyPegen_get_patterns (p , items)) , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'{' '}'"},
        {_alt_2, "_alt_2", "'{' double_star_pattern ','? '}'"},
        {_alt_3, "_alt_3", "'{' items_pattern ',' double_star_pattern ','? '}'"},
        {_alt_4, "_alt_4", "'{' items_pattern ','? '}'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
expr_ty _item_rest(void) {
    return _double_star_pattern_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
asdl_seq* _item_items(void) {
    return _items_pattern_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_rest(void) {
    return _double_star_pattern_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
asdl_seq* _item_items(void) {
    return _items_pattern_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}

// items_pattern: ','.key_value_pattern+
static void * _items_pattern_parse(RuleDescr *);
asdl_seq* _items_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "items_pattern", "','.key_value_pattern+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _items_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item__loop_var();
    void * _alt(void) {  // ','.key_value_pattern+
        // ','.key_value_pattern+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.key_value_pattern+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeyPatternPair* _node(void) {
    return _key_value_pattern_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// key_value_pattern: (literal_expr | attr) ':' pattern
static void * _key_value_pattern_parse(RuleDescr *);
KeyPatternPair* _key_value_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "key_value_pattern", "(literal_expr | attr) ':' pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _key_value_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static void * _item_key();
    static Token * _item__literal_var();
    static pattern_ty _item_pattern();
    void * _alt(void) {  // (literal_expr | attr) ':' pattern
        // (literal_expr | attr)
        void * key;
        if (!(key = _item_key())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // pattern
        pattern_ty pattern;
        if (!(pattern = _item_pattern())) return NULL;
        // parse succeeded.
        return _PyPegen_key_pattern_pair (p , key , pattern);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "(literal_expr | attr) ':' pattern"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_key(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_literal_expr_var();
    void * _alt_1(void) {  // literal_expr
        // literal_expr
        expr_ty literal_expr_var;
        if (!(literal_expr_var = _item_literal_expr_var())) return NULL;
        // parse succeeded.
        return literal_expr_var;
    }
    static expr_ty _item_attr_var();
    void * _alt_2(void) {  // attr
        // attr
        expr_ty attr_var;
        if (!(attr_var = _item_attr_var())) return NULL;
        // parse succeeded.
        return attr_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "literal_expr"},
        {_alt_2, "_alt_2", "attr"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_literal_expr_var(void) {
    return _literal_expr_rule(p);
}
expr_ty _item_attr_var(void) {
    return _attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
pattern_ty _item_pattern(void) {
    return _pattern_rule(p);
}

// double_star_pattern: '**' pattern_capture_target
static void * _double_star_pattern_parse(RuleDescr *);
expr_ty _double_star_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "double_star_pattern", "'**' pattern_capture_target"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _double_star_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_target();
    void * _alt(void) {  // '**' pattern_capture_target
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // pattern_capture_target
        expr_ty target;
        if (!(target = _item_target())) return NULL;
        // parse succeeded.
        return target;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'**' pattern_capture_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_target(void) {
    return _pattern_capture_target_rule(p);
}

// class_pattern: name_or_attr '(' ')' | name_or_attr '(' positional_patterns
//     ','? ')' | name_or_attr '(' keyword_patterns ','? ')' | name_or_attr '('
//     positional_patterns ',' keyword_patterns ','? ')' | invalid_class_pattern
static void * _class_pattern_parse(RuleDescr *);
pattern_ty _class_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "class_pattern", "name_or_attr '(' ')' | name_or_attr '(' positional_patterns ','? ')' | name_or_attr '(' keyword_patterns ','? ')' | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' | invalid_class_pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _class_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_cls();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // name_or_attr '(' ')'
        // name_or_attr
        expr_ty cls;
        if (!(cls = _item_cls())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchClass (cls , NULL , NULL , NULL , EXTRA);
    }
    static expr_ty _item_cls();
    static Token * _item__literal_var();
    static asdl_pattern_seq* _item_patterns();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // name_or_attr '(' positional_patterns ','? ')'
        // name_or_attr
        expr_ty cls;
        if (!(cls = _item_cls())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // positional_patterns
        asdl_pattern_seq* patterns;
        if (!(patterns = _item_patterns())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchClass (cls , patterns , NULL , NULL , EXTRA);
    }
    static expr_ty _item_cls();
    static Token * _item__literal_var();
    static asdl_seq* _item_keywords();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // name_or_attr '(' keyword_patterns ','? ')'
        // name_or_attr
        expr_ty cls;
        if (!(cls = _item_cls())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // keyword_patterns
        asdl_seq* keywords;
        if (!(keywords = _item_keywords())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchClass (cls , NULL , CHECK (asdl_identifier_seq* , _PyPegen_map_names_to_ids (p , CHECK (asdl_expr_seq* , _PyPegen_get_pattern_keys (p , keywords)))) , CHECK (asdl_pattern_seq* , _PyPegen_get_patterns (p , keywords)) , EXTRA);
    }
    static expr_ty _item_cls();
    static Token * _item__literal_var();
    static asdl_pattern_seq* _item_patterns();
    static Token * _item__literal_var_1();
    static asdl_seq* _item_keywords();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_2();
    void * _alt_4(void) {  // name_or_attr '(' positional_patterns ','
    //     keyword_patterns ','? ')'
        // name_or_attr
        expr_ty cls;
        if (!(cls = _item_cls())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // positional_patterns
        asdl_pattern_seq* patterns;
        if (!(patterns = _item_patterns())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // keyword_patterns
        asdl_seq* keywords;
        if (!(keywords = _item_keywords())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_MatchClass (cls , patterns , CHECK (asdl_identifier_seq* , _PyPegen_map_names_to_ids (p , CHECK (asdl_expr_seq* , _PyPegen_get_pattern_keys (p , keywords)))) , CHECK (asdl_pattern_seq* , _PyPegen_get_patterns (p , keywords)) , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_class_pattern
    static void * _item_invalid_class_pattern_var();
    void * _alt_5(void) {  // invalid_class_pattern
        // invalid_class_pattern
        void * invalid_class_pattern_var;
        if (!(invalid_class_pattern_var = _item_invalid_class_pattern_var())) return NULL;
        // parse succeeded.
        return invalid_class_pattern_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "name_or_attr '(' ')'"},
        {_alt_2, "_alt_2", "name_or_attr '(' positional_patterns ','? ')'"},
        {_alt_3, "_alt_3", "name_or_attr '(' keyword_patterns ','? ')'"},
        {_alt_4, "_alt_4", "name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'"},
        {_alt_5, "_alt_5", "invalid_class_pattern"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_cls(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
expr_ty _item_cls(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_pattern_seq* _item_patterns(void) {
    return _positional_patterns_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
expr_ty _item_cls(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq* _item_keywords(void) {
    return _keyword_patterns_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
expr_ty _item_cls(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_pattern_seq* _item_patterns(void) {
    return _positional_patterns_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq* _item_keywords(void) {
    return _keyword_patterns_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
void * _item_invalid_class_pattern_var(void) {
    return _invalid_class_pattern_rule(p);
}

// positional_patterns: ','.pattern+
static void * _positional_patterns_parse(RuleDescr *);
asdl_pattern_seq* _positional_patterns_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "positional_patterns", "','.pattern+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _positional_patterns_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_args();
    void * _alt(void) {  // ','.pattern+
        // ','.pattern+
        asdl_pattern_seq* args;
        if (!(args = _item_args())) return NULL;
        // parse succeeded.
        return args;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.pattern+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_args(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
pattern_ty _node(void) {
    return _pattern_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// keyword_patterns: ','.keyword_pattern+
static void * _keyword_patterns_parse(RuleDescr *);
asdl_seq* _keyword_patterns_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "keyword_patterns", "','.keyword_pattern+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _keyword_patterns_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item__loop_var();
    void * _alt(void) {  // ','.keyword_pattern+
        // ','.keyword_pattern+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.keyword_pattern+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeyPatternPair* _node(void) {
    return _keyword_pattern_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// keyword_pattern: NAME '=' pattern
static void * _keyword_pattern_parse(RuleDescr *);
KeyPatternPair* _keyword_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "keyword_pattern", "NAME '=' pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _keyword_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_arg();
    static Token * _item__literal_var();
    static pattern_ty _item_value();
    void * _alt(void) {  // NAME '=' pattern
        // NAME
        expr_ty arg;
        if (!(arg = _item_arg())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // pattern
        pattern_ty value;
        if (!(value = _item_value())) return NULL;
        // parse succeeded.
        return _PyPegen_key_pattern_pair (p , arg , value);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME '=' pattern"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arg(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
pattern_ty _item_value(void) {
    return _pattern_rule(p);
}

// expressions: expression ((',' expression))+ [','] | expression ',' |
//     expression
static void * _expressions_parse(RuleDescr *);
expr_ty _expressions_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "expressions", "expression ((',' expression))+ [','] | expression ',' | expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _expressions_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_opt_var();
    void * _alt_1(void) {  // expression ((',' expression))+ [',']
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ((',' expression))+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , a , b)) , Load , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_2(void) {  // expression ','
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_singleton_seq (p , a)) , Load , EXTRA);
    }
    static expr_ty _item_expression_var();
    void * _alt_3(void) {  // expression
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "expression ((',' expression))+ [',']"},
        {_alt_2, "_alt_2", "expression ','"},
        {_alt_3, "_alt_3", "expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_c();
    void * _alt(void) {  // ',' expression
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_c(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}

// expression: invalid_expression | invalid_legacy_expression | disjunction 'if'
//     disjunction 'else' expression | disjunction | lambdef
static void * _expression_parse(RuleDescr *);
expr_ty _expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "expression", "invalid_expression | invalid_legacy_expression | disjunction 'if' disjunction 'else' expression | disjunction | lambdef"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, expression_type);
}
void * _expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_expression
    static void * _item_invalid_expression_var();
    void * _alt_1(void) {  // invalid_expression
        // invalid_expression
        void * invalid_expression_var;
        if (!(invalid_expression_var = _item_invalid_expression_var())) return NULL;
        // parse succeeded.
        return invalid_expression_var;
    }
    }
    if (p->call_invalid_rules) {   // invalid_legacy_expression
    static void * _item_invalid_legacy_expression_var();
    void * _alt_2(void) {  // invalid_legacy_expression
        // invalid_legacy_expression
        void * invalid_legacy_expression_var;
        if (!(invalid_legacy_expression_var = _item_invalid_legacy_expression_var())) return NULL;
        // parse succeeded.
        return invalid_legacy_expression_var;
    }
    }
    static expr_ty _item_a();
    static Token * _item__keyword_var();
    static expr_ty _item_b();
    static Token * _item__keyword_var_1();
    static expr_ty _item_c();
    void * _alt_3(void) {  // disjunction 'if' disjunction 'else' expression
        // disjunction
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // disjunction
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // 'else'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // expression
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_IfExp (b , a , c , EXTRA);
    }
    static expr_ty _item_disjunction_var();
    void * _alt_4(void) {  // disjunction
        // disjunction
        expr_ty disjunction_var;
        if (!(disjunction_var = _item_disjunction_var())) return NULL;
        // parse succeeded.
        return disjunction_var;
    }
    static expr_ty _item_lambdef_var();
    void * _alt_5(void) {  // lambdef
        // lambdef
        expr_ty lambdef_var;
        if (!(lambdef_var = _item_lambdef_var())) return NULL;
        // parse succeeded.
        return lambdef_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_expression"},
        {_alt_2, "_alt_2", "invalid_legacy_expression"},
        {_alt_3, "_alt_3", "disjunction 'if' disjunction 'else' expression"},
        {_alt_4, "_alt_4", "disjunction"},
        {_alt_5, "_alt_5", "lambdef"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_expression_var(void) {
    return _invalid_expression_rule(p);
}
void * _item_invalid_legacy_expression_var(void) {
    return _invalid_legacy_expression_rule(p);
}
expr_ty _item_a(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_b(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 642);   // keyword='else'
}
expr_ty _item_c(void) {
    return _expression_rule(p);
}
expr_ty _item_disjunction_var(void) {
    return _disjunction_rule(p);
}
expr_ty _item_lambdef_var(void) {
    return _lambdef_rule(p);
}

// yield_expr: 'yield' 'from' expression | 'yield' [star_expressions]
static void * _yield_expr_parse(RuleDescr *);
expr_ty _yield_expr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "yield_expr", "'yield' 'from' expression | 'yield' [star_expressions]"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _yield_expr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static Token * _item__keyword_var_1();
    static expr_ty _item_a();
    void * _alt_1(void) {  // 'yield' 'from' expression
        // 'yield'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // 'from'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_YieldFrom (a , EXTRA);
    }
    static Token * _item__keyword_var();
    static ParseResult[Any] _item_a();
    void * _alt_2(void) {  // 'yield' [star_expressions]
        // 'yield'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // [star_expressions]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Yield (a , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'yield' 'from' expression"},
        {_alt_2, "_alt_2", "'yield' [star_expressions]"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 573);   // keyword='yield'
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 572);   // keyword='from'
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 573);   // keyword='yield'
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_star_expressions_var();
    void * _alt(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}

// star_expressions: star_expression ((',' star_expression))+ [','] |
//     star_expression ',' | star_expression
static void * _star_expressions_parse(RuleDescr *);
expr_ty _star_expressions_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_expressions", "star_expression ((',' star_expression))+ [','] | star_expression ',' | star_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_expressions_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_opt_var();
    void * _alt_1(void) {  // star_expression ((',' star_expression))+ [',']
        // star_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ((',' star_expression))+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , a , b)) , Load , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_2(void) {  // star_expression ','
        // star_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_singleton_seq (p , a)) , Load , EXTRA);
    }
    static expr_ty _item_star_expression_var();
    void * _alt_3(void) {  // star_expression
        // star_expression
        expr_ty star_expression_var;
        if (!(star_expression_var = _item_star_expression_var())) return NULL;
        // parse succeeded.
        return star_expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "star_expression ((',' star_expression))+ [',']"},
        {_alt_2, "_alt_2", "star_expression ','"},
        {_alt_3, "_alt_3", "star_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _star_expression_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_c();
    void * _alt(void) {  // ',' star_expression
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_expression
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' star_expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_c(void) {
    return _star_expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_a(void) {
    return _star_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_star_expression_var(void) {
    return _star_expression_rule(p);
}

// star_expression: '*' bitwise_or | expression
static void * _star_expression_parse(RuleDescr *);
expr_ty _star_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_expression", "'*' bitwise_or | expression"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, star_expression_type);
}
void * _star_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // '*' bitwise_or
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Starred (a , Load , EXTRA);
    }
    static expr_ty _item_expression_var();
    void * _alt_2(void) {  // expression
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' bitwise_or"},
        {_alt_2, "_alt_2", "expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}

// star_named_expressions: ','.star_named_expression+ [',']
static void * _star_named_expressions_parse(RuleDescr *);
asdl_expr_seq* _star_named_expressions_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_named_expressions", "','.star_named_expression+ [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_named_expressions_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // ','.star_named_expression+ [',']
        // ','.star_named_expression+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.star_named_expression+ [',']"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _star_named_expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// star_named_expression: '*' bitwise_or | named_expression
static void * _star_named_expression_parse(RuleDescr *);
expr_ty _star_named_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_named_expression", "'*' bitwise_or | named_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_named_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // '*' bitwise_or
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Starred (a , Load , EXTRA);
    }
    static expr_ty _item_named_expression_var();
    void * _alt_2(void) {  // named_expression
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // parse succeeded.
        return named_expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' bitwise_or"},
        {_alt_2, "_alt_2", "named_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}

// assignment_expression: NAME ':=' ~ expression
static void * _assignment_expression_parse(RuleDescr *);
expr_ty _assignment_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "assignment_expression", "NAME ':=' ~ expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _assignment_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt(void) {  // NAME ':=' ~ expression
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ~
        // expression
        expr_ty b;
        if (!(b = _item_b())) return _PyPegen_cut_sentinel;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (expr_ty , 8 , "Assignment expressions are" , _PyAST_NamedExpr (CHECK (expr_ty , _PyPegen_set_expr_context (p , a , Store)) , b , EXTRA));
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME ':=' ~ expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}

// named_expression: assignment_expression | invalid_named_expression |
//     expression !':='
static void * _named_expression_parse(RuleDescr *);
expr_ty _named_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "named_expression", "assignment_expression | invalid_named_expression | expression !':='"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _named_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_assignment_expression_var();
    void * _alt_1(void) {  // assignment_expression
        // assignment_expression
        expr_ty assignment_expression_var;
        if (!(assignment_expression_var = _item_assignment_expression_var())) return NULL;
        // parse succeeded.
        return assignment_expression_var;
    }
    if (p->call_invalid_rules) {   // invalid_named_expression
    static void * _item_invalid_named_expression_var();
    void * _alt_2(void) {  // invalid_named_expression
        // invalid_named_expression
        void * invalid_named_expression_var;
        if (!(invalid_named_expression_var = _item_invalid_named_expression_var())) return NULL;
        // parse succeeded.
        return invalid_named_expression_var;
    }
    }
    static expr_ty _item_expression_var();
    static int _item__lookahead_var();
    void * _alt_3(void) {  // expression !':='
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // !':='
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, _lookahead_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "assignment_expression"},
        {_alt_2, "_alt_2", "invalid_named_expression"},
        {_alt_3, "_alt_3", "expression !':='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_assignment_expression_var(void) {
    return _assignment_expression_rule(p);
}
void * _item_invalid_named_expression_var(void) {
    return _invalid_named_expression_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}

// disjunction: conjunction (('or' conjunction))+ | conjunction
static void * _disjunction_parse(RuleDescr *);
expr_ty _disjunction_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "disjunction", "conjunction (('or' conjunction))+ | conjunction"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, disjunction_type);
}
void * _disjunction_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    void * _alt_1(void) {  // conjunction (('or' conjunction))+
        // conjunction
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // (('or' conjunction))+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BoolOp (Or , CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , a , b)) , EXTRA);
    }
    static expr_ty _item_conjunction_var();
    void * _alt_2(void) {  // conjunction
        // conjunction
        expr_ty conjunction_var;
        if (!(conjunction_var = _item_conjunction_var())) return NULL;
        // parse succeeded.
        return conjunction_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "conjunction (('or' conjunction))+"},
        {_alt_2, "_alt_2", "conjunction"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _conjunction_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_c();
    void * _alt(void) {  // 'or' conjunction
        // 'or'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // conjunction
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'or' conjunction"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 574);   // keyword='or'
}
expr_ty _item_c(void) {
    return _conjunction_rule(p);
}
expr_ty _item_conjunction_var(void) {
    return _conjunction_rule(p);
}

// conjunction: inversion (('and' inversion))+ | inversion
static void * _conjunction_parse(RuleDescr *);
expr_ty _conjunction_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "conjunction", "inversion (('and' inversion))+ | inversion"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, conjunction_type);
}
void * _conjunction_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    void * _alt_1(void) {  // inversion (('and' inversion))+
        // inversion
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // (('and' inversion))+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BoolOp (And , CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , a , b)) , EXTRA);
    }
    static expr_ty _item_inversion_var();
    void * _alt_2(void) {  // inversion
        // inversion
        expr_ty inversion_var;
        if (!(inversion_var = _item_inversion_var())) return NULL;
        // parse succeeded.
        return inversion_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "inversion (('and' inversion))+"},
        {_alt_2, "_alt_2", "inversion"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _inversion_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_c();
    void * _alt(void) {  // 'and' inversion
        // 'and'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // inversion
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'and' inversion"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 575);   // keyword='and'
}
expr_ty _item_c(void) {
    return _inversion_rule(p);
}
expr_ty _item_inversion_var(void) {
    return _inversion_rule(p);
}

// inversion: 'not' inversion | comparison
static void * _inversion_parse(RuleDescr *);
expr_ty _inversion_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "inversion", "'not' inversion | comparison"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, inversion_type);
}
void * _inversion_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // 'not' inversion
        // 'not'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // inversion
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (Not , a , EXTRA);
    }
    static expr_ty _item_comparison_var();
    void * _alt_2(void) {  // comparison
        // comparison
        expr_ty comparison_var;
        if (!(comparison_var = _item_comparison_var())) return NULL;
        // parse succeeded.
        return comparison_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'not' inversion"},
        {_alt_2, "_alt_2", "comparison"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 581);   // keyword='not'
}
expr_ty _item_a(void) {
    return _inversion_rule(p);
}
expr_ty _item_comparison_var(void) {
    return _comparison_rule(p);
}

// comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
static void * _comparison_parse(RuleDescr *);
expr_ty _comparison_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "comparison", "bitwise_or compare_op_bitwise_or_pair+ | bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _comparison_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    void * _alt_1(void) {  // bitwise_or compare_op_bitwise_or_pair+
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // compare_op_bitwise_or_pair+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Compare (a , CHECK (asdl_int_seq* , _PyPegen_get_cmpops (p , b)) , CHECK (asdl_expr_seq* , _PyPegen_get_exprs (p , b)) , EXTRA);
    }
    static expr_ty _item_bitwise_or_var();
    void * _alt_2(void) {  // bitwise_or
        // bitwise_or
        expr_ty bitwise_or_var;
        if (!(bitwise_or_var = _item_bitwise_or_var())) return NULL;
        // parse succeeded.
        return bitwise_or_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "bitwise_or compare_op_bitwise_or_pair+"},
        {_alt_2, "_alt_2", "bitwise_or"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
CmpopExprPair* _node(void) {
    return _compare_op_bitwise_or_pair_rule(p);
}
expr_ty _item_bitwise_or_var(void) {
    return _bitwise_or_rule(p);
}

// compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or
//     | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or |
//     in_bitwise_or | isnot_bitwise_or | is_bitwise_or
static void * _compare_op_bitwise_or_pair_parse(RuleDescr *);
CmpopExprPair* _compare_op_bitwise_or_pair_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "compare_op_bitwise_or_pair", "eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _compare_op_bitwise_or_pair_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static CmpopExprPair* _item_eq_bitwise_or_var();
    void * _alt_1(void) {  // eq_bitwise_or
        // eq_bitwise_or
        CmpopExprPair* eq_bitwise_or_var;
        if (!(eq_bitwise_or_var = _item_eq_bitwise_or_var())) return NULL;
        // parse succeeded.
        return eq_bitwise_or_var;
    }
    static CmpopExprPair* _item_noteq_bitwise_or_var();
    void * _alt_2(void) {  // noteq_bitwise_or
        // noteq_bitwise_or
        CmpopExprPair* noteq_bitwise_or_var;
        if (!(noteq_bitwise_or_var = _item_noteq_bitwise_or_var())) return NULL;
        // parse succeeded.
        return noteq_bitwise_or_var;
    }
    static CmpopExprPair* _item_lte_bitwise_or_var();
    void * _alt_3(void) {  // lte_bitwise_or
        // lte_bitwise_or
        CmpopExprPair* lte_bitwise_or_var;
        if (!(lte_bitwise_or_var = _item_lte_bitwise_or_var())) return NULL;
        // parse succeeded.
        return lte_bitwise_or_var;
    }
    static CmpopExprPair* _item_lt_bitwise_or_var();
    void * _alt_4(void) {  // lt_bitwise_or
        // lt_bitwise_or
        CmpopExprPair* lt_bitwise_or_var;
        if (!(lt_bitwise_or_var = _item_lt_bitwise_or_var())) return NULL;
        // parse succeeded.
        return lt_bitwise_or_var;
    }
    static CmpopExprPair* _item_gte_bitwise_or_var();
    void * _alt_5(void) {  // gte_bitwise_or
        // gte_bitwise_or
        CmpopExprPair* gte_bitwise_or_var;
        if (!(gte_bitwise_or_var = _item_gte_bitwise_or_var())) return NULL;
        // parse succeeded.
        return gte_bitwise_or_var;
    }
    static CmpopExprPair* _item_gt_bitwise_or_var();
    void * _alt_6(void) {  // gt_bitwise_or
        // gt_bitwise_or
        CmpopExprPair* gt_bitwise_or_var;
        if (!(gt_bitwise_or_var = _item_gt_bitwise_or_var())) return NULL;
        // parse succeeded.
        return gt_bitwise_or_var;
    }
    static CmpopExprPair* _item_notin_bitwise_or_var();
    void * _alt_7(void) {  // notin_bitwise_or
        // notin_bitwise_or
        CmpopExprPair* notin_bitwise_or_var;
        if (!(notin_bitwise_or_var = _item_notin_bitwise_or_var())) return NULL;
        // parse succeeded.
        return notin_bitwise_or_var;
    }
    static CmpopExprPair* _item_in_bitwise_or_var();
    void * _alt_8(void) {  // in_bitwise_or
        // in_bitwise_or
        CmpopExprPair* in_bitwise_or_var;
        if (!(in_bitwise_or_var = _item_in_bitwise_or_var())) return NULL;
        // parse succeeded.
        return in_bitwise_or_var;
    }
    static CmpopExprPair* _item_isnot_bitwise_or_var();
    void * _alt_9(void) {  // isnot_bitwise_or
        // isnot_bitwise_or
        CmpopExprPair* isnot_bitwise_or_var;
        if (!(isnot_bitwise_or_var = _item_isnot_bitwise_or_var())) return NULL;
        // parse succeeded.
        return isnot_bitwise_or_var;
    }
    static CmpopExprPair* _item_is_bitwise_or_var();
    void * _alt_10(void) {  // is_bitwise_or
        // is_bitwise_or
        CmpopExprPair* is_bitwise_or_var;
        if (!(is_bitwise_or_var = _item_is_bitwise_or_var())) return NULL;
        // parse succeeded.
        return is_bitwise_or_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "eq_bitwise_or"},
        {_alt_2, "_alt_2", "noteq_bitwise_or"},
        {_alt_3, "_alt_3", "lte_bitwise_or"},
        {_alt_4, "_alt_4", "lt_bitwise_or"},
        {_alt_5, "_alt_5", "gte_bitwise_or"},
        {_alt_6, "_alt_6", "gt_bitwise_or"},
        {_alt_7, "_alt_7", "notin_bitwise_or"},
        {_alt_8, "_alt_8", "in_bitwise_or"},
        {_alt_9, "_alt_9", "isnot_bitwise_or"},
        {_alt_10, "_alt_10", "is_bitwise_or"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
CmpopExprPair* _item_eq_bitwise_or_var(void) {
    return _eq_bitwise_or_rule(p);
}
CmpopExprPair* _item_noteq_bitwise_or_var(void) {
    return _noteq_bitwise_or_rule(p);
}
CmpopExprPair* _item_lte_bitwise_or_var(void) {
    return _lte_bitwise_or_rule(p);
}
CmpopExprPair* _item_lt_bitwise_or_var(void) {
    return _lt_bitwise_or_rule(p);
}
CmpopExprPair* _item_gte_bitwise_or_var(void) {
    return _gte_bitwise_or_rule(p);
}
CmpopExprPair* _item_gt_bitwise_or_var(void) {
    return _gt_bitwise_or_rule(p);
}
CmpopExprPair* _item_notin_bitwise_or_var(void) {
    return _notin_bitwise_or_rule(p);
}
CmpopExprPair* _item_in_bitwise_or_var(void) {
    return _in_bitwise_or_rule(p);
}
CmpopExprPair* _item_isnot_bitwise_or_var(void) {
    return _isnot_bitwise_or_rule(p);
}
CmpopExprPair* _item_is_bitwise_or_var(void) {
    return _is_bitwise_or_rule(p);
}

// eq_bitwise_or: '==' bitwise_or
static void * _eq_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _eq_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "eq_bitwise_or", "'==' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _eq_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '==' bitwise_or
        // '=='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , Eq , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'==' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 27);   // token===
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// noteq_bitwise_or: ('!=') bitwise_or
static void * _noteq_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _noteq_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "noteq_bitwise_or", "('!=') bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _noteq_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static void * _item__group_var();
    static expr_ty _item_a();
    void * _alt(void) {  // ('!=') bitwise_or
        // ('!=')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , NotEq , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "('!=') bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item_tok();
    void * _alt(void) {  // '!='
        // '!='
        Token * tok;
        if (!(tok = _item_tok())) return NULL;
        // parse succeeded.
        return _PyPegen_check_barry_as_flufl (p , tok) ? NULL : tok;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'!='"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item_tok(void) {
    return _PyPegen_expect_token(p, 28);   // token=!=
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// lte_bitwise_or: '<=' bitwise_or
static void * _lte_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _lte_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lte_bitwise_or", "'<=' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lte_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '<=' bitwise_or
        // '<='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , LtE , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'<=' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 29);   // token=<=
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// lt_bitwise_or: '<' bitwise_or
static void * _lt_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _lt_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lt_bitwise_or", "'<' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lt_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '<' bitwise_or
        // '<'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , Lt , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'<' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 20);   // token=<
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// gte_bitwise_or: '>=' bitwise_or
static void * _gte_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _gte_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "gte_bitwise_or", "'>=' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _gte_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '>=' bitwise_or
        // '>='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , GtE , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'>=' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 30);   // token=>=
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// gt_bitwise_or: '>' bitwise_or
static void * _gt_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _gt_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "gt_bitwise_or", "'>' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _gt_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '>' bitwise_or
        // '>'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , Gt , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'>' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 21);   // token=>
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// notin_bitwise_or: 'not' 'in' bitwise_or
static void * _notin_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _notin_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "notin_bitwise_or", "'not' 'in' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _notin_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static Token * _item__keyword_var_1();
    static expr_ty _item_a();
    void * _alt(void) {  // 'not' 'in' bitwise_or
        // 'not'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , NotIn , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'not' 'in' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 581);   // keyword='not'
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// in_bitwise_or: 'in' bitwise_or
static void * _in_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _in_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "in_bitwise_or", "'in' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _in_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt(void) {  // 'in' bitwise_or
        // 'in'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , In , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'in' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// isnot_bitwise_or: 'is' 'not' bitwise_or
static void * _isnot_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _isnot_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "isnot_bitwise_or", "'is' 'not' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _isnot_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static Token * _item__keyword_var_1();
    static expr_ty _item_a();
    void * _alt(void) {  // 'is' 'not' bitwise_or
        // 'is'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // 'not'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , IsNot , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'is' 'not' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 582);   // keyword='is'
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 581);   // keyword='not'
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// is_bitwise_or: 'is' bitwise_or
static void * _is_bitwise_or_parse(RuleDescr *);
CmpopExprPair* _is_bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "is_bitwise_or", "'is' bitwise_or"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _is_bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt(void) {  // 'is' bitwise_or
        // 'is'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_cmpop_expr_pair (p , Is , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'is' bitwise_or"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 582);   // keyword='is'
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}

// Left-recursive leader
// bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
static void * _bitwise_or_parse(RuleDescr *);
expr_ty _bitwise_or_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "bitwise_or", "bitwise_or '|' bitwise_xor | bitwise_xor"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _bitwise_or_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // bitwise_or '|' bitwise_xor
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '|'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_xor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , BitOr , b , EXTRA);
    }
    static expr_ty _item_bitwise_xor_var();
    void * _alt_2(void) {  // bitwise_xor
        // bitwise_xor
        expr_ty bitwise_xor_var;
        if (!(bitwise_xor_var = _item_bitwise_xor_var())) return NULL;
        // parse succeeded.
        return bitwise_xor_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "bitwise_or '|' bitwise_xor"},
        {_alt_2, "_alt_2", "bitwise_xor"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 18);   // token=|
}
expr_ty _item_b(void) {
    return _bitwise_xor_rule(p);
}
expr_ty _item_bitwise_xor_var(void) {
    return _bitwise_xor_rule(p);
}

// Left-recursive leader
// bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
static void * _bitwise_xor_parse(RuleDescr *);
expr_ty _bitwise_xor_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "bitwise_xor", "bitwise_xor '^' bitwise_and | bitwise_and"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _bitwise_xor_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // bitwise_xor '^' bitwise_and
        // bitwise_xor
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '^'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_and
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , BitXor , b , EXTRA);
    }
    static expr_ty _item_bitwise_and_var();
    void * _alt_2(void) {  // bitwise_and
        // bitwise_and
        expr_ty bitwise_and_var;
        if (!(bitwise_and_var = _item_bitwise_and_var())) return NULL;
        // parse succeeded.
        return bitwise_and_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "bitwise_xor '^' bitwise_and"},
        {_alt_2, "_alt_2", "bitwise_and"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _bitwise_xor_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 32);   // token=^
}
expr_ty _item_b(void) {
    return _bitwise_and_rule(p);
}
expr_ty _item_bitwise_and_var(void) {
    return _bitwise_and_rule(p);
}

// Left-recursive leader
// bitwise_and: bitwise_and '&' shift_expr | shift_expr
static void * _bitwise_and_parse(RuleDescr *);
expr_ty _bitwise_and_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "bitwise_and", "bitwise_and '&' shift_expr | shift_expr"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _bitwise_and_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // bitwise_and '&' shift_expr
        // bitwise_and
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '&'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // shift_expr
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , BitAnd , b , EXTRA);
    }
    static expr_ty _item_shift_expr_var();
    void * _alt_2(void) {  // shift_expr
        // shift_expr
        expr_ty shift_expr_var;
        if (!(shift_expr_var = _item_shift_expr_var())) return NULL;
        // parse succeeded.
        return shift_expr_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "bitwise_and '&' shift_expr"},
        {_alt_2, "_alt_2", "shift_expr"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _bitwise_and_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 19);   // token=&
}
expr_ty _item_b(void) {
    return _shift_expr_rule(p);
}
expr_ty _item_shift_expr_var(void) {
    return _shift_expr_rule(p);
}

// Left-recursive leader
// shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
static void * _shift_expr_parse(RuleDescr *);
expr_ty _shift_expr_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "shift_expr", "shift_expr '<<' sum | shift_expr '>>' sum | sum"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _shift_expr_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // shift_expr '<<' sum
        // shift_expr
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '<<'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // sum
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , LShift , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_2(void) {  // shift_expr '>>' sum
        // shift_expr
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '>>'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // sum
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , RShift , b , EXTRA);
    }
    static expr_ty _item_sum_var();
    void * _alt_3(void) {  // sum
        // sum
        expr_ty sum_var;
        if (!(sum_var = _item_sum_var())) return NULL;
        // parse succeeded.
        return sum_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "shift_expr '<<' sum"},
        {_alt_2, "_alt_2", "shift_expr '>>' sum"},
        {_alt_3, "_alt_3", "sum"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _shift_expr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 33);   // token=<<
}
expr_ty _item_b(void) {
    return _sum_rule(p);
}
expr_ty _item_a(void) {
    return _shift_expr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 34);   // token=>>
}
expr_ty _item_b(void) {
    return _sum_rule(p);
}
expr_ty _item_sum_var(void) {
    return _sum_rule(p);
}

// Left-recursive leader
// sum: sum '+' term | sum '-' term | term
static void * _sum_parse(RuleDescr *);
expr_ty _sum_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "sum", "sum '+' term | sum '-' term | term"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _sum_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // sum '+' term
        // sum
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '+'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // term
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Add , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_2(void) {  // sum '-' term
        // sum
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // term
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Sub , b , EXTRA);
    }
    static expr_ty _item_term_var();
    void * _alt_3(void) {  // term
        // term
        expr_ty term_var;
        if (!(term_var = _item_term_var())) return NULL;
        // parse succeeded.
        return term_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "sum '+' term"},
        {_alt_2, "_alt_2", "sum '-' term"},
        {_alt_3, "_alt_3", "term"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _sum_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 14);   // token=+
}
expr_ty _item_b(void) {
    return _term_rule(p);
}
expr_ty _item_a(void) {
    return _sum_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_b(void) {
    return _term_rule(p);
}
expr_ty _item_term_var(void) {
    return _term_rule(p);
}

// Left-recursive leader
// term: term '*' factor | term '/' factor | term '//' factor | term '%' factor
//     | term '@' factor | factor
static void * _term_parse(RuleDescr *);
expr_ty _term_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "term", "term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _term_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // term '*' factor
        // term
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Mult , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_2(void) {  // term '/' factor
        // term
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Div , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_3(void) {  // term '//' factor
        // term
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '//'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , FloorDiv , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_4(void) {  // term '%' factor
        // term
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '%'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Mod , b , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_5(void) {  // term '@' factor
        // term
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '@'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (expr_ty , 5 , "The '@' operator is" , _PyAST_BinOp (a , MatMult , b , EXTRA));
    }
    static expr_ty _item_factor_var();
    void * _alt_6(void) {  // factor
        // factor
        expr_ty factor_var;
        if (!(factor_var = _item_factor_var())) return NULL;
        // parse succeeded.
        return factor_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "term '*' factor"},
        {_alt_2, "_alt_2", "term '/' factor"},
        {_alt_3, "_alt_3", "term '//' factor"},
        {_alt_4, "_alt_4", "term '%' factor"},
        {_alt_5, "_alt_5", "term '@' factor"},
        {_alt_6, "_alt_6", "factor"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _term_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_a(void) {
    return _term_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_a(void) {
    return _term_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 47);   // token=//
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_a(void) {
    return _term_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 24);   // token=%
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_a(void) {
    return _term_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 49);   // token=@
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_factor_var(void) {
    return _factor_rule(p);
}

// factor: '+' factor | '-' factor | '~' factor | power
static void * _factor_parse(RuleDescr *);
expr_ty _factor_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "factor", "'+' factor | '-' factor | '~' factor | power"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, factor_type);
}
void * _factor_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // '+' factor
        // '+'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (UAdd , a , EXTRA);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_2(void) {  // '-' factor
        // '-'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (USub , a , EXTRA);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_3(void) {  // '~' factor
        // '~'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_UnaryOp (Invert , a , EXTRA);
    }
    static expr_ty _item_power_var();
    void * _alt_4(void) {  // power
        // power
        expr_ty power_var;
        if (!(power_var = _item_power_var())) return NULL;
        // parse succeeded.
        return power_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'+' factor"},
        {_alt_2, "_alt_2", "'-' factor"},
        {_alt_3, "_alt_3", "'~' factor"},
        {_alt_4, "_alt_4", "power"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 14);   // token=+
}
expr_ty _item_a(void) {
    return _factor_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 15);   // token=-
}
expr_ty _item_a(void) {
    return _factor_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 31);   // token=~
}
expr_ty _item_a(void) {
    return _factor_rule(p);
}
expr_ty _item_power_var(void) {
    return _power_rule(p);
}

// power: await_primary '**' factor | await_primary
static void * _power_parse(RuleDescr *);
expr_ty _power_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "power", "await_primary '**' factor | await_primary"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _power_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // await_primary '**' factor
        // await_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // factor
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_BinOp (a , Pow , b , EXTRA);
    }
    static expr_ty _item_await_primary_var();
    void * _alt_2(void) {  // await_primary
        // await_primary
        expr_ty await_primary_var;
        if (!(await_primary_var = _item_await_primary_var())) return NULL;
        // parse succeeded.
        return await_primary_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "await_primary '**' factor"},
        {_alt_2, "_alt_2", "await_primary"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _await_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_b(void) {
    return _factor_rule(p);
}
expr_ty _item_await_primary_var(void) {
    return _await_primary_rule(p);
}

// await_primary: AWAIT primary | primary
static void * _await_primary_parse(RuleDescr *);
expr_ty _await_primary_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "await_primary", "AWAIT primary | primary"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, await_primary_type);
}
void * _await_primary_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__await_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // AWAIT primary
        // AWAIT
        Token * _await_var;
        if (!(_await_var = _item__await_var())) return NULL;
        // primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return CHECK_VERSION (expr_ty , 5 , "Await expressions are" , _PyAST_Await (a , EXTRA));
    }
    static expr_ty _item_primary_var();
    void * _alt_2(void) {  // primary
        // primary
        expr_ty primary_var;
        if (!(primary_var = _item_primary_var())) return NULL;
        // parse succeeded.
        return primary_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "AWAIT primary"},
        {_alt_2, "_alt_2", "primary"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__await_var(void) {
    return _PyPegen_expect_token(p, 55);
}
expr_ty _item_a(void) {
    return _primary_rule(p);
}
expr_ty _item_primary_var(void) {
    return _primary_rule(p);
}

// Left-recursive leader
// primary: primary '.' NAME | primary genexp | primary '(' [arguments] ')' |
//     primary '[' slices ']' | atom
static void * _primary_parse(RuleDescr *);
expr_ty _primary_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "primary", "primary '.' NAME | primary genexp | primary '(' [arguments] ')' | primary '[' slices ']' | atom"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _primary_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_1(void) {  // primary '.' NAME
        // primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (a , b -> v . Name . id , Load , EXTRA);
    }
    static expr_ty _item_a();
    static expr_ty _item_b();
    void * _alt_2(void) {  // primary genexp
        // primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // genexp
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Call (a , CHECK (asdl_expr_seq* , (asdl_expr_seq*) _PyPegen_singleton_seq (p , b)) , NULL , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_b();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // primary '(' [arguments] ')'
        // primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [arguments]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Call (a , (b) ? ((expr_ty) b) -> v . Call . args : NULL , (b) ? ((expr_ty) b) -> v . Call . keywords : NULL , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    void * _alt_4(void) {  // primary '[' slices ']'
        // primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // slices
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Subscript (a , b , Load , EXTRA);
    }
    static expr_ty _item_atom_var();
    void * _alt_5(void) {  // atom
        // atom
        expr_ty atom_var;
        if (!(atom_var = _item_atom_var())) return NULL;
        // parse succeeded.
        return atom_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "primary '.' NAME"},
        {_alt_2, "_alt_2", "primary genexp"},
        {_alt_3, "_alt_3", "primary '(' [arguments] ')'"},
        {_alt_4, "_alt_4", "primary '[' slices ']'"},
        {_alt_5, "_alt_5", "atom"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
expr_ty _item_a(void) {
    return _primary_rule(p);
}
expr_ty _item_b(void) {
    return _genexp_rule(p);
}
expr_ty _item_a(void) {
    return _primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_arguments_var();
    void * _alt(void) {  // arguments
        // arguments
        expr_ty arguments_var;
        if (!(arguments_var = _item_arguments_var())) return NULL;
        // parse succeeded.
        return arguments_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "arguments"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arguments_var(void) {
    return _arguments_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
expr_ty _item_a(void) {
    return _primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_b(void) {
    return _slices_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
expr_ty _item_atom_var(void) {
    return _atom_rule(p);
}

// slices: slice !',' | ','.(slice | starred_expression)+ [',']
static void * _slices_parse(RuleDescr *);
expr_ty _slices_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "slices", "slice !',' | ','.(slice | starred_expression)+ [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _slices_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // slice !','
        // slice
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // !','
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    void * _alt_2(void) {  // ','.(slice | starred_expression)+ [',']
        // ','.(slice | starred_expression)+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (a , Load , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slice !','"},
        {_alt_2, "_alt_2", "','.(slice | starred_expression)+ [',']"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _slice_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_slice_var();
    void * _alt_1(void) {  // slice
        // slice
        expr_ty slice_var;
        if (!(slice_var = _item_slice_var())) return NULL;
        // parse succeeded.
        return slice_var;
    }
    static expr_ty _item_starred_expression_var();
    void * _alt_2(void) {  // starred_expression
        // starred_expression
        expr_ty starred_expression_var;
        if (!(starred_expression_var = _item_starred_expression_var())) return NULL;
        // parse succeeded.
        return starred_expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slice"},
        {_alt_2, "_alt_2", "starred_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_slice_var(void) {
    return _slice_rule(p);
}
expr_ty _item_starred_expression_var(void) {
    return _starred_expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// slice: [expression] ':' [expression] [':' [expression]] | named_expression
static void * _slice_parse(RuleDescr *);
expr_ty _slice_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "slice", "[expression] ':' [expression] [':' [expression]] | named_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _slice_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_1(void) {  // [expression] ':' [expression] [':' [expression]]
        // [expression]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [expression]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [':' [expression]]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Slice (a , b , c , EXTRA);
    }
    static expr_ty _item_a();
    void * _alt_2(void) {  // named_expression
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "[expression] ':' [expression] [':' [expression]]"},
        {_alt_2, "_alt_2", "named_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_expression_var();
    void * _alt(void) {  // expression
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return expression_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_expression_var();
    void * _alt(void) {  // expression
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return expression_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_d();
    void * _alt(void) {  // ':' [expression]
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [expression]
        ParseResult[Any] d;
        if ((d = (ParseResult[Any]) _item_d()), p->error_indicator) return NULL;
        d = _item_d();
        // parse succeeded.
        return d;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "':' [expression]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
ParseResult[Any] _item_d(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_expression_var();
    void * _alt(void) {  // expression
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return expression_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}

// atom: NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'('
//     (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set |
//     dictcomp | setcomp) | '...'
static void * _atom_parse(RuleDescr *);
expr_ty _atom_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "atom", "NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _atom_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_NAME_var();
    void * _alt_1(void) {  // NAME
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return NAME_var;
    }
    static Token * _item__keyword_var();
    void * _alt_2(void) {  // 'True'
        // 'True'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_True , NULL , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_3(void) {  // 'False'
        // 'False'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_False , NULL , EXTRA);
    }
    static Token * _item__keyword_var();
    void * _alt_4(void) {  // 'None'
        // 'None'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_None , NULL , EXTRA);
    }
    static int _item__lookahead_var();
    static expr_ty _item_strings_var();
    void * _alt_5(void) {  // &STRING strings
        // &STRING
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // strings
        expr_ty strings_var;
        if (!(strings_var = _item_strings_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, strings_var);
    }
    static expr_ty _item_NUMBER_var();
    void * _alt_6(void) {  // NUMBER
        // NUMBER
        expr_ty NUMBER_var;
        if (!(NUMBER_var = _item_NUMBER_var())) return NULL;
        // parse succeeded.
        return NUMBER_var;
    }
    static int _item__lookahead_var();
    static void * _item__group_var();
    void * _alt_7(void) {  // &'(' (tuple | group | genexp)
        // &'('
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // (tuple | group | genexp)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, _group_var);
    }
    static int _item__lookahead_var();
    static void * _item__group_var();
    void * _alt_8(void) {  // &'[' (list | listcomp)
        // &'['
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // (list | listcomp)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, _group_var);
    }
    static int _item__lookahead_var();
    static void * _item__group_var();
    void * _alt_9(void) {  // &'{' (dict | set | dictcomp | setcomp)
        // &'{'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // (dict | set | dictcomp | setcomp)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, _group_var);
    }
    static Token * _item__literal_var();
    void * _alt_10(void) {  // '...'
        // '...'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Constant (Py_Ellipsis , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NAME"},
        {_alt_2, "_alt_2", "'True'"},
        {_alt_3, "_alt_3", "'False'"},
        {_alt_4, "_alt_4", "'None'"},
        {_alt_5, "_alt_5", "&STRING strings"},
        {_alt_6, "_alt_6", "NUMBER"},
        {_alt_7, "_alt_7", "&'(' (tuple | group | genexp)"},
        {_alt_8, "_alt_8", "&'[' (list | listcomp)"},
        {_alt_9, "_alt_9", "&'{' (dict | set | dictcomp | setcomp)"},
        {_alt_10, "_alt_10", "'...'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 600);   // keyword='True'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 602);   // keyword='False'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 601);   // keyword='None'
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_string_token(p);
}
expr_ty _item_strings_var(void) {
    return _strings_rule(p);
}
expr_ty _item_NUMBER_var(void) {
    return _PyPegen_number_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_tuple_var();
    void * _alt_1(void) {  // tuple
        // tuple
        expr_ty tuple_var;
        if (!(tuple_var = _item_tuple_var())) return NULL;
        // parse succeeded.
        return tuple_var;
    }
    static expr_ty _item_group_var();
    void * _alt_2(void) {  // group
        // group
        expr_ty group_var;
        if (!(group_var = _item_group_var())) return NULL;
        // parse succeeded.
        return group_var;
    }
    static expr_ty _item_genexp_var();
    void * _alt_3(void) {  // genexp
        // genexp
        expr_ty genexp_var;
        if (!(genexp_var = _item_genexp_var())) return NULL;
        // parse succeeded.
        return genexp_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "tuple"},
        {_alt_2, "_alt_2", "group"},
        {_alt_3, "_alt_3", "genexp"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_tuple_var(void) {
    return _tuple_rule(p);
}
expr_ty _item_group_var(void) {
    return _group_rule(p);
}
expr_ty _item_genexp_var(void) {
    return _genexp_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_list_var();
    void * _alt_1(void) {  // list
        // list
        expr_ty list_var;
        if (!(list_var = _item_list_var())) return NULL;
        // parse succeeded.
        return list_var;
    }
    static expr_ty _item_listcomp_var();
    void * _alt_2(void) {  // listcomp
        // listcomp
        expr_ty listcomp_var;
        if (!(listcomp_var = _item_listcomp_var())) return NULL;
        // parse succeeded.
        return listcomp_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "list"},
        {_alt_2, "_alt_2", "listcomp"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_list_var(void) {
    return _list_rule(p);
}
expr_ty _item_listcomp_var(void) {
    return _listcomp_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_dict_var();
    void * _alt_1(void) {  // dict
        // dict
        expr_ty dict_var;
        if (!(dict_var = _item_dict_var())) return NULL;
        // parse succeeded.
        return dict_var;
    }
    static expr_ty _item_set_var();
    void * _alt_2(void) {  // set
        // set
        expr_ty set_var;
        if (!(set_var = _item_set_var())) return NULL;
        // parse succeeded.
        return set_var;
    }
    static expr_ty _item_dictcomp_var();
    void * _alt_3(void) {  // dictcomp
        // dictcomp
        expr_ty dictcomp_var;
        if (!(dictcomp_var = _item_dictcomp_var())) return NULL;
        // parse succeeded.
        return dictcomp_var;
    }
    static expr_ty _item_setcomp_var();
    void * _alt_4(void) {  // setcomp
        // setcomp
        expr_ty setcomp_var;
        if (!(setcomp_var = _item_setcomp_var())) return NULL;
        // parse succeeded.
        return setcomp_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "dict"},
        {_alt_2, "_alt_2", "set"},
        {_alt_3, "_alt_3", "dictcomp"},
        {_alt_4, "_alt_4", "setcomp"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_dict_var(void) {
    return _dict_rule(p);
}
expr_ty _item_set_var(void) {
    return _set_rule(p);
}
expr_ty _item_dictcomp_var(void) {
    return _dictcomp_rule(p);
}
expr_ty _item_setcomp_var(void) {
    return _setcomp_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 52);   // token=...
}

// group: '(' (yield_expr | named_expression) ')' | invalid_group
static void * _group_parse(RuleDescr *);
expr_ty _group_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "group", "'(' (yield_expr | named_expression) ')' | invalid_group"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _group_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static void * _item_a();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '(' (yield_expr | named_expression) ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (yield_expr | named_expression)
        void * a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    if (p->call_invalid_rules) {   // invalid_group
    static void * _item_invalid_group_var();
    void * _alt_2(void) {  // invalid_group
        // invalid_group
        void * invalid_group_var;
        if (!(invalid_group_var = _item_invalid_group_var())) return NULL;
        // parse succeeded.
        return invalid_group_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'(' (yield_expr | named_expression) ')'"},
        {_alt_2, "_alt_2", "invalid_group"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_yield_expr_var();
    void * _alt_1(void) {  // yield_expr
        // yield_expr
        expr_ty yield_expr_var;
        if (!(yield_expr_var = _item_yield_expr_var())) return NULL;
        // parse succeeded.
        return yield_expr_var;
    }
    static expr_ty _item_named_expression_var();
    void * _alt_2(void) {  // named_expression
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // parse succeeded.
        return named_expression_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "yield_expr"},
        {_alt_2, "_alt_2", "named_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_yield_expr_var(void) {
    return _yield_expr_rule(p);
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
void * _item_invalid_group_var(void) {
    return _invalid_group_rule(p);
}

// lambdef: 'lambda' [lambda_params] ':' expression
static void * _lambdef_parse(RuleDescr *);
expr_ty _lambdef_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambdef", "'lambda' [lambda_params] ':' expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambdef_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt(void) {  // 'lambda' [lambda_params] ':' expression
        // 'lambda'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // [lambda_params]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Lambda ((a) ? a : CHECK (arguments_ty , _PyPegen_empty_arguments (p)) , b , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'lambda' [lambda_params] ':' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 586);   // keyword='lambda'
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arguments_ty _item_lambda_params_var();
    void * _alt(void) {  // lambda_params
        // lambda_params
        arguments_ty lambda_params_var;
        if (!(lambda_params_var = _item_lambda_params_var())) return NULL;
        // parse succeeded.
        return lambda_params_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_params"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arguments_ty _item_lambda_params_var(void) {
    return _lambda_params_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}

// lambda_params: invalid_lambda_parameters | lambda_parameters
static void * _lambda_params_parse(RuleDescr *);
arguments_ty _lambda_params_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_params", "invalid_lambda_parameters | lambda_parameters"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_params_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_lambda_parameters
    static void * _item_invalid_lambda_parameters_var();
    void * _alt_1(void) {  // invalid_lambda_parameters
        // invalid_lambda_parameters
        void * invalid_lambda_parameters_var;
        if (!(invalid_lambda_parameters_var = _item_invalid_lambda_parameters_var())) return NULL;
        // parse succeeded.
        return invalid_lambda_parameters_var;
    }
    }
    static arguments_ty _item_lambda_parameters_var();
    void * _alt_2(void) {  // lambda_parameters
        // lambda_parameters
        arguments_ty lambda_parameters_var;
        if (!(lambda_parameters_var = _item_lambda_parameters_var())) return NULL;
        // parse succeeded.
        return lambda_parameters_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_lambda_parameters"},
        {_alt_2, "_alt_2", "lambda_parameters"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_lambda_parameters_var(void) {
    return _invalid_lambda_parameters_rule(p);
}
arguments_ty _item_lambda_parameters_var(void) {
    return _lambda_parameters_rule(p);
}

// lambda_parameters: lambda_slash_no_default lambda_param_no_default*
//     lambda_param_with_default* [lambda_star_etc] | lambda_slash_with_default
//     lambda_param_with_default* [lambda_star_etc] | lambda_param_no_default+
//     lambda_param_with_default* [lambda_star_etc] | lambda_param_with_default+
//     [lambda_star_etc] | lambda_star_etc
static void * _lambda_parameters_parse(RuleDescr *);
arguments_ty _lambda_parameters_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_parameters", "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc] | lambda_slash_with_default lambda_param_with_default* [lambda_star_etc] | lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc] | lambda_param_with_default+ [lambda_star_etc] | lambda_star_etc"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_parameters_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_arg_seq* _item_a();
    static asdl_seq * _item_b();
    static asdl_seq * _item_c();
    static ParseResult[Any] _item_d();
    void * _alt_1(void) {  // lambda_slash_no_default lambda_param_no_default*
    //     lambda_param_with_default* [lambda_star_etc]
        // lambda_slash_no_default
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // lambda_param_no_default*
        asdl_arg_seq* b;
        if ((b = (asdl_arg_seq*) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // lambda_param_with_default*
        asdl_seq * c;
        if ((c = (asdl_seq *) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // [lambda_star_etc]
        ParseResult[Any] d;
        if ((d = (ParseResult[Any]) _item_d()), p->error_indicator) return NULL;
        d = _item_d();
        // parse succeeded.
        return CHECK_VERSION (arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments (p , a , NULL , b , c , d));
    }
    static SlashWithDefault* _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // lambda_slash_with_default
    //     lambda_param_with_default* [lambda_star_etc]
        // lambda_slash_with_default
        SlashWithDefault* a;
        if (!(a = _item_a())) return NULL;
        // lambda_param_with_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [lambda_star_etc]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return CHECK_VERSION (arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments (p , NULL , a , NULL , b , c));
    }
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // lambda_param_no_default+
    //     lambda_param_with_default* [lambda_star_etc]
        // lambda_param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // lambda_param_with_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [lambda_star_etc]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , a , b , c);
    }
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_b();
    void * _alt_4(void) {  // lambda_param_with_default+ [lambda_star_etc]
        // lambda_param_with_default+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // [lambda_star_etc]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , NULL , a , b);
    }
    static StarEtc* _item_a();
    void * _alt_5(void) {  // lambda_star_etc
        // lambda_star_etc
        StarEtc* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_make_arguments (p , NULL , NULL , NULL , NULL , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* [lambda_star_etc]"},
        {_alt_2, "_alt_2", "lambda_slash_with_default lambda_param_with_default* [lambda_star_etc]"},
        {_alt_3, "_alt_3", "lambda_param_no_default+ lambda_param_with_default* [lambda_star_etc]"},
        {_alt_4, "_alt_4", "lambda_param_with_default+ [lambda_star_etc]"},
        {_alt_5, "_alt_5", "lambda_star_etc"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_a(void) {
    return _lambda_slash_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item_c(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
ParseResult[Any] _item_d(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_lambda_star_etc_var();
    void * _alt(void) {  // lambda_star_etc
        // lambda_star_etc
        StarEtc* lambda_star_etc_var;
        if (!(lambda_star_etc_var = _item_lambda_star_etc_var())) return NULL;
        // parse succeeded.
        return lambda_star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_lambda_star_etc_var(void) {
    return _lambda_star_etc_rule(p);
}
SlashWithDefault* _item_a(void) {
    return _lambda_slash_with_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_lambda_star_etc_var();
    void * _alt(void) {  // lambda_star_etc
        // lambda_star_etc
        StarEtc* lambda_star_etc_var;
        if (!(lambda_star_etc_var = _item_lambda_star_etc_var())) return NULL;
        // parse succeeded.
        return lambda_star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_lambda_star_etc_var(void) {
    return _lambda_star_etc_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_lambda_star_etc_var();
    void * _alt(void) {  // lambda_star_etc
        // lambda_star_etc
        StarEtc* lambda_star_etc_var;
        if (!(lambda_star_etc_var = _item_lambda_star_etc_var())) return NULL;
        // parse succeeded.
        return lambda_star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_lambda_star_etc_var(void) {
    return _lambda_star_etc_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static StarEtc* _item_lambda_star_etc_var();
    void * _alt(void) {  // lambda_star_etc
        // lambda_star_etc
        StarEtc* lambda_star_etc_var;
        if (!(lambda_star_etc_var = _item_lambda_star_etc_var())) return NULL;
        // parse succeeded.
        return lambda_star_etc_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_star_etc"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
StarEtc* _item_lambda_star_etc_var(void) {
    return _lambda_star_etc_rule(p);
}
StarEtc* _item_a(void) {
    return _lambda_star_etc_rule(p);
}

// lambda_slash_no_default: lambda_param_no_default+ '/' ',' |
//     lambda_param_no_default+ '/' &':'
static void * _lambda_slash_no_default_parse(RuleDescr *);
asdl_arg_seq* _lambda_slash_no_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_slash_no_default", "lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_slash_no_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // lambda_param_no_default+ '/' ','
        // lambda_param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // lambda_param_no_default+ '/' &':'
        // lambda_param_no_default+
        asdl_arg_seq* a;
        if (!(a = _item_a())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // &':'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param_no_default+ '/' ','"},
        {_alt_2, "_alt_2", "lambda_param_no_default+ '/' &':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// lambda_slash_with_default: lambda_param_no_default*
//     lambda_param_with_default+ '/' ',' | lambda_param_no_default*
//     lambda_param_with_default+ '/' &':'
static void * _lambda_slash_with_default_parse(RuleDescr *);
SlashWithDefault* _lambda_slash_with_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_slash_with_default", "lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_slash_with_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // lambda_param_no_default*
    //     lambda_param_with_default+ '/' ','
        // lambda_param_no_default*
        asdl_seq * a;
        if ((a = (asdl_seq *) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // lambda_param_with_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_slash_with_default (p , (asdl_arg_seq*) a , b);
    }
    static asdl_seq * _item_a();
    static asdl_seq * _item_b();
    static Token * _item__literal_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // lambda_param_no_default*
    //     lambda_param_with_default+ '/' &':'
        // lambda_param_no_default*
        asdl_seq * a;
        if ((a = (asdl_seq *) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // lambda_param_with_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // &':'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_slash_with_default (p , (asdl_arg_seq*) a , b);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param_no_default* lambda_param_with_default+ '/' ','"},
        {_alt_2, "_alt_2", "lambda_param_no_default* lambda_param_with_default+ '/' &':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// lambda_star_etc: invalid_lambda_star_etc | '*' lambda_param_no_default
//     lambda_param_maybe_default* [lambda_kwds] | '*' ','
//     lambda_param_maybe_default+ [lambda_kwds] | lambda_kwds
static void * _lambda_star_etc_parse(RuleDescr *);
StarEtc* _lambda_star_etc_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_star_etc", "invalid_lambda_star_etc | '*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds] | '*' ',' lambda_param_maybe_default+ [lambda_kwds] | lambda_kwds"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_star_etc_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_lambda_star_etc
    static void * _item_invalid_lambda_star_etc_var();
    void * _alt_1(void) {  // invalid_lambda_star_etc
        // invalid_lambda_star_etc
        void * invalid_lambda_star_etc_var;
        if (!(invalid_lambda_star_etc_var = _item_invalid_lambda_star_etc_var())) return NULL;
        // parse succeeded.
        return invalid_lambda_star_etc_var;
    }
    }
    static Token * _item__literal_var();
    static arg_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_2(void) {  // '*' lambda_param_no_default
    //     lambda_param_maybe_default* [lambda_kwds]
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // lambda_param_maybe_default*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [lambda_kwds]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_star_etc (p , a , b , c);
    }
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_c();
    void * _alt_3(void) {  // '*' ',' lambda_param_maybe_default+ [lambda_kwds]
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // lambda_param_maybe_default+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // [lambda_kwds]
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // parse succeeded.
        return _PyPegen_star_etc (p , NULL , b , c);
    }
    static arg_ty _item_a();
    void * _alt_4(void) {  // lambda_kwds
        // lambda_kwds
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_star_etc (p , NULL , NULL , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_lambda_star_etc"},
        {_alt_2, "_alt_2", "'*' lambda_param_no_default lambda_param_maybe_default* [lambda_kwds]"},
        {_alt_3, "_alt_3", "'*' ',' lambda_param_maybe_default+ [lambda_kwds]"},
        {_alt_4, "_alt_4", "lambda_kwds"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_lambda_star_etc_var(void) {
    return _invalid_lambda_star_etc_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
arg_ty _item_a(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arg_ty _item_lambda_kwds_var();
    void * _alt(void) {  // lambda_kwds
        // lambda_kwds
        arg_ty lambda_kwds_var;
        if (!(lambda_kwds_var = _item_lambda_kwds_var())) return NULL;
        // parse succeeded.
        return lambda_kwds_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_kwds"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arg_ty _item_lambda_kwds_var(void) {
    return _lambda_kwds_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arg_ty _item_lambda_kwds_var();
    void * _alt(void) {  // lambda_kwds
        // lambda_kwds
        arg_ty lambda_kwds_var;
        if (!(lambda_kwds_var = _item_lambda_kwds_var())) return NULL;
        // parse succeeded.
        return lambda_kwds_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "lambda_kwds"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arg_ty _item_lambda_kwds_var(void) {
    return _lambda_kwds_rule(p);
}
arg_ty _item_a(void) {
    return _lambda_kwds_rule(p);
}

// lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default
static void * _lambda_kwds_parse(RuleDescr *);
arg_ty _lambda_kwds_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_kwds", "invalid_lambda_kwds | '**' lambda_param_no_default"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_kwds_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_lambda_kwds
    static void * _item_invalid_lambda_kwds_var();
    void * _alt_1(void) {  // invalid_lambda_kwds
        // invalid_lambda_kwds
        void * invalid_lambda_kwds_var;
        if (!(invalid_lambda_kwds_var = _item_invalid_lambda_kwds_var())) return NULL;
        // parse succeeded.
        return invalid_lambda_kwds_var;
    }
    }
    static Token * _item__literal_var();
    static arg_ty _item_a();
    void * _alt_2(void) {  // '**' lambda_param_no_default
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_lambda_kwds"},
        {_alt_2, "_alt_2", "'**' lambda_param_no_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_lambda_kwds_var(void) {
    return _invalid_lambda_kwds_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_a(void) {
    return _lambda_param_no_default_rule(p);
}

// lambda_param_no_default: lambda_param ',' | lambda_param &':'
static void * _lambda_param_no_default_parse(RuleDescr *);
arg_ty _lambda_param_no_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_param_no_default", "lambda_param ',' | lambda_param &':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_param_no_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_1(void) {  // lambda_param ','
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return a;
    }
    static arg_ty _item_a();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // lambda_param &':'
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // &':'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param ','"},
        {_alt_2, "_alt_2", "lambda_param &':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// lambda_param_with_default: lambda_param default ',' | lambda_param default
//     &':'
static void * _lambda_param_with_default_parse(RuleDescr *);
NameDefaultPair* _lambda_param_with_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_param_with_default", "lambda_param default ',' | lambda_param default &':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_param_with_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static expr_ty _item_c();
    static Token * _item__literal_var();
    void * _alt_1(void) {  // lambda_param default ','
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , NULL);
    }
    static arg_ty _item_a();
    static expr_ty _item_c();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // lambda_param default &':'
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // &':'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , NULL);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param default ','"},
        {_alt_2, "_alt_2", "lambda_param default &':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
expr_ty _item_c(void) {
    return _default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
expr_ty _item_c(void) {
    return _default_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// lambda_param_maybe_default: lambda_param default? ',' | lambda_param default?
//     &':'
static void * _lambda_param_maybe_default_parse(RuleDescr *);
NameDefaultPair* _lambda_param_maybe_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_param_maybe_default", "lambda_param default? ',' | lambda_param default? &':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_param_maybe_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static arg_ty _item_a();
    static ParseResult[Any] _item_c();
    static Token * _item__literal_var();
    void * _alt_1(void) {  // lambda_param default? ','
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default?
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , NULL);
    }
    static arg_ty _item_a();
    static ParseResult[Any] _item_c();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // lambda_param default? &':'
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // default?
        ParseResult[Any] c;
        if ((c = (ParseResult[Any]) _item_c()), p->error_indicator) return NULL;
        c = _item_c();
        // &':'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_name_default_pair (p , a , c , NULL);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param default? ','"},
        {_alt_2, "_alt_2", "lambda_param default? &':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
ParseResult[Any] _item_c(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _default_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// lambda_param: NAME
static void * _lambda_param_parse(RuleDescr *);
arg_ty _lambda_param_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "lambda_param", "NAME"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _lambda_param_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    void * _alt(void) {  // NAME
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_arg (a -> v . Name . id , NULL , NULL , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}

// strings: STRING+
static void * _strings_parse(RuleDescr *);
expr_ty _strings_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "strings", "STRING+"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, strings_type);
}
void * _strings_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // STRING+
        // STRING+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_concatenate_strings (p , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "STRING+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_string_token(p);
}

// list: '[' [star_named_expressions] ']'
static void * _list_parse(RuleDescr *);
expr_ty _list_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "list", "'[' [star_named_expressions] ']'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _list_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '[' [star_named_expressions] ']'
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [star_named_expressions]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_List (a , Load , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'[' [star_named_expressions] ']'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_star_named_expressions_var();
    void * _alt(void) {  // star_named_expressions
        // star_named_expressions
        asdl_expr_seq* star_named_expressions_var;
        if (!(star_named_expressions_var = _item_star_named_expressions_var())) return NULL;
        // parse succeeded.
        return star_named_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_named_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_star_named_expressions_var(void) {
    return _star_named_expressions_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}

// tuple: '(' [star_named_expression ',' [star_named_expressions]] ')'
static void * _tuple_parse(RuleDescr *);
expr_ty _tuple_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "tuple", "'(' [star_named_expression ',' [star_named_expressions]] ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _tuple_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '(' [star_named_expression ','
    //     [star_named_expressions]] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [star_named_expression ',' [star_named_expressions]]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (a , Load , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' [star_named_expression ',' [star_named_expressions]] ')'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_y();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_z();
    void * _alt(void) {  // star_named_expression ',' [star_named_expressions]
        // star_named_expression
        expr_ty y;
        if (!(y = _item_y())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [star_named_expressions]
        ParseResult[Any] z;
        if ((z = (ParseResult[Any]) _item_z()), p->error_indicator) return NULL;
        z = _item_z();
        // parse succeeded.
        return _PyPegen_seq_insert_in_front (p , y , z);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_named_expression ',' [star_named_expressions]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_y(void) {
    return _star_named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_z(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_star_named_expressions_var();
    void * _alt(void) {  // star_named_expressions
        // star_named_expressions
        asdl_expr_seq* star_named_expressions_var;
        if (!(star_named_expressions_var = _item_star_named_expressions_var())) return NULL;
        // parse succeeded.
        return star_named_expressions_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_named_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_star_named_expressions_var(void) {
    return _star_named_expressions_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// set: '{' star_named_expressions '}'
static void * _set_parse(RuleDescr *);
expr_ty _set_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "set", "'{' star_named_expressions '}'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _set_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static asdl_expr_seq* _item_a();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '{' star_named_expressions '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_named_expressions
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Set (a , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'{' star_named_expressions '}'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
asdl_expr_seq* _item_a(void) {
    return _star_named_expressions_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}

// dict: '{' [double_starred_kvpairs] '}' | '{' invalid_double_starred_kvpairs
//     '}'
static void * _dict_parse(RuleDescr *);
expr_ty _dict_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "dict", "'{' [double_starred_kvpairs] '}' | '{' invalid_double_starred_kvpairs '}'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _dict_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '{' [double_starred_kvpairs] '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [double_starred_kvpairs]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Dict (CHECK (asdl_expr_seq* , _PyPegen_get_keys (p , a)) , CHECK (asdl_expr_seq* , _PyPegen_get_values (p , a)) , EXTRA);
    }
    static Token * _item__literal_var();
    static void * _item_invalid_double_starred_kvpairs_var();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '{' invalid_double_starred_kvpairs '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // invalid_double_starred_kvpairs
        void * invalid_double_starred_kvpairs_var;
        if (!(invalid_double_starred_kvpairs_var = _item_invalid_double_starred_kvpairs_var())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, invalid_double_starred_kvpairs_var, _literal_var_1);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'{' [double_starred_kvpairs] '}'"},
        {_alt_2, "_alt_2", "'{' invalid_double_starred_kvpairs '}'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_seq* _item_double_starred_kvpairs_var();
    void * _alt(void) {  // double_starred_kvpairs
        // double_starred_kvpairs
        asdl_seq* double_starred_kvpairs_var;
        if (!(double_starred_kvpairs_var = _item_double_starred_kvpairs_var())) return NULL;
        // parse succeeded.
        return double_starred_kvpairs_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "double_starred_kvpairs"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq* _item_double_starred_kvpairs_var(void) {
    return _double_starred_kvpairs_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
void * _item_invalid_double_starred_kvpairs_var(void) {
    return _invalid_double_starred_kvpairs_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}

// double_starred_kvpairs: ','.double_starred_kvpair+ [',']
static void * _double_starred_kvpairs_parse(RuleDescr *);
asdl_seq* _double_starred_kvpairs_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "double_starred_kvpairs", "','.double_starred_kvpair+ [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _double_starred_kvpairs_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // ','.double_starred_kvpair+ [',']
        // ','.double_starred_kvpair+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.double_starred_kvpair+ [',']"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeyValuePair* _node(void) {
    return _double_starred_kvpair_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// double_starred_kvpair: '**' bitwise_or | kvpair
static void * _double_starred_kvpair_parse(RuleDescr *);
KeyValuePair* _double_starred_kvpair_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "double_starred_kvpair", "'**' bitwise_or | kvpair"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _double_starred_kvpair_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // '**' bitwise_or
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_key_value_pair (p , NULL , a);
    }
    static KeyValuePair* _item_kvpair_var();
    void * _alt_2(void) {  // kvpair
        // kvpair
        KeyValuePair* kvpair_var;
        if (!(kvpair_var = _item_kvpair_var())) return NULL;
        // parse succeeded.
        return kvpair_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'**' bitwise_or"},
        {_alt_2, "_alt_2", "kvpair"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
KeyValuePair* _item_kvpair_var(void) {
    return _kvpair_rule(p);
}

// kvpair: expression ':' expression
static void * _kvpair_parse(RuleDescr *);
KeyValuePair* _kvpair_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "kvpair", "expression ':' expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _kvpair_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt(void) {  // expression ':' expression
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_key_value_pair (p , a , b);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression ':' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}

// for_if_clauses: for_if_clause+
static void * _for_if_clauses_parse(RuleDescr *);
asdl_comprehension_seq* _for_if_clauses_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "for_if_clauses", "for_if_clause+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _for_if_clauses_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    void * _alt(void) {  // for_if_clause+
        // for_if_clause+
        asdl_comprehension_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "for_if_clause+"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
comprehension_ty _node(void) {
    return _for_if_clause_rule(p);
}

// for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if'
//     disjunction))* | 'for' star_targets 'in' ~ disjunction (('if'
//     disjunction))* | invalid_for_target
static void * _for_if_clause_parse(RuleDescr *);
comprehension_ty _for_if_clause_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "for_if_clause", "ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _for_if_clause_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__async_var();
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__keyword_var_1();
    static expr_ty _item_b();
    static asdl_seq * _item_c();
    void * _alt_1(void) {  // ASYNC 'for' star_targets 'in' ~ disjunction (('if'
    //     disjunction))*
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_targets
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // ~
        // disjunction
        expr_ty b;
        if (!(b = _item_b())) return _PyPegen_cut_sentinel;
        // (('if' disjunction))*
        asdl_expr_seq* c;
        if ((c = (asdl_expr_seq*) _item_c()), p->error_indicator) return _PyPegen_cut_sentinel;
        c = _item_c();
        // parse succeeded.
        return CHECK_VERSION (comprehension_ty , 6 , "Async comprehensions are" , _PyAST_comprehension (a , b , c , 1 , p -> arena));
    }
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static Token * _item__keyword_var_1();
    static expr_ty _item_b();
    static asdl_seq * _item_c();
    void * _alt_2(void) {  // 'for' star_targets 'in' ~ disjunction (('if'
    //     disjunction))*
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_targets
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // ~
        // disjunction
        expr_ty b;
        if (!(b = _item_b())) return _PyPegen_cut_sentinel;
        // (('if' disjunction))*
        asdl_expr_seq* c;
        if ((c = (asdl_expr_seq*) _item_c()), p->error_indicator) return _PyPegen_cut_sentinel;
        c = _item_c();
        // parse succeeded.
        return _PyAST_comprehension (a , b , c , 0 , p -> arena);
    }
    if (p->call_invalid_rules) {   // invalid_for_target
    static void * _item_invalid_for_target_var();
    void * _alt_3(void) {  // invalid_for_target
        // invalid_for_target
        void * invalid_for_target_var;
        if (!(invalid_for_target_var = _item_invalid_for_target_var())) return NULL;
        // parse succeeded.
        return invalid_for_target_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"},
        {_alt_2, "_alt_2", "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"},
        {_alt_3, "_alt_3", "invalid_for_target"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_a(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_b(void) {
    return _disjunction_rule(p);
}
asdl_seq * _item_c(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'if' disjunction
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // disjunction
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'if' disjunction"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_z(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_a(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_b(void) {
    return _disjunction_rule(p);
}
asdl_seq * _item_c(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_z();
    void * _alt(void) {  // 'if' disjunction
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // disjunction
        expr_ty z;
        if (!(z = _item_z())) return NULL;
        // parse succeeded.
        return z;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'if' disjunction"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_z(void) {
    return _disjunction_rule(p);
}
void * _item_invalid_for_target_var(void) {
    return _invalid_for_target_rule(p);
}

// listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
static void * _listcomp_parse(RuleDescr *);
expr_ty _listcomp_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "listcomp", "'[' named_expression for_if_clauses ']' | invalid_comprehension"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _listcomp_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_b();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '[' named_expression for_if_clauses ']'
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_ListComp (a , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_comprehension
    static void * _item_invalid_comprehension_var();
    void * _alt_2(void) {  // invalid_comprehension
        // invalid_comprehension
        void * invalid_comprehension_var;
        if (!(invalid_comprehension_var = _item_invalid_comprehension_var())) return NULL;
        // parse succeeded.
        return invalid_comprehension_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'[' named_expression for_if_clauses ']'"},
        {_alt_2, "_alt_2", "invalid_comprehension"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
void * _item_invalid_comprehension_var(void) {
    return _invalid_comprehension_rule(p);
}

// setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension
static void * _setcomp_parse(RuleDescr *);
expr_ty _setcomp_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "setcomp", "'{' named_expression for_if_clauses '}' | invalid_comprehension"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _setcomp_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_b();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '{' named_expression for_if_clauses '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_SetComp (a , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_comprehension
    static void * _item_invalid_comprehension_var();
    void * _alt_2(void) {  // invalid_comprehension
        // invalid_comprehension
        void * invalid_comprehension_var;
        if (!(invalid_comprehension_var = _item_invalid_comprehension_var())) return NULL;
        // parse succeeded.
        return invalid_comprehension_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'{' named_expression for_if_clauses '}'"},
        {_alt_2, "_alt_2", "invalid_comprehension"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
expr_ty _item_a(void) {
    return _named_expression_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
void * _item_invalid_comprehension_var(void) {
    return _invalid_comprehension_rule(p);
}

// genexp: '(' (assignment_expression | expression !':=') for_if_clauses ')' |
//     invalid_comprehension
static void * _genexp_parse(RuleDescr *);
expr_ty _genexp_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "genexp", "'(' (assignment_expression | expression !':=') for_if_clauses ')' | invalid_comprehension"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _genexp_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static void * _item_a();
    static asdl_comprehension_seq* _item_b();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '(' (assignment_expression | expression !':=')
    //     for_if_clauses ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (assignment_expression | expression !':=')
        void * a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_GeneratorExp (a , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_comprehension
    static void * _item_invalid_comprehension_var();
    void * _alt_2(void) {  // invalid_comprehension
        // invalid_comprehension
        void * invalid_comprehension_var;
        if (!(invalid_comprehension_var = _item_invalid_comprehension_var())) return NULL;
        // parse succeeded.
        return invalid_comprehension_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'(' (assignment_expression | expression !':=') for_if_clauses ')'"},
        {_alt_2, "_alt_2", "invalid_comprehension"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_assignment_expression_var();
    void * _alt_1(void) {  // assignment_expression
        // assignment_expression
        expr_ty assignment_expression_var;
        if (!(assignment_expression_var = _item_assignment_expression_var())) return NULL;
        // parse succeeded.
        return assignment_expression_var;
    }
    static expr_ty _item_expression_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // expression !':='
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // !':='
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, _lookahead_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "assignment_expression"},
        {_alt_2, "_alt_2", "expression !':='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_assignment_expression_var(void) {
    return _assignment_expression_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
void * _item_invalid_comprehension_var(void) {
    return _invalid_comprehension_rule(p);
}

// dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
static void * _dictcomp_parse(RuleDescr *);
expr_ty _dictcomp_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "dictcomp", "'{' kvpair for_if_clauses '}' | invalid_dict_comprehension"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _dictcomp_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static KeyValuePair* _item_a();
    static asdl_comprehension_seq* _item_b();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '{' kvpair for_if_clauses '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // kvpair
        KeyValuePair* a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_DictComp (a -> key , a -> value , b , EXTRA);
    }
    if (p->call_invalid_rules) {   // invalid_dict_comprehension
    static void * _item_invalid_dict_comprehension_var();
    void * _alt_2(void) {  // invalid_dict_comprehension
        // invalid_dict_comprehension
        void * invalid_dict_comprehension_var;
        if (!(invalid_dict_comprehension_var = _item_invalid_dict_comprehension_var())) return NULL;
        // parse succeeded.
        return invalid_dict_comprehension_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'{' kvpair for_if_clauses '}'"},
        {_alt_2, "_alt_2", "invalid_dict_comprehension"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
KeyValuePair* _item_a(void) {
    return _kvpair_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
void * _item_invalid_dict_comprehension_var(void) {
    return _invalid_dict_comprehension_rule(p);
}

// arguments: args [','] &')' | invalid_arguments
static void * _arguments_parse(RuleDescr *);
expr_ty _arguments_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "arguments", "args [','] &')' | invalid_arguments"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, arguments_type);
}
void * _arguments_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static ParseResult[Any] _item_opt_var();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // args [','] &')'
        // args
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // &')'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    if (p->call_invalid_rules) {   // invalid_arguments
    static void * _item_invalid_arguments_var();
    void * _alt_2(void) {  // invalid_arguments
        // invalid_arguments
        void * invalid_arguments_var;
        if (!(invalid_arguments_var = _item_invalid_arguments_var())) return NULL;
        // parse succeeded.
        return invalid_arguments_var;
    }
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "args [','] &')'"},
        {_alt_2, "_alt_2", "invalid_arguments"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _args_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
void * _item_invalid_arguments_var(void) {
    return _invalid_arguments_rule(p);
}

// args: ','.(starred_expression | (assignment_expression | expression !':=')
//     !'=')+ [',' kwargs] | kwargs
static void * _args_parse(RuleDescr *);
expr_ty _args_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "args", "','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs] | kwargs"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _args_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_b();
    void * _alt_1(void) {  // ','.(starred_expression | (assignment_expression |
    //     expression !':=') !'=')+ [',' kwargs]
        // ','.(starred_expression | (assignment_expression | expression !':=')
        //     !'=')+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',' kwargs]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyPegen_collect_call_seqs (p , a , b , EXTRA);
    }
    static asdl_seq* _item_a();
    void * _alt_2(void) {  // kwargs
        // kwargs
        asdl_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Call (_PyPegen_dummy_name (p) , CHECK_NULL_ALLOWED (asdl_expr_seq* , _PyPegen_seq_extract_starred_exprs (p , a)) , CHECK_NULL_ALLOWED (asdl_keyword_seq* , _PyPegen_seq_delete_starred_exprs (p , a)) , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]"},
        {_alt_2, "_alt_2", "kwargs"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_starred_expression_var();
    void * _alt_1(void) {  // starred_expression
        // starred_expression
        expr_ty starred_expression_var;
        if (!(starred_expression_var = _item_starred_expression_var())) return NULL;
        // parse succeeded.
        return starred_expression_var;
    }
    static void * _item__group_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // (assignment_expression | expression !':=') !'='
        // (assignment_expression | expression !':=')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // !'='
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _group_var, _lookahead_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "starred_expression"},
        {_alt_2, "_alt_2", "(assignment_expression | expression !':=') !'='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_starred_expression_var(void) {
    return _starred_expression_rule(p);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_assignment_expression_var();
    void * _alt_1(void) {  // assignment_expression
        // assignment_expression
        expr_ty assignment_expression_var;
        if (!(assignment_expression_var = _item_assignment_expression_var())) return NULL;
        // parse succeeded.
        return assignment_expression_var;
    }
    static expr_ty _item_expression_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // expression !':='
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // !':='
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, _lookahead_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "assignment_expression"},
        {_alt_2, "_alt_2", "expression !':='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_assignment_expression_var(void) {
    return _assignment_expression_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static asdl_seq* _item_k();
    void * _alt(void) {  // ',' kwargs
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // kwargs
        asdl_seq* k;
        if (!(k = _item_k())) return NULL;
        // parse succeeded.
        return k;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' kwargs"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq* _item_k(void) {
    return _kwargs_rule(p);
}
asdl_seq* _item_a(void) {
    return _kwargs_rule(p);
}

// kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ |
//     ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
static void * _kwargs_parse(RuleDescr *);
asdl_seq* _kwargs_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "kwargs", "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _kwargs_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static asdl_seq * _item_b();
    void * _alt_1(void) {  // ','.kwarg_or_starred+ ','
    //     ','.kwarg_or_double_starred+
        // ','.kwarg_or_starred+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','.kwarg_or_double_starred+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_join_sequences (p , a , b);
    }
    static asdl_seq * _item__loop_var();
    void * _alt_2(void) {  // ','.kwarg_or_starred+
        // ','.kwarg_or_starred+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    static asdl_seq * _item__loop_var();
    void * _alt_3(void) {  // ','.kwarg_or_double_starred+
        // ','.kwarg_or_double_starred+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"},
        {_alt_2, "_alt_2", "','.kwarg_or_starred+"},
        {_alt_3, "_alt_3", "','.kwarg_or_double_starred+"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeywordOrStarred* _node(void) {
    return _kwarg_or_starred_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeywordOrStarred* _node(void) {
    return _kwarg_or_double_starred_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeywordOrStarred* _node(void) {
    return _kwarg_or_starred_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeywordOrStarred* _node(void) {
    return _kwarg_or_double_starred_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// starred_expression: '*' expression
static void * _starred_expression_parse(RuleDescr *);
expr_ty _starred_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "starred_expression", "'*' expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _starred_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt(void) {  // '*' expression
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Starred (a , Load , EXTRA);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'*' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}

// kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression
static void * _kwarg_or_starred_parse(RuleDescr *);
KeywordOrStarred* _kwarg_or_starred_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "kwarg_or_starred", "invalid_kwarg | NAME '=' expression | starred_expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _kwarg_or_starred_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_kwarg
    static void * _item_invalid_kwarg_var();
    void * _alt_1(void) {  // invalid_kwarg
        // invalid_kwarg
        void * invalid_kwarg_var;
        if (!(invalid_kwarg_var = _item_invalid_kwarg_var())) return NULL;
        // parse succeeded.
        return invalid_kwarg_var;
    }
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_2(void) {  // NAME '=' expression
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyPegen_keyword_or_starred (p , CHECK (keyword_ty , _PyAST_keyword (a -> v . Name . id , b , EXTRA)) , 1);
    }
    static expr_ty _item_a();
    void * _alt_3(void) {  // starred_expression
        // starred_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_keyword_or_starred (p , a , 0);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_kwarg"},
        {_alt_2, "_alt_2", "NAME '=' expression"},
        {_alt_3, "_alt_3", "starred_expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_kwarg_var(void) {
    return _invalid_kwarg_rule(p);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
expr_ty _item_a(void) {
    return _starred_expression_rule(p);
}

// kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**'
//     expression
static void * _kwarg_or_double_starred_parse(RuleDescr *);
KeywordOrStarred* _kwarg_or_double_starred_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "kwarg_or_double_starred", "invalid_kwarg | NAME '=' expression | '**' expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _kwarg_or_double_starred_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    if (p->call_invalid_rules) {   // invalid_kwarg
    static void * _item_invalid_kwarg_var();
    void * _alt_1(void) {  // invalid_kwarg
        // invalid_kwarg
        void * invalid_kwarg_var;
        if (!(invalid_kwarg_var = _item_invalid_kwarg_var())) return NULL;
        // parse succeeded.
        return invalid_kwarg_var;
    }
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    void * _alt_2(void) {  // NAME '=' expression
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyPegen_keyword_or_starred (p , CHECK (keyword_ty , _PyAST_keyword (a -> v . Name . id , b , EXTRA)) , 1);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_3(void) {  // '**' expression
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyPegen_keyword_or_starred (p , CHECK (keyword_ty , _PyAST_keyword (NULL , a , EXTRA)) , 1);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_kwarg"},
        {_alt_2, "_alt_2", "NAME '=' expression"},
        {_alt_3, "_alt_3", "'**' expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_invalid_kwarg_var(void) {
    return _invalid_kwarg_rule(p);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}

// star_targets: star_target !',' | star_target ((',' star_target))* [',']
static void * _star_targets_parse(RuleDescr *);
expr_ty _star_targets_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_targets", "star_target !',' | star_target ((',' star_target))* [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_targets_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // star_target !','
        // star_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // !','
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_opt_var();
    void * _alt_2(void) {  // star_target ((',' star_target))* [',']
        // star_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ((',' star_target))*
        asdl_seq * b;
        if ((b = (asdl_seq *) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (CHECK (asdl_expr_seq* , _PyPegen_seq_insert_in_front (p , a , b)) , Store , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "star_target !','"},
        {_alt_2, "_alt_2", "star_target ((',' star_target))* [',']"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _star_target_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_a(void) {
    return _star_target_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_c();
    void * _alt(void) {  // ',' star_target
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_target
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_c(void) {
    return _star_target_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// star_targets_list_seq: ','.star_target+ [',']
static void * _star_targets_list_seq_parse(RuleDescr *);
asdl_expr_seq* _star_targets_list_seq_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_targets_list_seq", "','.star_target+ [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_targets_list_seq_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // ','.star_target+ [',']
        // ','.star_target+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.star_target+ [',']"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _star_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// star_targets_tuple_seq: star_target ((',' star_target))+ [','] | star_target
//     ','
static void * _star_targets_tuple_seq_parse(RuleDescr *);
asdl_expr_seq* _star_targets_tuple_seq_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_targets_tuple_seq", "star_target ((',' star_target))+ [','] | star_target ','"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_targets_tuple_seq_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static asdl_seq * _item_b();
    static ParseResult[Any] _item_opt_var();
    void * _alt_1(void) {  // star_target ((',' star_target))+ [',']
        // star_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ((',' star_target))+
        asdl_seq * b;
        if (!(b = _item_b())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_seq_insert_in_front (p , a , b);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_2(void) {  // star_target ','
        // star_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_singleton_seq (p , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "star_target ((',' star_target))+ [',']"},
        {_alt_2, "_alt_2", "star_target ','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _star_target_rule(p);
}
asdl_seq * _item_b(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_c();
    void * _alt(void) {  // ',' star_target
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_target
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return c;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "',' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_c(void) {
    return _star_target_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_a(void) {
    return _star_target_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// star_target: '*' (!'*' star_target) | target_with_star_atom
static void * _star_target_parse(RuleDescr *);
expr_ty _star_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_target", "'*' (!'*' star_target) | target_with_star_atom"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, star_target_type);
}
void * _star_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static void * _item_a();
    void * _alt_1(void) {  // '*' (!'*' star_target)
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (!'*' star_target)
        void * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Starred (CHECK (expr_ty , _PyPegen_set_expr_context (p , a , Store)) , Store , EXTRA);
    }
    static expr_ty _item_target_with_star_atom_var();
    void * _alt_2(void) {  // target_with_star_atom
        // target_with_star_atom
        expr_ty target_with_star_atom_var;
        if (!(target_with_star_atom_var = _item_target_with_star_atom_var())) return NULL;
        // parse succeeded.
        return target_with_star_atom_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' (!'*' star_target)"},
        {_alt_2, "_alt_2", "target_with_star_atom"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static int _item__lookahead_var();
    static expr_ty _item_star_target_var();
    void * _alt(void) {  // !'*' star_target
        // !'*'
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // star_target
        expr_ty star_target_var;
        if (!(star_target_var = _item_star_target_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _lookahead_var, star_target_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "!'*' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_star_target_var(void) {
    return _star_target_rule(p);
}
expr_ty _item_target_with_star_atom_var(void) {
    return _target_with_star_atom_rule(p);
}

// target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices
//     ']' !t_lookahead | star_atom
static void * _target_with_star_atom_parse(RuleDescr *);
expr_ty _target_with_star_atom_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "target_with_star_atom", "t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, target_with_star_atom_type);
}
void * _target_with_star_atom_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // t_primary '.' NAME !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (a , b -> v . Name . id , Store , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // t_primary '[' slices ']' !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // slices
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Subscript (a , b , Store , EXTRA);
    }
    static expr_ty _item_star_atom_var();
    void * _alt_3(void) {  // star_atom
        // star_atom
        expr_ty star_atom_var;
        if (!(star_atom_var = _item_star_atom_var())) return NULL;
        // parse succeeded.
        return star_atom_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "t_primary '.' NAME !t_lookahead"},
        {_alt_2, "_alt_2", "t_primary '[' slices ']' !t_lookahead"},
        {_alt_3, "_alt_3", "star_atom"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_b(void) {
    return _slices_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_star_atom_var(void) {
    return _star_atom_rule(p);
}

// star_atom: NAME | '(' target_with_star_atom ')' | '('
//     [star_targets_tuple_seq] ')' | '[' [star_targets_list_seq] ']'
static void * _star_atom_parse(RuleDescr *);
expr_ty _star_atom_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "star_atom", "NAME | '(' target_with_star_atom ')' | '(' [star_targets_tuple_seq] ')' | '[' [star_targets_list_seq] ']'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _star_atom_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    void * _alt_1(void) {  // NAME
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , a , Store);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '(' target_with_star_atom ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // target_with_star_atom
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , a , Store);
    }
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // '(' [star_targets_tuple_seq] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [star_targets_tuple_seq]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (a , Store , EXTRA);
    }
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt_4(void) {  // '[' [star_targets_list_seq] ']'
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [star_targets_list_seq]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_List (a , Store , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NAME"},
        {_alt_2, "_alt_2", "'(' target_with_star_atom ')'"},
        {_alt_3, "_alt_3", "'(' [star_targets_tuple_seq] ')'"},
        {_alt_4, "_alt_4", "'[' [star_targets_list_seq] ']'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_a(void) {
    return _target_with_star_atom_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_star_targets_tuple_seq_var();
    void * _alt(void) {  // star_targets_tuple_seq
        // star_targets_tuple_seq
        asdl_expr_seq* star_targets_tuple_seq_var;
        if (!(star_targets_tuple_seq_var = _item_star_targets_tuple_seq_var())) return NULL;
        // parse succeeded.
        return star_targets_tuple_seq_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_targets_tuple_seq"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_star_targets_tuple_seq_var(void) {
    return _star_targets_tuple_seq_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_star_targets_list_seq_var();
    void * _alt(void) {  // star_targets_list_seq
        // star_targets_list_seq
        asdl_expr_seq* star_targets_list_seq_var;
        if (!(star_targets_list_seq_var = _item_star_targets_list_seq_var())) return NULL;
        // parse succeeded.
        return star_targets_list_seq_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_targets_list_seq"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_star_targets_list_seq_var(void) {
    return _star_targets_list_seq_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}

// single_target: single_subscript_attribute_target | NAME | '(' single_target
//     ')'
static void * _single_target_parse(RuleDescr *);
expr_ty _single_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "single_target", "single_subscript_attribute_target | NAME | '(' single_target ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _single_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_single_subscript_attribute_target_var();
    void * _alt_1(void) {  // single_subscript_attribute_target
        // single_subscript_attribute_target
        expr_ty single_subscript_attribute_target_var;
        if (!(single_subscript_attribute_target_var = _item_single_subscript_attribute_target_var())) return NULL;
        // parse succeeded.
        return single_subscript_attribute_target_var;
    }
    static expr_ty _item_a();
    void * _alt_2(void) {  // NAME
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , a , Store);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // '(' single_target ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // single_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "single_subscript_attribute_target"},
        {_alt_2, "_alt_2", "NAME"},
        {_alt_3, "_alt_3", "'(' single_target ')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_single_subscript_attribute_target_var(void) {
    return _single_subscript_attribute_target_rule(p);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_a(void) {
    return _single_target_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// single_subscript_attribute_target: t_primary '.' NAME !t_lookahead |
//     t_primary '[' slices ']' !t_lookahead
static void * _single_subscript_attribute_target_parse(RuleDescr *);
expr_ty _single_subscript_attribute_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "single_subscript_attribute_target", "t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _single_subscript_attribute_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // t_primary '.' NAME !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (a , b -> v . Name . id , Store , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // t_primary '[' slices ']' !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // slices
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Subscript (a , b , Store , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "t_primary '.' NAME !t_lookahead"},
        {_alt_2, "_alt_2", "t_primary '[' slices ']' !t_lookahead"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_b(void) {
    return _slices_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}

// Left-recursive leader
// t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']'
//     &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' [arguments]
//     ')' &t_lookahead | atom &t_lookahead
static void * _t_primary_parse(RuleDescr *);
expr_ty _t_primary_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "t_primary", "t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' [arguments] ')' &t_lookahead | atom &t_lookahead"};
    return _PyPegen_parse_recursive_rule(p, &_rule_descriptor);
}
void * _t_primary_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // t_primary '.' NAME &t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // &t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (a , b -> v . Name . id , Load , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // t_primary '[' slices ']' &t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // slices
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // &t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Subscript (a , b , Load , EXTRA);
    }
    static expr_ty _item_a();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_3(void) {  // t_primary genexp &t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // genexp
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // &t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Call (a , CHECK (asdl_expr_seq* , (asdl_expr_seq*) _PyPegen_singleton_seq (p , b)) , NULL , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_b();
    static Token * _item__literal_var_1();
    static int _item__lookahead_var();
    void * _alt_4(void) {  // t_primary '(' [arguments] ')' &t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [arguments]
        ParseResult[Any] b;
        if ((b = (ParseResult[Any]) _item_b()), p->error_indicator) return NULL;
        b = _item_b();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // &t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Call (a , (b) ? ((expr_ty) b) -> v . Call . args : NULL , (b) ? ((expr_ty) b) -> v . Call . keywords : NULL , EXTRA);
    }
    static expr_ty _item_a();
    static int _item__lookahead_var();
    void * _alt_5(void) {  // atom &t_lookahead
        // atom
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // &t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "t_primary '.' NAME &t_lookahead"},
        {_alt_2, "_alt_2", "t_primary '[' slices ']' &t_lookahead"},
        {_alt_3, "_alt_3", "t_primary genexp &t_lookahead"},
        {_alt_4, "_alt_4", "t_primary '(' [arguments] ')' &t_lookahead"},
        {_alt_5, "_alt_5", "atom &t_lookahead"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_b(void) {
    return _slices_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
expr_ty _item_b(void) {
    return _genexp_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_b(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_arguments_var();
    void * _alt(void) {  // arguments
        // arguments
        expr_ty arguments_var;
        if (!(arguments_var = _item_arguments_var())) return NULL;
        // parse succeeded.
        return arguments_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "arguments"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arguments_var(void) {
    return _arguments_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _atom_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}

// t_lookahead: '(' | '[' | '.'
static void * _t_lookahead_parse(RuleDescr *);
void * _t_lookahead_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "t_lookahead", "'(' | '[' | '.'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _t_lookahead_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '('
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '['
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '.'
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'('"},
        {_alt_2, "_alt_2", "'['"},
        {_alt_3, "_alt_3", "'.'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}

// del_targets: ','.del_target+ [',']
static void * _del_targets_parse(RuleDescr *);
asdl_expr_seq* _del_targets_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "del_targets", "','.del_target+ [',']"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _del_targets_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // ','.del_target+ [',']
        // ','.del_target+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // [',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','.del_target+ [',']"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _del_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']'
//     !t_lookahead | del_t_atom
static void * _del_target_parse(RuleDescr *);
expr_ty _del_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "del_target", "t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, del_target_type);
}
void * _del_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // t_primary '.' NAME !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '.'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NAME
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Attribute (a , b -> v . Name . id , Del , EXTRA);
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static Token * _item__literal_var_1();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // t_primary '[' slices ']' !t_lookahead
        // t_primary
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // slices
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // !t_lookahead
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Subscript (a , b , Del , EXTRA);
    }
    static expr_ty _item_del_t_atom_var();
    void * _alt_3(void) {  // del_t_atom
        // del_t_atom
        expr_ty del_t_atom_var;
        if (!(del_t_atom_var = _item_del_t_atom_var())) return NULL;
        // parse succeeded.
        return del_t_atom_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "t_primary '.' NAME !t_lookahead"},
        {_alt_2, "_alt_2", "t_primary '[' slices ']' !t_lookahead"},
        {_alt_3, "_alt_3", "del_t_atom"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 23);   // token=.
}
expr_ty _item_b(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_a(void) {
    return _t_primary_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
expr_ty _item_b(void) {
    return _slices_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _t_lookahead_rule(p);
}
expr_ty _item_del_t_atom_var(void) {
    return _del_t_atom_rule(p);
}

// del_t_atom: NAME | '(' del_target ')' | '(' [del_targets] ')' | '['
//     [del_targets] ']'
static void * _del_t_atom_parse(RuleDescr *);
expr_ty _del_t_atom_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "del_t_atom", "NAME | '(' del_target ')' | '(' [del_targets] ')' | '[' [del_targets] ']'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _del_t_atom_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    void * _alt_1(void) {  // NAME
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , a , Del);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '(' del_target ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // del_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_set_expr_context (p , a , Del);
    }
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // '(' [del_targets] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [del_targets]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_Tuple (a , Del , EXTRA);
    }
    static Token * _item__literal_var();
    static ParseResult[Any] _item_a();
    static Token * _item__literal_var_1();
    void * _alt_4(void) {  // '[' [del_targets] ']'
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [del_targets]
        ParseResult[Any] a;
        if ((a = (ParseResult[Any]) _item_a()), p->error_indicator) return NULL;
        a = _item_a();
        // ']'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_List (a , Del , EXTRA);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NAME"},
        {_alt_2, "_alt_2", "'(' del_target ')'"},
        {_alt_3, "_alt_3", "'(' [del_targets] ')'"},
        {_alt_4, "_alt_4", "'[' [del_targets] ']'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_a(void) {
    return _del_target_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_del_targets_var();
    void * _alt(void) {  // del_targets
        // del_targets
        asdl_expr_seq* del_targets_var;
        if (!(del_targets_var = _item_del_targets_var())) return NULL;
        // parse succeeded.
        return del_targets_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "del_targets"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_del_targets_var(void) {
    return _del_targets_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
ParseResult[Any] _item_a(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_expr_seq* _item_del_targets_var();
    void * _alt(void) {  // del_targets
        // del_targets
        asdl_expr_seq* del_targets_var;
        if (!(del_targets_var = _item_del_targets_var())) return NULL;
        // parse succeeded.
        return del_targets_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "del_targets"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_expr_seq* _item_del_targets_var(void) {
    return _del_targets_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 10);   // token=]
}

// type_expressions: ','.expression+ ',' '*' expression ',' '**' expression |
//     ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression
//     | '*' expression ',' '**' expression | '*' expression | '**' expression |
//     ','.expression+
static void * _type_expressions_parse(RuleDescr *);
asdl_expr_seq* _type_expressions_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "type_expressions", "','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _type_expressions_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static expr_ty _item_b();
    static Token * _item__literal_var_2();
    static Token * _item__literal_var_3();
    static expr_ty _item_c();
    void * _alt_1(void) {  // ','.expression+ ',' '*' expression ',' '**'
    //     expression
        // ','.expression+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // ','
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // '**'
        Token * _literal_var_3;
        if (!(_literal_var_3 = _item__literal_var_3())) return NULL;
        // expression
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_seq_append_to_end (p , CHECK (asdl_seq* , _PyPegen_seq_append_to_end (p , a , b)) , c);
    }
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static expr_ty _item_b();
    void * _alt_2(void) {  // ','.expression+ ',' '*' expression
        // ','.expression+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_seq_append_to_end (p , a , b);
    }
    static asdl_seq * _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static expr_ty _item_b();
    void * _alt_3(void) {  // ','.expression+ ',' '**' expression
        // ','.expression+
        asdl_seq * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '**'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_seq_append_to_end (p , a , b);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    static Token * _item__literal_var_2();
    static expr_ty _item_b();
    void * _alt_4(void) {  // '*' expression ',' '**' expression
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // '**'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // expression
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_seq_append_to_end (p , CHECK (asdl_seq* , _PyPegen_singleton_seq (p , a)) , b);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_5(void) {  // '*' expression
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_singleton_seq (p , a);
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    void * _alt_6(void) {  // '**' expression
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return (asdl_expr_seq*) _PyPegen_singleton_seq (p , a);
    }
    static asdl_seq * _item_a();
    void * _alt_7(void) {  // ','.expression+
        // ','.expression+
        asdl_expr_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','.expression+ ',' '*' expression ',' '**' expression"},
        {_alt_2, "_alt_2", "','.expression+ ',' '*' expression"},
        {_alt_3, "_alt_3", "','.expression+ ',' '**' expression"},
        {_alt_4, "_alt_4", "'*' expression ',' '**' expression"},
        {_alt_5, "_alt_5", "'*' expression"},
        {_alt_6, "_alt_6", "'**' expression"},
        {_alt_7, "_alt_7", "','.expression+"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_3(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_c(void) {
    return _expression_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_b(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
asdl_seq * _item_a(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
expr_ty _node(void) {
    return _expression_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) |
//     invalid_double_type_comments | TYPE_COMMENT
static void * _func_type_comment_parse(RuleDescr *);
Token* _func_type_comment_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "func_type_comment", "NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _func_type_comment_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__newline_var();
    static void * _item_t();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // TYPE_COMMENT
        void * t;
        if (!(t = _item_t())) return NULL;
        // &(NEWLINE INDENT)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return t;
    }
    if (p->call_invalid_rules) {   // invalid_double_type_comments
    static void * _item_invalid_double_type_comments_var();
    void * _alt_2(void) {  // invalid_double_type_comments
        // invalid_double_type_comments
        void * invalid_double_type_comments_var;
        if (!(invalid_double_type_comments_var = _item_invalid_double_type_comments_var())) return NULL;
        // parse succeeded.
        return invalid_double_type_comments_var;
    }
    }
    static void * _item_TYPE_COMMENT_var();
    void * _alt_3(void) {  // TYPE_COMMENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return TYPE_COMMENT_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"},
        {_alt_2, "_alt_2", "invalid_double_type_comments"},
        {_alt_3, "_alt_3", "TYPE_COMMENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
void * _item_t(void) {
    return _PyPegen_type_comment_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__newline_var();
    static Token * _item__indent_var();
    void * _alt(void) {  // NEWLINE INDENT
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // INDENT
        Token * _indent_var;
        if (!(_indent_var = _item__indent_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _newline_var, _indent_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NEWLINE INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__indent_var(void) {
    return _PyPegen_expect_token(p, 5);
}
void * _item_invalid_double_type_comments_var(void) {
    return _invalid_double_type_comments_rule(p);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}

// invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args |
//     expression for_if_clauses] | NAME '=' expression for_if_clauses | args
//     for_if_clauses | args ',' expression for_if_clauses | args ',' args
static void * _invalid_arguments_parse(RuleDescr *);
void * _invalid_arguments_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_arguments", "args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | NAME '=' expression for_if_clauses | args for_if_clauses | args ',' expression for_if_clauses | args ',' args"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_arguments_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // args ',' '*'
        // args
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "iterable argument unpacking follows keyword argument unpacking");
    }
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_b();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt_2(void) {  // expression for_if_clauses ',' [args | expression
    //     for_if_clauses]
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [args | expression for_if_clauses]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , _PyPegen_get_last_comprehension_item (PyPegen_last_item (b , comprehension_ty)) , "Generator expression must be parenthesized");
    }
    static expr_ty _item_a();
    static Token * _item_b();
    static expr_ty _item_expression_var();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_3(void) {  // NAME '=' expression for_if_clauses
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * b;
        if (!(b = _item_b())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
    }
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_b();
    void * _alt_4(void) {  // args for_if_clauses
        // args
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_nonparen_genexp_in_call (p , a , b);
    }
    static expr_ty _item_args_var();
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_b();
    void * _alt_5(void) {  // args ',' expression for_if_clauses
        // args
        expr_ty args_var;
        if (!(args_var = _item_args_var())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , _PyPegen_get_last_comprehension_item (PyPegen_last_item (b , comprehension_ty)) , "Generator expression must be parenthesized");
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_args_var();
    void * _alt_6(void) {  // args ',' args
        // args
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // args
        expr_ty args_var;
        if (!(args_var = _item_args_var())) return NULL;
        // parse succeeded.
        return _PyPegen_arguments_parsing_error (p , a);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "args ',' '*'"},
        {_alt_2, "_alt_2", "expression for_if_clauses ',' [args | expression for_if_clauses]"},
        {_alt_3, "_alt_3", "NAME '=' expression for_if_clauses"},
        {_alt_4, "_alt_4", "args for_if_clauses"},
        {_alt_5, "_alt_5", "args ',' expression for_if_clauses"},
        {_alt_6, "_alt_6", "args ',' args"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _args_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_args_var();
    void * _alt_1(void) {  // args
        // args
        expr_ty args_var;
        if (!(args_var = _item_args_var())) return NULL;
        // parse succeeded.
        return args_var;
    }
    static expr_ty _item_expression_var();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_2(void) {  // expression for_if_clauses
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, for_if_clauses_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "args"},
        {_alt_2, "_alt_2", "expression for_if_clauses"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_args_var(void) {
    return _args_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
expr_ty _item_a(void) {
    return _args_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
expr_ty _item_args_var(void) {
    return _args_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
asdl_comprehension_seq* _item_b(void) {
    return _for_if_clauses_rule(p);
}
expr_ty _item_a(void) {
    return _args_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_args_var(void) {
    return _args_rule(p);
}

// invalid_kwarg: ('True' | 'False' | 'None') '=' | NAME '=' expression
//     for_if_clauses | !(NAME '=') expression '='
static void * _invalid_kwarg_parse(RuleDescr *);
void * _invalid_kwarg_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_kwarg", "('True' | 'False' | 'None') '=' | NAME '=' expression for_if_clauses | !(NAME '=') expression '='"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_kwarg_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static void * _item_a();
    static Token * _item_b();
    void * _alt_1(void) {  // ('True' | 'False' | 'None') '='
        // ('True' | 'False' | 'None')
        Token* a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "cannot assign to %s" , PyBytes_AS_STRING (a -> bytes));
    }
    static expr_ty _item_a();
    static Token * _item_b();
    static expr_ty _item_expression_var();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_2(void) {  // NAME '=' expression for_if_clauses
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * b;
        if (!(b = _item_b())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
    }
    static int _item__lookahead_var();
    static expr_ty _item_a();
    static Token * _item_b();
    void * _alt_3(void) {  // !(NAME '=') expression '='
        // !(NAME '=')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "expression cannot contain assignment, perhaps you meant \"==\"?");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "('True' | 'False' | 'None') '='"},
        {_alt_2, "_alt_2", "NAME '=' expression for_if_clauses"},
        {_alt_3, "_alt_3", "!(NAME '=') expression '='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'True'
        // 'True'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_2(void) {  // 'False'
        // 'False'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_3(void) {  // 'None'
        // 'None'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'True'"},
        {_alt_2, "_alt_2", "'False'"},
        {_alt_3, "_alt_3", "'None'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 600);   // keyword='True'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 602);   // keyword='False'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 601);   // keyword='None'
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_NAME_var();
    static Token * _item__literal_var();
    void * _alt(void) {  // NAME '='
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, NAME_var, _literal_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME '='"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}

// expression_without_invalid: disjunction 'if' disjunction 'else' expression |
//     disjunction | lambdef
    int _prev_call_invalid = p->call_invalid_rules;
    p->call_invalid_rules = 0;
static void * _expression_without_invalid_parse(RuleDescr *);
expr_ty _expression_without_invalid_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "expression_without_invalid", "disjunction 'if' disjunction 'else' expression | disjunction | lambdef"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _expression_without_invalid_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__keyword_var();
    static expr_ty _item_b();
    static Token * _item__keyword_var_1();
    static expr_ty _item_c();
    void * _alt_1(void) {  // disjunction 'if' disjunction 'else' expression
        // disjunction
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // disjunction
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // 'else'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // expression
        expr_ty c;
        if (!(c = _item_c())) return NULL;
        // parse succeeded.
        int _end_lineno, _end_col_offset;
        _PyPegen_location_end(p, &_end_lineno, &_end_col_offset {
            return NULL;
        }
        return _PyAST_IfExp (b , a , c , EXTRA);
    }
    static expr_ty _item_disjunction_var();
    void * _alt_2(void) {  // disjunction
        // disjunction
        expr_ty disjunction_var;
        if (!(disjunction_var = _item_disjunction_var())) return NULL;
        // parse succeeded.
        return disjunction_var;
    }
    static expr_ty _item_lambdef_var();
    void * _alt_3(void) {  // lambdef
        // lambdef
        expr_ty lambdef_var;
        if (!(lambdef_var = _item_lambdef_var())) return NULL;
        // parse succeeded.
        return lambdef_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "disjunction 'if' disjunction 'else' expression"},
        {_alt_2, "_alt_2", "disjunction"},
        {_alt_3, "_alt_3", "lambdef"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_b(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 642);   // keyword='else'
}
expr_ty _item_c(void) {
    return _expression_rule(p);
}
expr_ty _item_disjunction_var(void) {
    return _disjunction_rule(p);
}
expr_ty _item_lambdef_var(void) {
    return _lambdef_rule(p);
}

// invalid_legacy_expression: NAME !'(' star_expressions
static void * _invalid_legacy_expression_parse(RuleDescr *);
void * _invalid_legacy_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_legacy_expression", "NAME !'(' star_expressions"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_legacy_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static int _item__lookahead_var();
    static expr_ty _item_b();
    void * _alt(void) {  // NAME !'(' star_expressions
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // !'('
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // star_expressions
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_check_legacy_stmt (p , a) ? RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "Missing parentheses in call to '%U'. Did you mean %U(...)?" , a -> v . Name . id , a -> v . Name . id) : NULL;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NAME !'(' star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_b(void) {
    return _star_expressions_rule(p);
}

// invalid_expression: !(NAME STRING | SOFT_KEYWORD) disjunction
//     expression_without_invalid | disjunction 'if' disjunction !('else' | ':')
static void * _invalid_expression_parse(RuleDescr *);
void * _invalid_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_expression", "!(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid | disjunction 'if' disjunction !('else' | ':')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static int _item__lookahead_var();
    static expr_ty _item_a();
    static expr_ty _item_b();
    void * _alt_1(void) {  // !(NAME STRING | SOFT_KEYWORD) disjunction
    //     expression_without_invalid
        // !(NAME STRING | SOFT_KEYWORD)
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // disjunction
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // expression_without_invalid
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return _PyPegen_check_legacy_stmt (p , a) ? NULL : p -> tokens [p -> mark - 1] -> level == 0 ? NULL : RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "invalid syntax. Perhaps you forgot a comma?");
    }
    static expr_ty _item_a();
    static Token * _item__keyword_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // disjunction 'if' disjunction !('else' | ':')
        // disjunction
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // disjunction
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // !('else' | ':')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "expected 'else' after 'if' expression");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "!(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid"},
        {_alt_2, "_alt_2", "disjunction 'if' disjunction !('else' | ':')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_NAME_var();
    static void * _item_STRING_var();
    void * _alt_1(void) {  // NAME STRING
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // STRING
        void * STRING_var;
        if (!(STRING_var = _item_STRING_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, NAME_var, STRING_var);
    }
    static void * _item_SOFT_KEYWORD_var();
    void * _alt_2(void) {  // SOFT_KEYWORD
        // SOFT_KEYWORD
        void * SOFT_KEYWORD_var;
        if (!(SOFT_KEYWORD_var = _item_SOFT_KEYWORD_var())) return NULL;
        // parse succeeded.
        return SOFT_KEYWORD_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NAME STRING"},
        {_alt_2, "_alt_2", "SOFT_KEYWORD"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
void * _item_STRING_var(void) {
    return _PyPegen_string_token(p);
}
void * _item_SOFT_KEYWORD_var(void) {
    return _PyPegen_soft_keyword_token(p);
}
expr_ty _item_a(void) {
    return _disjunction_rule(p);
}
expr_ty _item_b(void) {
    return _expression_without_invalid_rule(p);
}
expr_ty _item_a(void) {
    return _disjunction_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_b(void) {
    return _disjunction_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'else'
        // 'else'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'else'"},
        {_alt_2, "_alt_2", "':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 642);   // keyword='else'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// invalid_named_expression: expression ':=' expression | NAME '=' bitwise_or
//     !('=' | ':=') | !(list | tuple | genexp | 'True' | 'None' | 'False')
//     bitwise_or '=' bitwise_or !('=' | ':=')
static void * _invalid_named_expression_parse(RuleDescr *);
void * _invalid_named_expression_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_named_expression", "expression ':=' expression | NAME '=' bitwise_or !('=' | ':=') | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')"};
    return _PyPegen_parse_memo_rule(p, &_rule_descriptor, invalid_named_expression_type);
}
void * _invalid_named_expression_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_expression_var();
    void * _alt_1(void) {  // expression ':=' expression
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot use assignment expressions with %s" , _PyPegen_get_expr_name (a));
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_b();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // NAME '=' bitwise_or !('=' | ':=')
        // NAME
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // bitwise_or
        expr_ty b;
        if (!(b = _item_b())) return NULL;
        // !('=' | ':=')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "invalid syntax. Maybe you meant '==' or ':=' instead of '='?");
    }
    static int _item__lookahead_var();
    static expr_ty _item_a();
    static Token * _item_b();
    static expr_ty _item_bitwise_or_var();
    static int _item__lookahead_var_1();
    void * _alt_3(void) {  // !(list | tuple | genexp | 'True' | 'None' |
    //     'False') bitwise_or '=' bitwise_or !('=' | ':=')
        // !(list | tuple | genexp | 'True' | 'None' | 'False')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // bitwise_or
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * b;
        if (!(b = _item_b())) return NULL;
        // bitwise_or
        expr_ty bitwise_or_var;
        if (!(bitwise_or_var = _item_bitwise_or_var())) return NULL;
        // !('=' | ':=')
        int _lookahead_var_1;
        if (!(_lookahead_var_1 = _item__lookahead_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot assign to %s here. Maybe you meant '==' instead of '='?" , _PyPegen_get_expr_name (a));
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "expression ':=' expression"},
        {_alt_2, "_alt_2", "NAME '=' bitwise_or !('=' | ':=')"},
        {_alt_3, "_alt_3", "!(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
expr_ty _item_a(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_b(void) {
    return _bitwise_or_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '='
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ':='
        // ':='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'='"},
        {_alt_2, "_alt_2", "':='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_list_var();
    void * _alt_1(void) {  // list
        // list
        expr_ty list_var;
        if (!(list_var = _item_list_var())) return NULL;
        // parse succeeded.
        return list_var;
    }
    static expr_ty _item_tuple_var();
    void * _alt_2(void) {  // tuple
        // tuple
        expr_ty tuple_var;
        if (!(tuple_var = _item_tuple_var())) return NULL;
        // parse succeeded.
        return tuple_var;
    }
    static expr_ty _item_genexp_var();
    void * _alt_3(void) {  // genexp
        // genexp
        expr_ty genexp_var;
        if (!(genexp_var = _item_genexp_var())) return NULL;
        // parse succeeded.
        return genexp_var;
    }
    static Token * _item__keyword_var();
    void * _alt_4(void) {  // 'True'
        // 'True'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_5(void) {  // 'None'
        // 'None'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_6(void) {  // 'False'
        // 'False'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "list"},
        {_alt_2, "_alt_2", "tuple"},
        {_alt_3, "_alt_3", "genexp"},
        {_alt_4, "_alt_4", "'True'"},
        {_alt_5, "_alt_5", "'None'"},
        {_alt_6, "_alt_6", "'False'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_list_var(void) {
    return _list_rule(p);
}
expr_ty _item_tuple_var(void) {
    return _tuple_rule(p);
}
expr_ty _item_genexp_var(void) {
    return _genexp_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 600);   // keyword='True'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 601);   // keyword='None'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 602);   // keyword='False'
}
expr_ty _item_a(void) {
    return _bitwise_or_rule(p);
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_bitwise_or_var(void) {
    return _bitwise_or_rule(p);
}
int _item__lookahead_var_1(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '='
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ':='
        // ':='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'='"},
        {_alt_2, "_alt_2", "':='"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 53);   // token=:=
}

// invalid_assignment: invalid_ann_assign_target ':' expression |
//     star_named_expression ',' star_named_expressions* ':' expression |
//     expression ':' expression | ((star_targets '='))* star_expressions '=' |
//     ((star_targets '='))* yield_expr '=' | star_expressions augassign
//     (yield_expr | star_expressions)
static void * _invalid_assignment_parse(RuleDescr *);
void * _invalid_assignment_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_assignment", "invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_assignment_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_expression_var();
    void * _alt_1(void) {  // invalid_ann_assign_target ':' expression
        // invalid_ann_assign_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "only single target (not %s) can be annotated" , _PyPegen_get_expr_name (a));
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var_1();
    static expr_ty _item_expression_var();
    void * _alt_2(void) {  // star_named_expression ',' star_named_expressions*
    //     ':' expression
        // star_named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_named_expressions*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "only single target (not tuple) can be annotated");
    }
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_expression_var();
    void * _alt_3(void) {  // expression ':' expression
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "illegal target for annotation");
    }
    static asdl_seq * _item__loop_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_4(void) {  // ((star_targets '='))* star_expressions '='
        // ((star_targets '='))*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // star_expressions
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_INVALID_TARGET (STAR_TARGETS , a);
    }
    static asdl_seq * _item__loop_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    void * _alt_5(void) {  // ((star_targets '='))* yield_expr '='
        // ((star_targets '='))*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // yield_expr
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "assignment to yield expression not possible");
    }
    static expr_ty _item_a();
    static AugOperator* _item_augassign_var();
    static void * _item__group_var();
    void * _alt_6(void) {  // star_expressions augassign (yield_expr |
    //     star_expressions)
        // star_expressions
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // augassign
        AugOperator* augassign_var;
        if (!(augassign_var = _item_augassign_var())) return NULL;
        // (yield_expr | star_expressions)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "'%s' is an illegal expression for augmented assignment" , _PyPegen_get_expr_name (a));
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "invalid_ann_assign_target ':' expression"},
        {_alt_2, "_alt_2", "star_named_expression ',' star_named_expressions* ':' expression"},
        {_alt_3, "_alt_3", "expression ':' expression"},
        {_alt_4, "_alt_4", "((star_targets '='))* star_expressions '='"},
        {_alt_5, "_alt_5", "((star_targets '='))* yield_expr '='"},
        {_alt_6, "_alt_6", "star_expressions augassign (yield_expr | star_expressions)"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _invalid_ann_assign_target_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
expr_ty _item_a(void) {
    return _star_named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
asdl_expr_seq* _node(void) {
    return _star_named_expressions_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_star_targets_var();
    static Token * _item__literal_var();
    void * _alt(void) {  // star_targets '='
        // star_targets
        expr_ty star_targets_var;
        if (!(star_targets_var = _item_star_targets_var())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, star_targets_var, _literal_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_targets '='"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_star_targets_var(void) {
    return _star_targets_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _star_expressions_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_star_targets_var();
    static Token * _item__literal_var();
    void * _alt(void) {  // star_targets '='
        // star_targets
        expr_ty star_targets_var;
        if (!(star_targets_var = _item_star_targets_var())) return NULL;
        // '='
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, star_targets_var, _literal_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "star_targets '='"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_star_targets_var(void) {
    return _star_targets_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _yield_expr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
expr_ty _item_a(void) {
    return _star_expressions_rule(p);
}
AugOperator* _item_augassign_var(void) {
    return _augassign_rule(p);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_yield_expr_var();
    void * _alt_1(void) {  // yield_expr
        // yield_expr
        expr_ty yield_expr_var;
        if (!(yield_expr_var = _item_yield_expr_var())) return NULL;
        // parse succeeded.
        return yield_expr_var;
    }
    static expr_ty _item_star_expressions_var();
    void * _alt_2(void) {  // star_expressions
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // parse succeeded.
        return star_expressions_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "yield_expr"},
        {_alt_2, "_alt_2", "star_expressions"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_yield_expr_var(void) {
    return _yield_expr_rule(p);
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}

// invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
static void * _invalid_ann_assign_target_parse(RuleDescr *);
expr_ty _invalid_ann_assign_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_ann_assign_target", "list | tuple | '(' invalid_ann_assign_target ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_ann_assign_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_list_var();
    void * _alt_1(void) {  // list
        // list
        expr_ty list_var;
        if (!(list_var = _item_list_var())) return NULL;
        // parse succeeded.
        return list_var;
    }
    static expr_ty _item_tuple_var();
    void * _alt_2(void) {  // tuple
        // tuple
        expr_ty tuple_var;
        if (!(tuple_var = _item_tuple_var())) return NULL;
        // parse succeeded.
        return tuple_var;
    }
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // '(' invalid_ann_assign_target ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // invalid_ann_assign_target
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "list"},
        {_alt_2, "_alt_2", "tuple"},
        {_alt_3, "_alt_3", "'(' invalid_ann_assign_target ')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_list_var(void) {
    return _list_rule(p);
}
expr_ty _item_tuple_var(void) {
    return _tuple_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_a(void) {
    return _invalid_ann_assign_target_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// invalid_del_stmt: 'del' star_expressions
static void * _invalid_del_stmt_parse(RuleDescr *);
void * _invalid_del_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_del_stmt", "'del' star_expressions"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_del_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt(void) {  // 'del' star_expressions
        // 'del'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_expressions
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_INVALID_TARGET (DEL_TARGETS , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'del' star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 603);   // keyword='del'
}
expr_ty _item_a(void) {
    return _star_expressions_rule(p);
}

// invalid_block: NEWLINE !INDENT
static void * _invalid_block_parse(RuleDescr *);
void * _invalid_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_block", "NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt(void) {  // NEWLINE !INDENT
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "NEWLINE !INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses |
//     ('[' | '{') star_named_expression ',' star_named_expressions
//     for_if_clauses | ('[' | '{') star_named_expression ',' for_if_clauses
static void * _invalid_comprehension_parse(RuleDescr *);
void * _invalid_comprehension_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_comprehension", "('[' | '(' | '{') starred_expression for_if_clauses | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses | ('[' | '{') star_named_expression ',' for_if_clauses"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_comprehension_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static void * _item__group_var();
    static expr_ty _item_a();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_1(void) {  // ('[' | '(' | '{') starred_expression
    //     for_if_clauses
        // ('[' | '(' | '{')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // starred_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "iterable unpacking cannot be used in comprehension");
    }
    static void * _item__group_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static asdl_expr_seq* _item_b();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_2(void) {  // ('[' | '{') star_named_expression ','
    //     star_named_expressions for_if_clauses
        // ('[' | '{')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // star_named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // star_named_expressions
        asdl_expr_seq* b;
        if (!(b = _item_b())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , PyPegen_last_item (b , expr_ty) , "did you forget parentheses around the comprehension target?");
    }
    static void * _item__group_var();
    static expr_ty _item_a();
    static Token * _item_b();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    void * _alt_3(void) {  // ('[' | '{') star_named_expression ','
    //     for_if_clauses
        // ('[' | '{')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // star_named_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * b;
        if (!(b = _item_b())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "did you forget parentheses around the comprehension target?");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "('[' | '(' | '{') starred_expression for_if_clauses"},
        {_alt_2, "_alt_2", "('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses"},
        {_alt_3, "_alt_3", "('[' | '{') star_named_expression ',' for_if_clauses"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '['
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '('
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '{'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'['"},
        {_alt_2, "_alt_2", "'('"},
        {_alt_3, "_alt_3", "'{'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
expr_ty _item_a(void) {
    return _starred_expression_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '['
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '{'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'['"},
        {_alt_2, "_alt_2", "'{'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
expr_ty _item_a(void) {
    return _star_named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_expr_seq* _item_b(void) {
    return _star_named_expressions_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '['
        // '['
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '{'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'['"},
        {_alt_2, "_alt_2", "'{'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 9);   // token=[
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
expr_ty _item_a(void) {
    return _star_named_expression_rule(p);
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}

// invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
static void * _invalid_dict_comprehension_parse(RuleDescr *);
void * _invalid_dict_comprehension_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_dict_comprehension", "'{' '**' bitwise_or for_if_clauses '}'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_dict_comprehension_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static Token * _item_a();
    static expr_ty _item_bitwise_or_var();
    static asdl_comprehension_seq* _item_for_if_clauses_var();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '{' '**' bitwise_or for_if_clauses '}'
        // '{'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '**'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // bitwise_or
        expr_ty bitwise_or_var;
        if (!(bitwise_or_var = _item_bitwise_or_var())) return NULL;
        // for_if_clauses
        asdl_comprehension_seq* for_if_clauses_var;
        if (!(for_if_clauses_var = _item_for_if_clauses_var())) return NULL;
        // '}'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "dict unpacking cannot be used in dict comprehension");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'{' '**' bitwise_or for_if_clauses '}'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 25);   // token={
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_bitwise_or_var(void) {
    return _bitwise_or_rule(p);
}
asdl_comprehension_seq* _item_for_if_clauses_var(void) {
    return _for_if_clauses_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}

// invalid_parameters: param_no_default* invalid_parameters_helper
//     param_no_default | param_no_default* '(' param_no_default+ ','? ')' | "/"
//     ',' | (slash_no_default | slash_with_default) param_maybe_default* '/' |
//     (slash_no_default | slash_with_default)? param_maybe_default* '*' (',' |
//     param_no_default) param_maybe_default* '/' | param_maybe_default+ '/' '*'
static void * _invalid_parameters_parse(RuleDescr *);
void * _invalid_parameters_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_parameters", "param_no_default* invalid_parameters_helper param_no_default | param_no_default* '(' param_no_default+ ','? ')' | \"/\" ',' | (slash_no_default | slash_with_default) param_maybe_default* '/' | (slash_no_default | slash_with_default)? param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/' | param_maybe_default+ '/' '*'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_parameters_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item__loop_var();
    static void * _item_invalid_parameters_helper_var();
    static arg_ty _item_a();
    void * _alt_1(void) {  // param_no_default* invalid_parameters_helper
    //     param_no_default
        // param_no_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // invalid_parameters_helper
        void * invalid_parameters_helper_var;
        if (!(invalid_parameters_helper_var = _item_invalid_parameters_helper_var())) return NULL;
        // param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "non-default argument follows default argument");
    }
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    static asdl_seq * _item__loop_var_1();
    static ParseResult[Any] _item_opt_var();
    static Token * _item_b();
    void * _alt_2(void) {  // param_no_default* '(' param_no_default+ ','? ')'
        // param_no_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '('
        Token * a;
        if (!(a = _item_a())) return NULL;
        // param_no_default+
        asdl_seq * _loop_var_1;
        if (!(_loop_var_1 = _item__loop_var_1())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "Function parameters cannot be parenthesized");
    }
    static Token * _item_a();
    static Token * _item__literal_var();
    void * _alt_3(void) {  // "/" ','
        // "/"
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "at least one argument must precede /");
    }
    static void * _item__group_var();
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    void * _alt_4(void) {  // (slash_no_default | slash_with_default)
    //     param_maybe_default* '/'
        // (slash_no_default | slash_with_default)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '/'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "/ may appear only once");
    }
    static ParseResult[Any] _item_opt_var();
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static void * _item__group_var();
    static asdl_seq * _item__loop_var_1();
    static Token * _item_a();
    void * _alt_5(void) {  // (slash_no_default | slash_with_default)?
    //     param_maybe_default* '*' (',' | param_no_default)
    //     param_maybe_default* '/'
        // (slash_no_default | slash_with_default)?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (',' | param_no_default)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // param_maybe_default*
        asdl_seq * _loop_var_1;
        if ((_loop_var_1 = (asdl_seq *) _item__loop_var_1()), p->error_indicator) return NULL;
        _loop_var_1 = _item__loop_var_1();
        // '/'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "/ must be ahead of *");
    }
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static Token * _item_a();
    void * _alt_6(void) {  // param_maybe_default+ '/' '*'
        // param_maybe_default+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "expected comma between / and *");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_no_default* invalid_parameters_helper param_no_default"},
        {_alt_2, "_alt_2", "param_no_default* '(' param_no_default+ ','? ')'"},
        {_alt_3, "_alt_3", "\"/\" ','"},
        {_alt_4, "_alt_4", "(slash_no_default | slash_with_default) param_maybe_default* '/'"},
        {_alt_5, "_alt_5", "(slash_no_default | slash_with_default)? param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'"},
        {_alt_6, "_alt_6", "param_maybe_default+ '/' '*'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
void * _item_invalid_parameters_helper_var(void) {
    return _invalid_parameters_helper_rule(p);
}
arg_ty _item_a(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
arg_ty _node(void) {
    return _param_no_default_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static asdl_arg_seq* _item_slash_no_default_var();
    void * _alt_1(void) {  // slash_no_default
        // slash_no_default
        asdl_arg_seq* slash_no_default_var;
        if (!(slash_no_default_var = _item_slash_no_default_var())) return NULL;
        // parse succeeded.
        return slash_no_default_var;
    }
    static SlashWithDefault* _item_slash_with_default_var();
    void * _alt_2(void) {  // slash_with_default
        // slash_with_default
        SlashWithDefault* slash_with_default_var;
        if (!(slash_with_default_var = _item_slash_with_default_var())) return NULL;
        // parse succeeded.
        return slash_with_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slash_no_default"},
        {_alt_2, "_alt_2", "slash_with_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_slash_no_default_var(void) {
    return _slash_no_default_rule(p);
}
SlashWithDefault* _item_slash_with_default_var(void) {
    return _slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static asdl_arg_seq* _item_slash_no_default_var();
    void * _alt_1(void) {  // slash_no_default
        // slash_no_default
        asdl_arg_seq* slash_no_default_var;
        if (!(slash_no_default_var = _item_slash_no_default_var())) return NULL;
        // parse succeeded.
        return slash_no_default_var;
    }
    static SlashWithDefault* _item_slash_with_default_var();
    void * _alt_2(void) {  // slash_with_default
        // slash_with_default
        SlashWithDefault* slash_with_default_var;
        if (!(slash_with_default_var = _item_slash_with_default_var())) return NULL;
        // parse succeeded.
        return slash_with_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slash_no_default"},
        {_alt_2, "_alt_2", "slash_with_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_slash_no_default_var(void) {
    return _slash_no_default_rule(p);
}
SlashWithDefault* _item_slash_with_default_var(void) {
    return _slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static arg_ty _item_param_no_default_var();
    void * _alt_2(void) {  // param_no_default
        // param_no_default
        arg_ty param_no_default_var;
        if (!(param_no_default_var = _item_param_no_default_var())) return NULL;
        // parse succeeded.
        return param_no_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','"},
        {_alt_2, "_alt_2", "param_no_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_param_no_default_var(void) {
    return _param_no_default_rule(p);
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}

// invalid_default: '=' &(')' | ',')
static void * _invalid_default_parse(RuleDescr *);
void * _invalid_default_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_default", "'=' &(')' | ',')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_default_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static int _item__lookahead_var();
    void * _alt(void) {  // '=' &(')' | ',')
        // '='
        Token * a;
        if (!(a = _item_a())) return NULL;
        // &(')' | ',')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "expected default value expression");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'=' &(')' | ',')"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ')'
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "')'"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT | '*'
//     param '=' | '*' (param_no_default | ',') param_maybe_default* '*'
//     (param_no_default | ',')
static void * _invalid_star_etc_parse(RuleDescr *);
void * _invalid_star_etc_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_star_etc", "'*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT | '*' param '=' | '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_star_etc_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static void * _item__group_var();
    void * _alt_1(void) {  // '*' (')' | ',' (')' | '**'))
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // (')' | ',' (')' | '**'))
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "named arguments must follow bare *");
    }
    static Token * _item__literal_var();
    static Token * _item__literal_var_1();
    static void * _item_TYPE_COMMENT_var();
    void * _alt_2(void) {  // '*' ',' TYPE_COMMENT
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("bare * has associated type comment");
    }
    static Token * _item__literal_var();
    static arg_ty _item_param_var();
    static Token * _item_a();
    void * _alt_3(void) {  // '*' param '='
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param
        arg_ty param_var;
        if (!(param_var = _item_param_var())) return NULL;
        // '='
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "var-positional argument cannot have default value");
    }
    static Token * _item__literal_var();
    static void * _item__group_var();
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    static void * _item__group_var_1();
    void * _alt_4(void) {  // '*' (param_no_default | ',') param_maybe_default*
    //     '*' (param_no_default | ',')
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (param_no_default | ',')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // (param_no_default | ',')
        void * _group_var_1;
        if (!(_group_var_1 = _item__group_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "* argument may appear only once");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' (')' | ',' (')' | '**'))"},
        {_alt_2, "_alt_2", "'*' ',' TYPE_COMMENT"},
        {_alt_3, "_alt_3", "'*' param '='"},
        {_alt_4, "_alt_4", "'*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ')'
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    static void * _item__group_var();
    void * _alt_2(void) {  // ',' (')' | '**')
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (')' | '**')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, _group_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "')'"},
        {_alt_2, "_alt_2", "',' (')' | '**')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ')'
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '**'
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "')'"},
        {_alt_2, "_alt_2", "'**'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
arg_ty _item_param_var(void) {
    return _param_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static arg_ty _item_param_no_default_var();
    void * _alt_1(void) {  // param_no_default
        // param_no_default
        arg_ty param_no_default_var;
        if (!(param_no_default_var = _item_param_no_default_var())) return NULL;
        // parse succeeded.
        return param_no_default_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_no_default"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_param_no_default_var(void) {
    return _param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var_1(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static arg_ty _item_param_no_default_var();
    void * _alt_1(void) {  // param_no_default
        // param_no_default
        arg_ty param_no_default_var;
        if (!(param_no_default_var = _item_param_no_default_var())) return NULL;
        // parse succeeded.
        return param_no_default_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "param_no_default"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_param_no_default_var(void) {
    return _param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// invalid_kwds: '**' param '=' | '**' param ',' param | '**' param ',' ('*' |
//     '**' | '/')
static void * _invalid_kwds_parse(RuleDescr *);
void * _invalid_kwds_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_kwds", "'**' param '=' | '**' param ',' param | '**' param ',' ('*' | '**' | '/')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_kwds_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static arg_ty _item_param_var();
    static Token * _item_a();
    void * _alt_1(void) {  // '**' param '='
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param
        arg_ty param_var;
        if (!(param_var = _item_param_var())) return NULL;
        // '='
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "var-keyword argument cannot have default value");
    }
    static Token * _item__literal_var();
    static arg_ty _item_param_var();
    static Token * _item__literal_var_1();
    static arg_ty _item_a();
    void * _alt_2(void) {  // '**' param ',' param
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param
        arg_ty param_var;
        if (!(param_var = _item_param_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "arguments cannot follow var-keyword argument");
    }
    static Token * _item__literal_var();
    static arg_ty _item_param_var();
    static Token * _item__literal_var_1();
    static void * _item_a();
    void * _alt_3(void) {  // '**' param ',' ('*' | '**' | '/')
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // param
        arg_ty param_var;
        if (!(param_var = _item_param_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ('*' | '**' | '/')
        Token* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "arguments cannot follow var-keyword argument");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'**' param '='"},
        {_alt_2, "_alt_2", "'**' param ',' param"},
        {_alt_3, "_alt_3", "'**' param ',' ('*' | '**' | '/')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_param_var(void) {
    return _param_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_param_var(void) {
    return _param_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_a(void) {
    return _param_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_param_var(void) {
    return _param_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '*'
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '**'
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '/'
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*'"},
        {_alt_2, "_alt_2", "'**'"},
        {_alt_3, "_alt_3", "'/'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}

// invalid_parameters_helper: slash_with_default | param_with_default+
static void * _invalid_parameters_helper_parse(RuleDescr *);
void * _invalid_parameters_helper_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_parameters_helper", "slash_with_default | param_with_default+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_parameters_helper_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static SlashWithDefault* _item_a();
    void * _alt_1(void) {  // slash_with_default
        // slash_with_default
        SlashWithDefault* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_singleton_seq (p , a);
    }
    static asdl_seq * _item__loop_var();
    void * _alt_2(void) {  // param_with_default+
        // param_with_default+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "slash_with_default"},
        {_alt_2, "_alt_2", "param_with_default+"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
SlashWithDefault* _item_a(void) {
    return _slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _param_with_default_rule(p);
}

// invalid_lambda_parameters: lambda_param_no_default*
//     invalid_lambda_parameters_helper lambda_param_no_default |
//     lambda_param_no_default* '(' ','.lambda_param+ ','? ')' | "/" ',' |
//     (lambda_slash_no_default | lambda_slash_with_default)
//     lambda_param_maybe_default* '/' | (lambda_slash_no_default |
//     lambda_slash_with_default)? lambda_param_maybe_default* '*' (',' |
//     lambda_param_no_default) lambda_param_maybe_default* '/' |
//     lambda_param_maybe_default+ '/' '*'
static void * _invalid_lambda_parameters_parse(RuleDescr *);
void * _invalid_lambda_parameters_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_lambda_parameters", "lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default | lambda_param_no_default* '(' ','.lambda_param+ ','? ')' | \"/\" ',' | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/' | (lambda_slash_no_default | lambda_slash_with_default)? lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/' | lambda_param_maybe_default+ '/' '*'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_lambda_parameters_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item__loop_var();
    static void * _item_invalid_lambda_parameters_helper_var();
    static arg_ty _item_a();
    void * _alt_1(void) {  // lambda_param_no_default*
    //     invalid_lambda_parameters_helper lambda_param_no_default
        // lambda_param_no_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // invalid_lambda_parameters_helper
        void * invalid_lambda_parameters_helper_var;
        if (!(invalid_lambda_parameters_helper_var = _item_invalid_lambda_parameters_helper_var())) return NULL;
        // lambda_param_no_default
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "non-default argument follows default argument");
    }
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    static asdl_seq * _item__loop_var_1();
    static ParseResult[Any] _item_opt_var();
    static Token * _item_b();
    void * _alt_2(void) {  // lambda_param_no_default* '(' ','.lambda_param+
    //     ','? ')'
        // lambda_param_no_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '('
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ','.lambda_param+
        asdl_seq * _loop_var_1;
        if (!(_loop_var_1 = _item__loop_var_1())) return NULL;
        // ','?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * b;
        if (!(b = _item_b())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "Lambda expression parameters cannot be parenthesized");
    }
    static Token * _item_a();
    static Token * _item__literal_var();
    void * _alt_3(void) {  // "/" ','
        // "/"
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "at least one argument must precede /");
    }
    static void * _item__group_var();
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    void * _alt_4(void) {  // (lambda_slash_no_default |
    //     lambda_slash_with_default) lambda_param_maybe_default* '/'
        // (lambda_slash_no_default | lambda_slash_with_default)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // lambda_param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '/'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "/ may appear only once");
    }
    static ParseResult[Any] _item_opt_var();
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static void * _item__group_var();
    static asdl_seq * _item__loop_var_1();
    static Token * _item_a();
    void * _alt_5(void) {  // (lambda_slash_no_default |
    //     lambda_slash_with_default)? lambda_param_maybe_default* '*' (',' |
    //     lambda_param_no_default) lambda_param_maybe_default* '/'
        // (lambda_slash_no_default | lambda_slash_with_default)?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // lambda_param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (',' | lambda_param_no_default)
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // lambda_param_maybe_default*
        asdl_seq * _loop_var_1;
        if ((_loop_var_1 = (asdl_seq *) _item__loop_var_1()), p->error_indicator) return NULL;
        _loop_var_1 = _item__loop_var_1();
        // '/'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "/ must be ahead of *");
    }
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static Token * _item_a();
    void * _alt_6(void) {  // lambda_param_maybe_default+ '/' '*'
        // lambda_param_maybe_default+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "expected comma between / and *");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default"},
        {_alt_2, "_alt_2", "lambda_param_no_default* '(' ','.lambda_param+ ','? ')'"},
        {_alt_3, "_alt_3", "\"/\" ','"},
        {_alt_4, "_alt_4", "(lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'"},
        {_alt_5, "_alt_5", "(lambda_slash_no_default | lambda_slash_with_default)? lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'"},
        {_alt_6, "_alt_6", "lambda_param_maybe_default+ '/' '*'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
void * _item_invalid_lambda_parameters_helper_var(void) {
    return _invalid_lambda_parameters_helper_rule(p);
}
arg_ty _item_a(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
arg_ty _node(void) {
    return _lambda_param_no_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
arg_ty _node(void) {
    return _lambda_param_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static asdl_arg_seq* _item_lambda_slash_no_default_var();
    void * _alt_1(void) {  // lambda_slash_no_default
        // lambda_slash_no_default
        asdl_arg_seq* lambda_slash_no_default_var;
        if (!(lambda_slash_no_default_var = _item_lambda_slash_no_default_var())) return NULL;
        // parse succeeded.
        return lambda_slash_no_default_var;
    }
    static SlashWithDefault* _item_lambda_slash_with_default_var();
    void * _alt_2(void) {  // lambda_slash_with_default
        // lambda_slash_with_default
        SlashWithDefault* lambda_slash_with_default_var;
        if (!(lambda_slash_with_default_var = _item_lambda_slash_with_default_var())) return NULL;
        // parse succeeded.
        return lambda_slash_with_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_slash_no_default"},
        {_alt_2, "_alt_2", "lambda_slash_with_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_lambda_slash_no_default_var(void) {
    return _lambda_slash_no_default_rule(p);
}
SlashWithDefault* _item_lambda_slash_with_default_var(void) {
    return _lambda_slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static asdl_arg_seq* _item_lambda_slash_no_default_var();
    void * _alt_1(void) {  // lambda_slash_no_default
        // lambda_slash_no_default
        asdl_arg_seq* lambda_slash_no_default_var;
        if (!(lambda_slash_no_default_var = _item_lambda_slash_no_default_var())) return NULL;
        // parse succeeded.
        return lambda_slash_no_default_var;
    }
    static SlashWithDefault* _item_lambda_slash_with_default_var();
    void * _alt_2(void) {  // lambda_slash_with_default
        // lambda_slash_with_default
        SlashWithDefault* lambda_slash_with_default_var;
        if (!(lambda_slash_with_default_var = _item_lambda_slash_with_default_var())) return NULL;
        // parse succeeded.
        return lambda_slash_with_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_slash_no_default"},
        {_alt_2, "_alt_2", "lambda_slash_with_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_arg_seq* _item_lambda_slash_no_default_var(void) {
    return _lambda_slash_no_default_rule(p);
}
SlashWithDefault* _item_lambda_slash_with_default_var(void) {
    return _lambda_slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static arg_ty _item_lambda_param_no_default_var();
    void * _alt_2(void) {  // lambda_param_no_default
        // lambda_param_no_default
        arg_ty lambda_param_no_default_var;
        if (!(lambda_param_no_default_var = _item_lambda_param_no_default_var())) return NULL;
        // parse succeeded.
        return lambda_param_no_default_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','"},
        {_alt_2, "_alt_2", "lambda_param_no_default"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_lambda_param_no_default_var(void) {
    return _lambda_param_no_default_rule(p);
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}

// invalid_lambda_parameters_helper: lambda_slash_with_default |
//     lambda_param_with_default+
static void * _invalid_lambda_parameters_helper_parse(RuleDescr *);
void * _invalid_lambda_parameters_helper_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_lambda_parameters_helper", "lambda_slash_with_default | lambda_param_with_default+"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_lambda_parameters_helper_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static SlashWithDefault* _item_a();
    void * _alt_1(void) {  // lambda_slash_with_default
        // lambda_slash_with_default
        SlashWithDefault* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return _PyPegen_singleton_seq (p , a);
    }
    static asdl_seq * _item__loop_var();
    void * _alt_2(void) {  // lambda_param_with_default+
        // lambda_param_with_default+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // parse succeeded.
        return _loop_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_slash_with_default"},
        {_alt_2, "_alt_2", "lambda_param_with_default+"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
SlashWithDefault* _item_a(void) {
    return _lambda_slash_with_default_rule(p);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
NameDefaultPair* _node(void) {
    return _lambda_param_with_default_rule(p);
}

// invalid_lambda_star_etc: '*' (':' | ',' (':' | '**')) | '*' lambda_param '='
//     | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*'
//     (lambda_param_no_default | ',')
static void * _invalid_lambda_star_etc_parse(RuleDescr *);
void * _invalid_lambda_star_etc_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_lambda_star_etc", "'*' (':' | ',' (':' | '**')) | '*' lambda_param '=' | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_lambda_star_etc_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static void * _item__group_var();
    void * _alt_1(void) {  // '*' (':' | ',' (':' | '**'))
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (':' | ',' (':' | '**'))
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("named arguments must follow bare *");
    }
    static Token * _item__literal_var();
    static arg_ty _item_lambda_param_var();
    static Token * _item_a();
    void * _alt_2(void) {  // '*' lambda_param '='
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param
        arg_ty lambda_param_var;
        if (!(lambda_param_var = _item_lambda_param_var())) return NULL;
        // '='
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "var-positional argument cannot have default value");
    }
    static Token * _item__literal_var();
    static void * _item__group_var();
    static asdl_seq * _item__loop_var();
    static Token * _item_a();
    static void * _item__group_var_1();
    void * _alt_3(void) {  // '*' (lambda_param_no_default | ',')
    //     lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (lambda_param_no_default | ',')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // lambda_param_maybe_default*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // (lambda_param_no_default | ',')
        void * _group_var_1;
        if (!(_group_var_1 = _item__group_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "* argument may appear only once");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*' (':' | ',' (':' | '**'))"},
        {_alt_2, "_alt_2", "'*' lambda_param '='"},
        {_alt_3, "_alt_3", "'*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    static void * _item__group_var();
    void * _alt_2(void) {  // ',' (':' | '**')
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (':' | '**')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, _group_var);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "':'"},
        {_alt_2, "_alt_2", "',' (':' | '**')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '**'
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "':'"},
        {_alt_2, "_alt_2", "'**'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
arg_ty _item_lambda_param_var(void) {
    return _lambda_param_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static arg_ty _item_lambda_param_no_default_var();
    void * _alt_1(void) {  // lambda_param_no_default
        // lambda_param_no_default
        arg_ty lambda_param_no_default_var;
        if (!(lambda_param_no_default_var = _item_lambda_param_no_default_var())) return NULL;
        // parse succeeded.
        return lambda_param_no_default_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param_no_default"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_lambda_param_no_default_var(void) {
    return _lambda_param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
NameDefaultPair* _node(void) {
    return _lambda_param_maybe_default_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var_1(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static arg_ty _item_lambda_param_no_default_var();
    void * _alt_1(void) {  // lambda_param_no_default
        // lambda_param_no_default
        arg_ty lambda_param_no_default_var;
        if (!(lambda_param_no_default_var = _item_lambda_param_no_default_var())) return NULL;
        // parse succeeded.
        return lambda_param_no_default_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "lambda_param_no_default"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
arg_ty _item_lambda_param_no_default_var(void) {
    return _lambda_param_no_default_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// invalid_lambda_kwds: '**' lambda_param '=' | '**' lambda_param ','
//     lambda_param | '**' lambda_param ',' ('*' | '**' | '/')
static void * _invalid_lambda_kwds_parse(RuleDescr *);
void * _invalid_lambda_kwds_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_lambda_kwds", "'**' lambda_param '=' | '**' lambda_param ',' lambda_param | '**' lambda_param ',' ('*' | '**' | '/')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_lambda_kwds_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static arg_ty _item_lambda_param_var();
    static Token * _item_a();
    void * _alt_1(void) {  // '**' lambda_param '='
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param
        arg_ty lambda_param_var;
        if (!(lambda_param_var = _item_lambda_param_var())) return NULL;
        // '='
        Token * a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "var-keyword argument cannot have default value");
    }
    static Token * _item__literal_var();
    static arg_ty _item_lambda_param_var();
    static Token * _item__literal_var_1();
    static arg_ty _item_a();
    void * _alt_2(void) {  // '**' lambda_param ',' lambda_param
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param
        arg_ty lambda_param_var;
        if (!(lambda_param_var = _item_lambda_param_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // lambda_param
        arg_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "arguments cannot follow var-keyword argument");
    }
    static Token * _item__literal_var();
    static arg_ty _item_lambda_param_var();
    static Token * _item__literal_var_1();
    static void * _item_a();
    void * _alt_3(void) {  // '**' lambda_param ',' ('*' | '**' | '/')
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // lambda_param
        arg_ty lambda_param_var;
        if (!(lambda_param_var = _item_lambda_param_var())) return NULL;
        // ','
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ('*' | '**' | '/')
        Token* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "arguments cannot follow var-keyword argument");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'**' lambda_param '='"},
        {_alt_2, "_alt_2", "'**' lambda_param ',' lambda_param"},
        {_alt_3, "_alt_3", "'**' lambda_param ',' ('*' | '**' | '/')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_lambda_param_var(void) {
    return _lambda_param_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 22);   // token==
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_lambda_param_var(void) {
    return _lambda_param_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
arg_ty _item_a(void) {
    return _lambda_param_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
arg_ty _item_lambda_param_var(void) {
    return _lambda_param_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item_a(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '*'
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // '**'
        // '**'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // '/'
        // '/'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'*'"},
        {_alt_2, "_alt_2", "'**'"},
        {_alt_3, "_alt_3", "'/'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 17);   // token=/
}

// invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE
//     INDENT
static void * _invalid_double_type_comments_parse(RuleDescr *);
void * _invalid_double_type_comments_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_double_type_comments", "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_double_type_comments_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static void * _item_TYPE_COMMENT_var();
    static Token * _item__newline_var();
    static void * _item_TYPE_COMMENT_var_1();
    static Token * _item__newline_var_1();
    static Token * _item__indent_var();
    void * _alt(void) {  // TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        // TYPE_COMMENT
        void * TYPE_COMMENT_var;
        if (!(TYPE_COMMENT_var = _item_TYPE_COMMENT_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // TYPE_COMMENT
        void * TYPE_COMMENT_var_1;
        if (!(TYPE_COMMENT_var_1 = _item_TYPE_COMMENT_var_1())) return NULL;
        // NEWLINE
        Token * _newline_var_1;
        if (!(_newline_var_1 = _item__newline_var_1())) return NULL;
        // INDENT
        Token * _indent_var;
        if (!(_indent_var = _item__indent_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("Cannot have two type comments on def");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
void * _item_TYPE_COMMENT_var(void) {
    return _PyPegen_type_comment_token(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
void * _item_TYPE_COMMENT_var_1(void) {
    return _PyPegen_type_comment_token(p);
}
Token * _item__newline_var_1(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__indent_var(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_with_item: expression 'as' expression &(',' | ')' | ':')
static void * _invalid_with_item_parse(RuleDescr *);
void * _invalid_with_item_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_with_item", "expression 'as' expression &(',' | ')' | ':')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_with_item_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_expression_var();
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    static int _item__lookahead_var();
    void * _alt(void) {  // expression 'as' expression &(',' | ')' | ':')
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // &(',' | ')' | ':')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_INVALID_TARGET (STAR_TARGETS , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression 'as' expression &(',' | ')' | ':')"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ')'
        // ')'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_3(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','"},
        {_alt_2, "_alt_2", "')'"},
        {_alt_3, "_alt_3", "':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// invalid_for_target: ASYNC? 'for' star_expressions
static void * _invalid_for_target_parse(RuleDescr *);
void * _invalid_for_target_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_for_target", "ASYNC? 'for' star_expressions"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_for_target_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt(void) {  // ASYNC? 'for' star_expressions
        // ASYNC?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_expressions
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_INVALID_TARGET (FOR_TARGETS , a);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC? 'for' star_expressions"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_a(void) {
    return _star_expressions_rule(p);
}

// invalid_group: '(' starred_expression ')' | '(' '**' expression ')'
static void * _invalid_group_parse(RuleDescr *);
void * _invalid_group_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_group", "'(' starred_expression ')' | '(' '**' expression ')'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_group_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__literal_var();
    static expr_ty _item_a();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // '(' starred_expression ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // starred_expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot use starred expression here");
    }
    static Token * _item__literal_var();
    static Token * _item_a();
    static expr_ty _item_expression_var();
    static Token * _item__literal_var_1();
    void * _alt_2(void) {  // '(' '**' expression ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '**'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot use double starred expression here");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'(' starred_expression ')'"},
        {_alt_2, "_alt_2", "'(' '**' expression ')'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
expr_ty _item_a(void) {
    return _starred_expression_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 35);   // token=**
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}

// invalid_import_from_targets: import_from_as_names ',' NEWLINE
static void * _invalid_import_from_targets_parse(RuleDescr *);
void * _invalid_import_from_targets_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_import_from_targets", "import_from_as_names ',' NEWLINE"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_import_from_targets_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_alias_seq* _item_import_from_as_names_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    void * _alt(void) {  // import_from_as_names ',' NEWLINE
        // import_from_as_names
        asdl_alias_seq* import_from_as_names_var;
        if (!(import_from_as_names_var = _item_import_from_as_names_var())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("trailing comma not allowed without surrounding parentheses");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "import_from_as_names ',' NEWLINE"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_alias_seq* _item_import_from_as_names_var(void) {
    return _import_from_as_names_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}

// invalid_with_stmt: [ASYNC] 'with' ','.(expression ['as' star_target])+
//     NEWLINE | [ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','?
//     ')' NEWLINE
static void * _invalid_with_stmt_parse(RuleDescr *);
void * _invalid_with_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_with_stmt", "[ASYNC] 'with' ','.(expression ['as' star_target])+ NEWLINE | [ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_with_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static Token * _item__keyword_var();
    static asdl_seq * _item__loop_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // [ASYNC] 'with' ','.(expression ['as'
    //     star_target])+ NEWLINE
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ','.(expression ['as' star_target])+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static ParseResult[Any] _item_opt_var();
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_seq * _item__loop_var();
    static ParseResult[Any] _item_opt_var_1();
    static Token * _item__literal_var_1();
    static Token * _item__newline_var();
    void * _alt_2(void) {  // [ASYNC] 'with' '(' ','.(expressions ['as'
    //     star_target])+ ','? ')' NEWLINE
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'with'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','.(expressions ['as' star_target])+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // ','?
        ParseResult[Any] opt_var_1;
        if ((opt_var_1 = (ParseResult[Any]) _item_opt_var_1()), p->error_indicator) return NULL;
        opt_var_1 = _item_opt_var_1();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "[ASYNC] 'with' ','.(expression ['as' star_target])+ NEWLINE"},
        {_alt_2, "_alt_2", "[ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // expression ['as' star_target]
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' star_target]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, opt_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression ['as' star_target]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_star_target_var();
    void * _alt(void) {  // 'as' star_target
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_target
        expr_ty star_target_var;
        if (!(star_target_var = _item_star_target_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, star_target_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_star_target_var(void) {
    return _star_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_expressions_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // expressions ['as' star_target]
        // expressions
        expr_ty expressions_var;
        if (!(expressions_var = _item_expressions_var())) return NULL;
        // ['as' star_target]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return _PyPegen_dummy_name(p, expressions_var, opt_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expressions ['as' star_target]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expressions_var(void) {
    return _expressions_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_star_target_var();
    void * _alt(void) {  // 'as' star_target
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_target
        expr_ty star_target_var;
        if (!(star_target_var = _item_star_target_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, star_target_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_star_target_var(void) {
    return _star_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var_1(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}

// invalid_with_stmt_indent: [ASYNC] 'with' ','.(expression ['as' star_target])+
//     ':' NEWLINE !INDENT | [ASYNC] 'with' '(' ','.(expressions ['as'
//     star_target])+ ','? ')' ':' NEWLINE !INDENT
static void * _invalid_with_stmt_indent_parse(RuleDescr *);
void * _invalid_with_stmt_indent_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_with_stmt_indent", "[ASYNC] 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT | [ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_with_stmt_indent_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static Token * _item_a();
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // [ASYNC] 'with' ','.(expression ['as'
    //     star_target])+ ':' NEWLINE !INDENT
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'with'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ','.(expression ['as' star_target])+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'with' statement on line %d" , a -> lineno);
    }
    static ParseResult[Any] _item_opt_var();
    static Token * _item_a();
    static Token * _item__literal_var();
    static asdl_seq * _item__loop_var();
    static ParseResult[Any] _item_opt_var_1();
    static Token * _item__literal_var_1();
    static Token * _item__literal_var_2();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // [ASYNC] 'with' '(' ','.(expressions ['as'
    //     star_target])+ ','? ')' ':' NEWLINE !INDENT
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'with'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // ','.(expressions ['as' star_target])+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // ','?
        ParseResult[Any] opt_var_1;
        if ((opt_var_1 = (ParseResult[Any]) _item_opt_var_1()), p->error_indicator) return NULL;
        opt_var_1 = _item_opt_var_1();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ':'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'with' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "[ASYNC] 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT"},
        {_alt_2, "_alt_2", "[ASYNC] 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // expression ['as' star_target]
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' star_target]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, opt_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression ['as' star_target]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_star_target_var();
    void * _alt(void) {  // 'as' star_target
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_target
        expr_ty star_target_var;
        if (!(star_target_var = _item_star_target_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, star_target_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_star_target_var(void) {
    return _star_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 612);   // keyword='with'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
void * _node(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static expr_ty _item_expressions_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // expressions ['as' star_target]
        // expressions
        expr_ty expressions_var;
        if (!(expressions_var = _item_expressions_var())) return NULL;
        // ['as' star_target]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return _PyPegen_dummy_name(p, expressions_var, opt_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expressions ['as' star_target]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expressions_var(void) {
    return _expressions_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_star_target_var();
    void * _alt(void) {  // 'as' star_target
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_target
        expr_ty star_target_var;
        if (!(star_target_var = _item_star_target_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, star_target_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' star_target"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_star_target_var(void) {
    return _star_target_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
ParseResult[Any] _item_opt_var_1(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_try_stmt: 'try' ':' NEWLINE !INDENT | 'try' ':' block !('except' |
//     'finally') | 'try' ':' block* except_block+ 'except' '*' expression ['as'
//     NAME] ':' | 'try' ':' block* except_star_block+ 'except' [expression
//     ['as' NAME]] ':'
static void * _invalid_try_stmt_parse(RuleDescr *);
void * _invalid_try_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_try_stmt", "'try' ':' NEWLINE !INDENT | 'try' ':' block !('except' | 'finally') | 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':' | 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_try_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // 'try' ':' NEWLINE !INDENT
        // 'try'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'try' statement on line %d" , a -> lineno);
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_stmt_seq* _item_block_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'try' ':' block !('except' | 'finally')
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block
        asdl_stmt_seq* block_var;
        if (!(block_var = _item_block_var())) return NULL;
        // !('except' | 'finally')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected 'except' or 'finally' block");
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_seq * _item__loop_var();
    static asdl_seq * _item__loop_var_1();
    static Token * _item_a();
    static Token * _item_b();
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_3(void) {  // 'try' ':' block* except_block+ 'except' '*'
    //     expression ['as' NAME] ':'
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // except_block+
        asdl_seq * _loop_var_1;
        if (!(_loop_var_1 = _item__loop_var_1())) return NULL;
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // '*'
        Token * b;
        if (!(b = _item_b())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (a , b , "cannot have both 'except' and 'except*' on the same 'try'");
    }
    static Token * _item__keyword_var();
    static Token * _item__literal_var();
    static asdl_seq * _item__loop_var();
    static asdl_seq * _item__loop_var_1();
    static Token * _item_a();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt_4(void) {  // 'try' ':' block* except_star_block+ 'except'
    //     [expression ['as' NAME]] ':'
        // 'try'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // block*
        asdl_seq * _loop_var;
        if ((_loop_var = (asdl_seq *) _item__loop_var()), p->error_indicator) return NULL;
        _loop_var = _item__loop_var();
        // except_star_block+
        asdl_seq * _loop_var_1;
        if (!(_loop_var_1 = _item__loop_var_1())) return NULL;
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // [expression ['as' NAME]]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot have both 'except' and 'except*' on the same 'try'");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'try' ':' NEWLINE !INDENT"},
        {_alt_2, "_alt_2", "'try' ':' block !('except' | 'finally')"},
        {_alt_3, "_alt_3", "'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'"},
        {_alt_4, "_alt_4", "'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_stmt_seq* _item_block_var(void) {
    return _block_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    void * _alt_1(void) {  // 'except'
        // 'except'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    static Token * _item__keyword_var();
    void * _alt_2(void) {  // 'finally'
        // 'finally'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // parse succeeded.
        return _keyword_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'except'"},
        {_alt_2, "_alt_2", "'finally'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 630);   // keyword='finally'
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
asdl_stmt_seq* _node(void) {
    return _block_rule(p);
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
excepthandler_ty _node(void) {
    return _except_block_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item_b(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 621);   // keyword='try'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, NULL, 0);
}
asdl_stmt_seq* _node(void) {
    return _block_rule(p);
}
asdl_seq * _item__loop_var_1(void) {
    return _PyPegen_loop(p, _node, NULL, 1);
}
excepthandler_ty _node(void) {
    return _except_star_block_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    void * _alt(void) {  // expression ['as' NAME]
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // parse succeeded.
        return _PyPegen_dummy_name(p, expression_var, opt_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "expression ['as' NAME]"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// invalid_except_stmt: 'except' '*'? expression ',' expressions ['as' NAME] ':'
//     | 'except' '*'? expression ['as' NAME] NEWLINE | 'except' NEWLINE |
//     'except' '*' (NEWLINE | ':')
static void * _invalid_except_stmt_parse(RuleDescr *);
void * _invalid_except_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_except_stmt", "'except' '*'? expression ',' expressions ['as' NAME] ':' | 'except' '*'? expression ['as' NAME] NEWLINE | 'except' NEWLINE | 'except' '*' (NEWLINE | ':')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_except_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static ParseResult[Any] _item_opt_var();
    static expr_ty _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_expressions_var();
    static ParseResult[Any] _item_opt_var_1();
    static Token * _item__literal_var_1();
    void * _alt_1(void) {  // 'except' '*'? expression ',' expressions ['as'
    //     NAME] ':'
        // 'except'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // '*'?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expressions
        expr_ty expressions_var;
        if (!(expressions_var = _item_expressions_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var_1;
        if ((opt_var_1 = (ParseResult[Any]) _item_opt_var_1()), p->error_indicator) return NULL;
        opt_var_1 = _item_opt_var_1();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_STARTING_FROM (a , "multiple exception types must be parenthesized");
    }
    static Token * _item_a();
    static ParseResult[Any] _item_opt_var();
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var_1();
    static Token * _item__newline_var();
    void * _alt_2(void) {  // 'except' '*'? expression ['as' NAME] NEWLINE
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // '*'?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var_1;
        if ((opt_var_1 = (ParseResult[Any]) _item_opt_var_1()), p->error_indicator) return NULL;
        opt_var_1 = _item_opt_var_1();
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static Token * _item__newline_var();
    void * _alt_3(void) {  // 'except' NEWLINE
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static Token * _item__literal_var();
    static void * _item__group_var();
    void * _alt_4(void) {  // 'except' '*' (NEWLINE | ':')
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // (NEWLINE | ':')
        void * _group_var;
        if (!(_group_var = _item__group_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected one or more exception types");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'except' '*'? expression ',' expressions ['as' NAME] ':'"},
        {_alt_2, "_alt_2", "'except' '*'? expression ['as' NAME] NEWLINE"},
        {_alt_3, "_alt_3", "'except' NEWLINE"},
        {_alt_4, "_alt_4", "'except' '*' (NEWLINE | ':')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
expr_ty _item_expressions_var(void) {
    return _expressions_rule(p);
}
ParseResult[Any] _item_opt_var_1(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
Token * _item(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var_1(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
void * _item__group_var(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__newline_var();
    void * _alt_1(void) {  // NEWLINE
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return _newline_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "NEWLINE"},
        {_alt_2, "_alt_2", "':'"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}

// invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT
static void * _invalid_finally_stmt_parse(RuleDescr *);
void * _invalid_finally_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_finally_stmt", "'finally' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_finally_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt(void) {  // 'finally' ':' NEWLINE !INDENT
        // 'finally'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'finally' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'finally' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 630);   // keyword='finally'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_except_stmt_indent: 'except' expression ['as' NAME] ':' NEWLINE
//     !INDENT | 'except' ':' NEWLINE !INDENT
static void * _invalid_except_stmt_indent_parse(RuleDescr *);
void * _invalid_except_stmt_indent_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_except_stmt_indent", "'except' expression ['as' NAME] ':' NEWLINE !INDENT | 'except' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_except_stmt_indent_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // 'except' expression ['as' NAME] ':' NEWLINE
    //     !INDENT
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'except' statement on line %d" , a -> lineno);
    }
    static Token * _item_a();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'except' ':' NEWLINE !INDENT
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'except' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'except' expression ['as' NAME] ':' NEWLINE !INDENT"},
        {_alt_2, "_alt_2", "'except' ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_except_star_stmt_indent: 'except' '*' expression ['as' NAME] ':'
//     NEWLINE !INDENT
static void * _invalid_except_star_stmt_indent_parse(RuleDescr *);
void * _invalid_except_star_stmt_indent_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_except_star_stmt_indent", "'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_except_star_stmt_indent_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static Token * _item__literal_var();
    static expr_ty _item_expression_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt(void) {  // 'except' '*' expression ['as' NAME] ':' NEWLINE
    //     !INDENT
        // 'except'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // '*'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ['as' NAME]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'except*' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 634);   // keyword='except'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    void * _alt(void) {  // 'as' NAME
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _keyword_var, NAME_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'as' NAME"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_match_stmt: "match" subject_expr NEWLINE | "match" subject_expr ':'
//     NEWLINE !INDENT
static void * _invalid_match_stmt_parse(RuleDescr *);
void * _invalid_match_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_match_stmt", "\"match\" subject_expr NEWLINE | \"match\" subject_expr ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_match_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item__keyword_var();
    static expr_ty _item_subject_expr_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // "match" subject_expr NEWLINE
        // "match"
        expr_ty _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // subject_expr
        expr_ty subject_expr_var;
        if (!(subject_expr_var = _item_subject_expr_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return CHECK_VERSION (void* , 10 , "Pattern matching is" , RAISE_SYNTAX_ERROR ("expected ':'"));
    }
    static expr_ty _item_a();
    static expr_ty _item_subject();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // "match" subject_expr ':' NEWLINE !INDENT
        // "match"
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // subject_expr
        expr_ty subject;
        if (!(subject = _item_subject())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'match' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "\"match\" subject_expr NEWLINE"},
        {_alt_2, "_alt_2", "\"match\" subject_expr ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item__keyword_var(void) {
    return _PyPegen_expect_soft_keyword(p, "match");   // keyword='match'
}
expr_ty _item_subject_expr_var(void) {
    return _subject_expr_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
expr_ty _item_a(void) {
    return _PyPegen_expect_soft_keyword(p, "match");   // keyword='match'
}
expr_ty _item_subject(void) {
    return _subject_expr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_case_block: "case" patterns guard? NEWLINE | "case" patterns guard?
//     ':' NEWLINE !INDENT
static void * _invalid_case_block_parse(RuleDescr *);
void * _invalid_case_block_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_case_block", "\"case\" patterns guard? NEWLINE | \"case\" patterns guard? ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_case_block_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item__keyword_var();
    static pattern_ty _item_patterns_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // "case" patterns guard? NEWLINE
        // "case"
        expr_ty _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // patterns
        pattern_ty patterns_var;
        if (!(patterns_var = _item_patterns_var())) return NULL;
        // guard?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static expr_ty _item_a();
    static pattern_ty _item_patterns_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // "case" patterns guard? ':' NEWLINE !INDENT
        // "case"
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // patterns
        pattern_ty patterns_var;
        if (!(patterns_var = _item_patterns_var())) return NULL;
        // guard?
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'case' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "\"case\" patterns guard? NEWLINE"},
        {_alt_2, "_alt_2", "\"case\" patterns guard? ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item__keyword_var(void) {
    return _PyPegen_expect_soft_keyword(p, "case");   // keyword='case'
}
pattern_ty _item_patterns_var(void) {
    return _patterns_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _guard_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
expr_ty _item_a(void) {
    return _PyPegen_expect_soft_keyword(p, "case");   // keyword='case'
}
pattern_ty _item_patterns_var(void) {
    return _patterns_rule(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
expr_ty _item(void) {
    return _guard_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_as_pattern: or_pattern 'as' "_" | or_pattern 'as' !NAME expression
static void * _invalid_as_pattern_parse(RuleDescr *);
void * _invalid_as_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_as_pattern", "or_pattern 'as' \"_\" | or_pattern 'as' !NAME expression"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_as_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static pattern_ty _item_or_pattern_var();
    static Token * _item__keyword_var();
    static expr_ty _item_a();
    void * _alt_1(void) {  // or_pattern 'as' "_"
        // or_pattern
        pattern_ty or_pattern_var;
        if (!(or_pattern_var = _item_or_pattern_var())) return NULL;
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // "_"
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "cannot use '_' as a target");
    }
    static pattern_ty _item_or_pattern_var();
    static Token * _item__keyword_var();
    static int _item__lookahead_var();
    static expr_ty _item_a();
    void * _alt_2(void) {  // or_pattern 'as' !NAME expression
        // or_pattern
        pattern_ty or_pattern_var;
        if (!(or_pattern_var = _item_or_pattern_var())) return NULL;
        // 'as'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // !NAME
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "invalid pattern target");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "or_pattern 'as' \"_\""},
        {_alt_2, "_alt_2", "or_pattern 'as' !NAME expression"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
pattern_ty _item_or_pattern_var(void) {
    return _or_pattern_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
expr_ty _item_a(void) {
    return _PyPegen_expect_soft_keyword(p, "_");   // keyword='_'
}
pattern_ty _item_or_pattern_var(void) {
    return _or_pattern_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 637);   // keyword='as'
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
expr_ty atom(void) {
    return _PyPegen_name_token(p);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}

// invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern
static void * _invalid_class_pattern_parse(RuleDescr *);
void * _invalid_class_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_class_pattern", "name_or_attr '(' invalid_class_argument_pattern"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_class_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_name_or_attr_var();
    static Token * _item__literal_var();
    static asdl_pattern_seq* _item_a();
    void * _alt(void) {  // name_or_attr '(' invalid_class_argument_pattern
        // name_or_attr
        expr_ty name_or_attr_var;
        if (!(name_or_attr_var = _item_name_or_attr_var())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // invalid_class_argument_pattern
        asdl_pattern_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_RANGE (PyPegen_first_item (a , pattern_ty) , PyPegen_last_item (a , pattern_ty) , "positional patterns follow keyword patterns");
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "name_or_attr '(' invalid_class_argument_pattern"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_name_or_attr_var(void) {
    return _name_or_attr_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
asdl_pattern_seq* _item_a(void) {
    return _invalid_class_argument_pattern_rule(p);
}

// invalid_class_argument_pattern: [positional_patterns ','] keyword_patterns
//     ',' positional_patterns
static void * _invalid_class_argument_pattern_parse(RuleDescr *);
asdl_pattern_seq* _invalid_class_argument_pattern_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_class_argument_pattern", "[positional_patterns ','] keyword_patterns ',' positional_patterns"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_class_argument_pattern_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static asdl_seq* _item_keyword_patterns_var();
    static Token * _item__literal_var();
    static asdl_pattern_seq* _item_a();
    void * _alt(void) {  // [positional_patterns ','] keyword_patterns ','
    //     positional_patterns
        // [positional_patterns ',']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // keyword_patterns
        asdl_seq* keyword_patterns_var;
        if (!(keyword_patterns_var = _item_keyword_patterns_var())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // positional_patterns
        asdl_pattern_seq* a;
        if (!(a = _item_a())) return NULL;
        // parse succeeded.
        return a;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "[positional_patterns ','] keyword_patterns ',' positional_patterns"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static asdl_pattern_seq* _item_positional_patterns_var();
    static Token * _item__literal_var();
    void * _alt(void) {  // positional_patterns ','
        // positional_patterns
        asdl_pattern_seq* positional_patterns_var;
        if (!(positional_patterns_var = _item_positional_patterns_var())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, positional_patterns_var, _literal_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "positional_patterns ','"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
asdl_pattern_seq* _item_positional_patterns_var(void) {
    return _positional_patterns_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_seq* _item_keyword_patterns_var(void) {
    return _keyword_patterns_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
asdl_pattern_seq* _item_a(void) {
    return _positional_patterns_rule(p);
}

// invalid_if_stmt: 'if' named_expression NEWLINE | 'if' named_expression ':'
//     NEWLINE !INDENT
static void * _invalid_if_stmt_parse(RuleDescr *);
void * _invalid_if_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_if_stmt", "'if' named_expression NEWLINE | 'if' named_expression ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_if_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_named_expression_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // 'if' named_expression NEWLINE
        // 'if'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static expr_ty _item_named_expression_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'if' named_expression ':' NEWLINE !INDENT
        // 'if'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'if' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'if' named_expression NEWLINE"},
        {_alt_2, "_alt_2", "'if' named_expression ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 639);   // keyword='if'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_elif_stmt: 'elif' named_expression NEWLINE | 'elif' named_expression
//     ':' NEWLINE !INDENT
static void * _invalid_elif_stmt_parse(RuleDescr *);
void * _invalid_elif_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_elif_stmt", "'elif' named_expression NEWLINE | 'elif' named_expression ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_elif_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_named_expression_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // 'elif' named_expression NEWLINE
        // 'elif'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static expr_ty _item_named_expression_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'elif' named_expression ':' NEWLINE !INDENT
        // 'elif'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'elif' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'elif' named_expression NEWLINE"},
        {_alt_2, "_alt_2", "'elif' named_expression ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 641);   // keyword='elif'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 641);   // keyword='elif'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_else_stmt: 'else' ':' NEWLINE !INDENT
static void * _invalid_else_stmt_parse(RuleDescr *);
void * _invalid_else_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_else_stmt", "'else' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_else_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item_a();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt(void) {  // 'else' ':' NEWLINE !INDENT
        // 'else'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'else' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'else' ':' NEWLINE !INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 642);   // keyword='else'
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_while_stmt: 'while' named_expression NEWLINE | 'while'
//     named_expression ':' NEWLINE !INDENT
static void * _invalid_while_stmt_parse(RuleDescr *);
void * _invalid_while_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_while_stmt", "'while' named_expression NEWLINE | 'while' named_expression ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_while_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_named_expression_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // 'while' named_expression NEWLINE
        // 'while'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static expr_ty _item_named_expression_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'while' named_expression ':' NEWLINE !INDENT
        // 'while'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // named_expression
        expr_ty named_expression_var;
        if (!(named_expression_var = _item_named_expression_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'while' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'while' named_expression NEWLINE"},
        {_alt_2, "_alt_2", "'while' named_expression ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 644);   // keyword='while'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 644);   // keyword='while'
}
expr_ty _item_named_expression_var(void) {
    return _named_expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_for_stmt: [ASYNC] 'for' star_targets 'in' star_expressions NEWLINE |
//     [ASYNC] 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
static void * _invalid_for_stmt_parse(RuleDescr *);
void * _invalid_for_stmt_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_for_stmt", "[ASYNC] 'for' star_targets 'in' star_expressions NEWLINE | [ASYNC] 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_for_stmt_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static Token * _item__keyword_var();
    static expr_ty _item_star_targets_var();
    static Token * _item__keyword_var_1();
    static expr_ty _item_star_expressions_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // [ASYNC] 'for' star_targets 'in' star_expressions
    //     NEWLINE
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'for'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_targets
        expr_ty star_targets_var;
        if (!(star_targets_var = _item_star_targets_var())) return NULL;
        // 'in'
        Token * _keyword_var_1;
        if (!(_keyword_var_1 = _item__keyword_var_1())) return NULL;
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static ParseResult[Any] _item_opt_var();
    static Token * _item_a();
    static expr_ty _item_star_targets_var();
    static Token * _item__keyword_var();
    static expr_ty _item_star_expressions_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // [ASYNC] 'for' star_targets 'in' star_expressions
    //     ':' NEWLINE !INDENT
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'for'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // star_targets
        expr_ty star_targets_var;
        if (!(star_targets_var = _item_star_targets_var())) return NULL;
        // 'in'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // star_expressions
        expr_ty star_expressions_var;
        if (!(star_expressions_var = _item_star_expressions_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after 'for' statement on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "[ASYNC] 'for' star_targets 'in' star_expressions NEWLINE"},
        {_alt_2, "_alt_2", "[ASYNC] 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_star_targets_var(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var_1(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 647);   // keyword='for'
}
expr_ty _item_star_targets_var(void) {
    return _star_targets_rule(p);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 648);   // keyword='in'
}
expr_ty _item_star_expressions_var(void) {
    return _star_expressions_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_def_raw: [ASYNC] 'def' NAME '(' [params] ')' ['->' expression] ':'
//     NEWLINE !INDENT
static void * _invalid_def_raw_parse(RuleDescr *);
void * _invalid_def_raw_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_def_raw", "[ASYNC] 'def' NAME '(' [params] ')' ['->' expression] ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_def_raw_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static ParseResult[Any] _item_opt_var();
    static Token * _item_a();
    static expr_ty _item_NAME_var();
    static Token * _item__literal_var();
    static ParseResult[Any] _item_opt_var_1();
    static Token * _item__literal_var_1();
    static ParseResult[Any] _item_opt_var_2();
    static Token * _item__literal_var_2();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt(void) {  // [ASYNC] 'def' NAME '(' [params] ')' ['->'
    //     expression] ':' NEWLINE !INDENT
        // [ASYNC]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // 'def'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [params]
        ParseResult[Any] opt_var_1;
        if ((opt_var_1 = (ParseResult[Any]) _item_opt_var_1()), p->error_indicator) return NULL;
        opt_var_1 = _item_opt_var_1();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // ['->' expression]
        ParseResult[Any] opt_var_2;
        if ((opt_var_2 = (ParseResult[Any]) _item_opt_var_2()), p->error_indicator) return NULL;
        opt_var_2 = _item_opt_var_2();
        // ':'
        Token * _literal_var_2;
        if (!(_literal_var_2 = _item__literal_var_2())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after function definition on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "[ASYNC] 'def' NAME '(' [params] ')' ['->' expression] ':' NEWLINE !INDENT"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__async_var();
    void * _alt(void) {  // ASYNC
        // ASYNC
        Token * _async_var;
        if (!(_async_var = _item__async_var())) return NULL;
        // parse succeeded.
        return _async_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "ASYNC"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__async_var(void) {
    return _PyPegen_expect_token(p, 56);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 649);   // keyword='def'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_opt_var_1(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static arguments_ty _item_params_var();
    void * _alt(void) {  // params
        // params
        arguments_ty params_var;
        if (!(params_var = _item_params_var())) return NULL;
        // parse succeeded.
        return params_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "params"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
arguments_ty _item_params_var(void) {
    return _params_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
ParseResult[Any] _item_opt_var_2(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static expr_ty _item_expression_var();
    void * _alt(void) {  // '->' expression
        // '->'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, expression_var);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'->' expression"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 51);   // token=->
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__literal_var_2(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_class_def_raw: 'class' NAME ['(' [arguments] ')'] NEWLINE | 'class'
//     NAME ['(' [arguments] ')'] ':' NEWLINE !INDENT
static void * _invalid_class_def_raw_parse(RuleDescr *);
void * _invalid_class_def_raw_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_class_def_raw", "'class' NAME ['(' [arguments] ')'] NEWLINE | 'class' NAME ['(' [arguments] ')'] ':' NEWLINE !INDENT"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_class_def_raw_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static Token * _item__keyword_var();
    static expr_ty _item_NAME_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__newline_var();
    void * _alt_1(void) {  // 'class' NAME ['(' [arguments] ')'] NEWLINE
        // 'class'
        Token * _keyword_var;
        if (!(_keyword_var = _item__keyword_var())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // ['(' [arguments] ')']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR ("expected ':'");
    }
    static Token * _item_a();
    static expr_ty _item_NAME_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var();
    static Token * _item__newline_var();
    static int _item__lookahead_var();
    void * _alt_2(void) {  // 'class' NAME ['(' [arguments] ')'] ':' NEWLINE
    //     !INDENT
        // 'class'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // NAME
        expr_ty NAME_var;
        if (!(NAME_var = _item_NAME_var())) return NULL;
        // ['(' [arguments] ')']
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // NEWLINE
        Token * _newline_var;
        if (!(_newline_var = _item__newline_var())) return NULL;
        // !INDENT
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_INDENTATION_ERROR ("expected an indented block after class definition on line %d" , a -> lineno);
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'class' NAME ['(' [arguments] ')'] NEWLINE"},
        {_alt_2, "_alt_2", "'class' NAME ['(' [arguments] ')'] ':' NEWLINE !INDENT"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__keyword_var(void) {
    return _PyPegen_expect_token(p, 651);   // keyword='class'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '(' [arguments] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [arguments]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, opt_var, _literal_var_1);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' [arguments] ')'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_arguments_var();
    void * _alt(void) {  // arguments
        // arguments
        expr_ty arguments_var;
        if (!(arguments_var = _item_arguments_var())) return NULL;
        // parse succeeded.
        return arguments_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "arguments"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arguments_var(void) {
    return _arguments_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 651);   // keyword='class'
}
expr_ty _item_NAME_var(void) {
    return _PyPegen_name_token(p);
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static Token * _item__literal_var();
    static ParseResult[Any] _item_opt_var();
    static Token * _item__literal_var_1();
    void * _alt(void) {  // '(' [arguments] ')'
        // '('
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // [arguments]
        ParseResult[Any] opt_var;
        if ((opt_var = (ParseResult[Any]) _item_opt_var()), p->error_indicator) return NULL;
        opt_var = _item_opt_var();
        // ')'
        Token * _literal_var_1;
        if (!(_literal_var_1 = _item__literal_var_1())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _literal_var, opt_var, _literal_var_1);
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "'(' [arguments] ')'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 7);   // token=(
}
ParseResult[Any] _item_opt_var(void) {
    return _PyPegen_opt(p, _item);
}
void * _item(void) {
    static expr_ty _item_arguments_var();
    void * _alt(void) {  // arguments
        // arguments
        expr_ty arguments_var;
        if (!(arguments_var = _item_arguments_var())) return NULL;
        // parse succeeded.
        return arguments_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "arguments"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
expr_ty _item_arguments_var(void) {
    return _arguments_rule(p);
}
Token * _item__literal_var_1(void) {
    return _PyPegen_expect_token(p, 8);   // token=)
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item__newline_var(void) {
    return _PyPegen_expect_token(p, 4);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
Token * atom(void) {
    return _PyPegen_expect_token(p, 5);
}

// invalid_double_starred_kvpairs: ','.double_starred_kvpair+ ',' invalid_kvpair
//     | expression ':' '*' bitwise_or | expression ':' &('}' | ',')
static void * _invalid_double_starred_kvpairs_parse(RuleDescr *);
void * _invalid_double_starred_kvpairs_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_double_starred_kvpairs", "','.double_starred_kvpair+ ',' invalid_kvpair | expression ':' '*' bitwise_or | expression ':' &('}' | ',')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_double_starred_kvpairs_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static asdl_seq * _item__loop_var();
    static Token * _item__literal_var();
    static void * _item_invalid_kvpair_var();
    void * _alt_1(void) {  // ','.double_starred_kvpair+ ',' invalid_kvpair
        // ','.double_starred_kvpair+
        asdl_seq * _loop_var;
        if (!(_loop_var = _item__loop_var())) return NULL;
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // invalid_kvpair
        void * invalid_kvpair_var;
        if (!(invalid_kvpair_var = _item_invalid_kvpair_var())) return NULL;
        // parse succeeded.
        return _PyPegen_dummy_name(p, _loop_var, _literal_var, invalid_kvpair_var);
    }
    static expr_ty _item_expression_var();
    static Token * _item__literal_var();
    static Token * _item_a();
    static expr_ty _item_bitwise_or_var();
    void * _alt_2(void) {  // expression ':' '*' bitwise_or
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // bitwise_or
        expr_ty bitwise_or_var;
        if (!(bitwise_or_var = _item_bitwise_or_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_STARTING_FROM (a , "cannot use a starred expression in a dictionary value");
    }
    static expr_ty _item_expression_var();
    static Token * _item_a();
    static int _item__lookahead_var();
    void * _alt_3(void) {  // expression ':' &('}' | ',')
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ':'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // &('}' | ',')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "expression expected after dictionary key and ':'");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "','.double_starred_kvpair+ ',' invalid_kvpair"},
        {_alt_2, "_alt_2", "expression ':' '*' bitwise_or"},
        {_alt_3, "_alt_3", "expression ':' &('}' | ',')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
asdl_seq * _item__loop_var(void) {
    return _PyPegen_loop(p, _node, sep, 1);
}
KeyValuePair* _node(void) {
    return _double_starred_kvpair_rule(p);
}
Token * sep(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}
void * _item_invalid_kvpair_var(void) {
    return _invalid_kvpair_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_bitwise_or_var(void) {
    return _bitwise_or_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '}'
        // '}'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'}'"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

// invalid_kvpair: expression !(':') | expression ':' '*' bitwise_or |
//     expression ':' &('}' | ',')
static void * _invalid_kvpair_parse(RuleDescr *);
void * _invalid_kvpair_rule(Parser *p) {  // {}
    RuleDescr _rule_descriptor =
        {_rule, "invalid_kvpair", "expression !(':') | expression ':' '*' bitwise_or | expression ':' &('}' | ',')"};
    return _PyPegen_parse_rule(p, &_rule_descriptor);
}
void * _invalid_kvpair_parse(void) {  // {}
    return _rhs();
}
void * _rhs(void) {
    static expr_ty _item_a();
    static int _item__lookahead_var();
    void * _alt_1(void) {  // expression !(':')
        // expression
        expr_ty a;
        if (!(a = _item_a())) return NULL;
        // !(':')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_ERROR_KNOWN_LOCATION (p , PyExc_SyntaxError , a -> lineno , a -> end_col_offset - 1 , a -> end_lineno , - 1 , "':' expected after dictionary key");
    }
    static expr_ty _item_expression_var();
    static Token * _item__literal_var();
    static Token * _item_a();
    static expr_ty _item_bitwise_or_var();
    void * _alt_2(void) {  // expression ':' '*' bitwise_or
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // '*'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // bitwise_or
        expr_ty bitwise_or_var;
        if (!(bitwise_or_var = _item_bitwise_or_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_STARTING_FROM (a , "cannot use a starred expression in a dictionary value");
    }
    static expr_ty _item_expression_var();
    static Token * _item_a();
    static int _item__lookahead_var();
    void * _alt_3(void) {  // expression ':' &('}' | ',')
        // expression
        expr_ty expression_var;
        if (!(expression_var = _item_expression_var())) return NULL;
        // ':'
        Token * a;
        if (!(a = _item_a())) return NULL;
        // &('}' | ',')
        int _lookahead_var;
        if (!(_lookahead_var = _item__lookahead_var())) return NULL;
        // parse succeeded.
        return RAISE_SYNTAX_ERROR_KNOWN_LOCATION (a , "expression expected after dictionary key and ':'");
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "expression !(':')"},
        {_alt_2, "_alt_2", "expression ':' '*' bitwise_or"},
        {_alt_3, "_alt_3", "expression ':' &('}' | ',')"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
expr_ty _item_a(void) {
    return _expression_rule(p);
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 0, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt(void) {  // ':'
        // ':'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptor =
        {_alt, "_alt", "':'"};
    return _PyPegen_parse_alt(p, &_alt_descriptor);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 16);   // token=*
}
expr_ty _item_bitwise_or_var(void) {
    return _bitwise_or_rule(p);
}
expr_ty _item_expression_var(void) {
    return _expression_rule(p);
}
Token * _item_a(void) {
    return _PyPegen_expect_token(p, 11);   // token=:
}
int _item__lookahead_var(void) {
    return _PyPegen_expect_lookahead(p, 1, atom);
}
void * atom(void) {
    return _PyPegen_group(p, _rhs);
}
void * _rhs(void) {
    static Token * _item__literal_var();
    void * _alt_1(void) {  // '}'
        // '}'
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    static Token * _item__literal_var();
    void * _alt_2(void) {  // ','
        // ','
        Token * _literal_var;
        if (!(_literal_var = _item__literal_var())) return NULL;
        // parse succeeded.
        return _literal_var;
    }
    RuleAltDescr _alt_descriptors[] = {
        {_alt_1, "_alt_1", "'}'"},
        {_alt_2, "_alt_2", "','"},
    };
    return _PyPegen_parse_alt_array(p, _alt_descriptors);
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 26);   // token=}
}
Token * _item__literal_var(void) {
    return _PyPegen_expect_token(p, 12);   // token=,
}

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;
    p->soft_keywords = soft_keywords;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_func_type_input) {
        result = func_type_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}
