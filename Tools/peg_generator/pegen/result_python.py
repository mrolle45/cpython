#!/usr/bin/env python3.8
# @generated by pegen from test.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional, Callable, cast

from pegen.parser import (
    memoize, memoize_left_rec, logger, Parser, ParseResult
    )
from ast import literal_eval

from pegen.grammar import (
    Alt,
    Cut,
    Forced,
    Gather,
    Grammar,
    Group,
    Item,
    Lookahead,
    LookaheadOrCut,
    MetaTuple,
    MetaList,
    NameLeaf,
    VarItem,
    NamedItemList,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    RuleList,
    RuleName,
    RuleParams,
    StringLeaf,
    TypedName,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    # xxxx [int] (__p1: int, __p2: char): <always>
    def xxxx(self, __p1: int, __p2: char) -> ParseResult[int]:
        def _rhs() -> ParseResult[int]:

            # <always>
            def _alt() -> ParseResult[int]:

                # parse succeeded
                return 1,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # r (): ('y' | 'z') rr
    def r(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # ('y' | 'z') rr
            def _alt() -> ParseResult[Any]:

                # ('y' | 'z')
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # 'y'
                        def _alt1() -> ParseResult[Any]:

                            # 'y'
                            def _item__keyword() -> ParseResult[Token]:
                                return self._expect_type(500)   # keyword = 'y'
                            _keyword: Token; _result__keyword: ParseResult[Token]
                            _result__keyword = _item__keyword()
                            if not _result__keyword: return None
                            _keyword, = _result__keyword

                            # parse succeeded
                            return _keyword,

                        # 'z'
                        def _alt2() -> ParseResult[Any]:

                            # 'z'
                            def _item__keyword() -> ParseResult[Token]:
                                return self._expect_type(501)   # keyword = 'z'
                            _keyword: Token; _result__keyword: ParseResult[Token]
                            _result__keyword = _item__keyword()
                            if not _result__keyword: return None
                            _keyword, = _result__keyword

                            # parse succeeded
                            return _keyword,

                        _alts = [
                            _alt1,
                            _alt2,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # rr
                def _item__rr() -> ParseResult[str]:
                    return self.rr()
                _rr: str; _result__rr: ParseResult[str]
                _result__rr = _item__rr()
                if not _result__rr: return None
                _rr, = _result__rr

                # parse succeeded
                return [_group, _rr],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rr [str] (): ('x' | 'y' | 'z')
    def rr(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:

            # ('x' | 'y' | 'z')
            def _alt() -> ParseResult[str]:

                # ('x' | 'y' | 'z')
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # 'x'
                        def _alt1() -> ParseResult[Any]:

                            # 'x'
                            def _item__keyword() -> ParseResult[Token]:
                                return self._expect_type(502)   # keyword = 'x'
                            _keyword: Token; _result__keyword: ParseResult[Token]
                            _result__keyword = _item__keyword()
                            if not _result__keyword: return None
                            _keyword, = _result__keyword

                            # parse succeeded
                            return _keyword,

                        # 'y'
                        def _alt2() -> ParseResult[Any]:

                            # 'y'
                            def _item__keyword() -> ParseResult[Token]:
                                return self._expect_type(500)   # keyword = 'y'
                            _keyword: Token; _result__keyword: ParseResult[Token]
                            _result__keyword = _item__keyword()
                            if not _result__keyword: return None
                            _keyword, = _result__keyword

                            # parse succeeded
                            return _keyword,

                        # 'z'
                        def _alt3() -> ParseResult[Any]:

                            # 'z'
                            def _item__keyword() -> ParseResult[Token]:
                                return self._expect_type(501)   # keyword = 'z'
                            _keyword: Token; _result__keyword: ParseResult[Token]
                            _result__keyword = _item__keyword()
                            if not _result__keyword: return None
                            _keyword, = _result__keyword

                            # parse succeeded
                            return _keyword,

                        _alts = [
                            _alt1,
                            _alt2,
                            _alt3,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # parse succeeded
                return _group,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # r1 (): r2 | (r3 | r4)
    # Left-recursive leader
    @memoize_left_rec
    def r1(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # r2
            def _alt1() -> ParseResult[Any]:

                # r2
                def _item__r2() -> ParseResult[Any]:
                    return self.r2()
                _r2: Any; _result__r2: ParseResult[Any]
                _result__r2 = _item__r2()
                if not _result__r2: return None
                _r2, = _result__r2

                # parse succeeded
                return _r2,

            # (r3 | r4)
            def _alt2() -> ParseResult[Any]:

                # (r3 | r4)
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # r3
                        def _alt1() -> ParseResult[Any]:

                            # r3
                            def _item__r3() -> ParseResult[Any]:
                                return self.r3()
                            _r3: Any; _result__r3: ParseResult[Any]
                            _result__r3 = _item__r3()
                            if not _result__r3: return None
                            _r3, = _result__r3

                            # parse succeeded
                            return _r3,

                        # r4
                        def _alt2() -> ParseResult[Any]:

                            # r4
                            def _item__r4() -> ParseResult[Any]:
                                return self.r4()
                            _r4: Any; _result__r4: ParseResult[Any]
                            _result__r4 = _item__r4()
                            if not _result__r4: return None
                            _r4, = _result__r4

                            # parse succeeded
                            return _r4,

                        _alts = [
                            _alt1,
                            _alt2,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # parse succeeded
                return _group,

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # r2 (): [r3]
    # Left-recursive
    @logger
    def r2(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # [r3]
            def _alt() -> ParseResult[Any]:

                # [r3]
                def _item__opt() -> ParseResult[list[Any]]:
                    def _rhs() -> ParseResult[Any]:

                        # r3
                        def _alt() -> ParseResult[Any]:

                            # r3
                            def _item__r3() -> ParseResult[Any]:
                                return self.r3()
                            _r3: Any; _result__r3: ParseResult[Any]
                            _result__r3 = _item__r3()
                            if not _result__r3: return None
                            _r3, = _result__r3

                            # parse succeeded
                            return _r3,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return self._opt(_rhs)
                _opt: list[Any]
                _opt, = _item__opt()

                # parse succeeded
                return _opt,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # r3 (): r4
    # Left-recursive
    @logger
    def r3(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # r4
            def _alt() -> ParseResult[Any]:

                # r4
                def _item__r4() -> ParseResult[Any]:
                    return self.r4()
                _r4: Any; _result__r4: ParseResult[Any]
                _result__r4 = _item__r4()
                if not _result__r4: return None
                _r4, = _result__r4

                # parse succeeded
                return _r4,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # r4 (): r1
    # Left-recursive
    @logger
    def r4(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # r1
            def _alt() -> ParseResult[Any]:

                # r1
                def _item__r1() -> ParseResult[Any]:
                    return self.r1()
                _r1: Any; _result__r1: ParseResult[Any]
                _result__r1 = _item__r1()
                if not _result__r1: return None
                _r1, = _result__r1

                # parse succeeded
                return _r1,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar97 (a): (STRING) NAME NAME
    def bar97(self, a) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # (STRING) NAME NAME
            def _alt() -> ParseResult[Any]:

                # (STRING)
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # STRING
                        def _alt() -> ParseResult[Any]:

                            # a=STRING
                            def _item_a() -> ParseResult[Token]:
                                return self._string()
                            a: Token; _result_a: ParseResult[Token]
                            _result_a = _item_a()
                            if not _result_a: return None
                            a, = _result_a

                            # parse succeeded
                            return a,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # a=NAME
                def _item_a() -> ParseResult[Token]:
                    return self._name()
                a: Token; _result_a: ParseResult[Token]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # b=NAME
                def _item_b() -> ParseResult[Token]:
                    return self._name()
                b: Token; _result_b: ParseResult[Token]
                _result_b = _item_b()
                if not _result_b: return None
                b, = _result_b

                # parse succeeded
                return [_group, a, b],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # x [_x_type] (): (DEDENT NAME | TYPE_COMMENT) NEWLINE NUMBER STRING
    def x(self) -> ParseResult[_x_type]:
        def _rhs() -> ParseResult[_x_type]:

            # (DEDENT NAME | TYPE_COMMENT) NEWLINE NUMBER STRING
            def _alt() -> ParseResult[_x_type]:

                # (DEDENT NAME | TYPE_COMMENT)
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # DEDENT NAME
                        def _alt1() -> ParseResult[Any]:

                            # DEDENT
                            def _item__DEDENT() -> ParseResult[Token]:
                                return self._expect_type(6)
                            _DEDENT: Token; _result__DEDENT: ParseResult[Token]
                            _result__DEDENT = _item__DEDENT()
                            if not _result__DEDENT: return None
                            _DEDENT, = _result__DEDENT

                            # NAME
                            def _item__NAME() -> ParseResult[Token]:
                                return self._name()
                            _NAME: Token; _result__NAME: ParseResult[Token]
                            _result__NAME = _item__NAME()
                            if not _result__NAME: return None
                            _NAME, = _result__NAME

                            # parse succeeded
                            return [_DEDENT, _NAME],

                        # TYPE_COMMENT
                        def _alt2() -> ParseResult[Any]:

                            # TYPE_COMMENT
                            def _item__TYPE_COMMENT() -> ParseResult[Token]:
                                return self._type_comment()
                            _TYPE_COMMENT: Token; _result__TYPE_COMMENT: ParseResult[Token]
                            _result__TYPE_COMMENT = _item__TYPE_COMMENT()
                            if not _result__TYPE_COMMENT: return None
                            _TYPE_COMMENT, = _result__TYPE_COMMENT

                            # parse succeeded
                            return _TYPE_COMMENT,

                        _alts = [
                            _alt1,
                            _alt2,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # NUMBER
                def _item__NUMBER() -> ParseResult[Token]:
                    return self._number()
                _NUMBER: Token; _result__NUMBER: ParseResult[Token]
                _result__NUMBER = _item__NUMBER()
                if not _result__NUMBER: return None
                _NUMBER, = _result__NUMBER

                # STRING
                def _item__STRING() -> ParseResult[Token]:
                    return self._string()
                _STRING: Token; _result__STRING: ParseResult[Token]
                _result__STRING = _item__STRING()
                if not _result__STRING: return None
                _STRING, = _result__STRING

                # parse succeeded
                return [_group, _NEWLINE, _NUMBER, _STRING],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar (): && NAME
    @memoize
    def bar(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # && NAME
            def _alt() -> ParseResult[Any]:

                # && NAME
                def _item__forced(result: Any, expected: str) -> ParseResult[Any]:
                    def _NAME() -> ParseResult[Token]:
                        return self._name()
                    return self._expect_forced(_NAME, "NAME")
                _forced: Any
                _forced, = _item__forced()

                # parse succeeded
                return "foo + bar",

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar0 (): NAME
    def bar0(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # NAME
            def _alt() -> ParseResult[Any]:

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # parse succeeded
                return "foo + bar",

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar1 [int] (x: int): NAME x | <always>
    def bar1(self, x: int) -> ParseResult[int]:
        def _rhs() -> ParseResult[int]:

            # NAME x
            def _alt1() -> ParseResult[int]:

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # x
                def _item__x() -> ParseResult[int]:
                    return x
                _x: int; _result__x: ParseResult[int]
                _result__x = _item__x()
                if not _result__x: return None
                _x, = _result__x

                # parse succeeded
                return 'S',

            # <always>
            def _alt2() -> ParseResult[int]:

                # parse succeeded
                return 43,

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar3 (x: int, y): ~ NAME | ([bar1(x)] | NAME)
    def bar3(self, x: int, y) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # ~ NAME
            def _alt1() -> ParseResult[Any]:

                # ~
                def _item__cut() -> Any:
                    return self._cut()
                _item__cut()

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # parse succeeded
                return _NAME,

            # ([bar1(x)] | NAME)
            def _alt2() -> ParseResult[Any]:

                # g=([bar1(x)] | NAME)
                def _item_g() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # [bar1(x)]
                        def _alt1() -> ParseResult[Any]:

                            # [bar1(x)]
                            def _item__opt() -> ParseResult[list[Any]]:
                                def _rhs() -> ParseResult[Any]:

                                    # bar1(x)
                                    def _alt() -> ParseResult[Any]:

                                        # b=bar1(x)
                                        def _item_b(x: int) -> ParseResult[int]:
                                            return self.bar1(x)
                                        b: int; _result_b: ParseResult[int]
                                        _result_b = _item_b()
                                        if not _result_b: return None
                                        b, = _result_b

                                        # parse succeeded
                                        return b,

                                    _alts = [
                                        _alt,
                                    ]
                                    return self._alts(_alts)
                                return self._opt(_rhs)
                            _opt: list[Any]
                            _opt, = _item__opt()

                            # parse succeeded
                            return _opt,

                        # NAME
                        def _alt2() -> ParseResult[Any]:

                            # NAME
                            def _item__NAME() -> ParseResult[Token]:
                                return self._name()
                            _NAME: Token; _result__NAME: ParseResult[Token]
                            _result__NAME = _item__NAME()
                            if not _result__NAME: return None
                            _NAME, = _result__NAME

                            # parse succeeded
                            return _NAME,

                        _alts = [
                            _alt1,
                            _alt2,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                g: Any; _result_g: ParseResult[Any]
                _result_g = _item_g()
                if not _result_g: return None
                g, = _result_g

                # parse succeeded
                return g+1,

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar5 (x: int, yfun: Callable[[int], Any]): NAME NAME yfun(x)+ yfun(x)
    def bar5(self, x: int, yfun: Callable[[int], Any]) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # NAME NAME yfun(x)+ yfun(x)
            def _alt() -> ParseResult[Any]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # n2=NAME
                def _item_n2() -> ParseResult[Token]:
                    return self._name()
                n2: Token; _result_n2: ParseResult[Token]
                _result_n2 = _item_n2()
                if not _result_n2: return None
                n2, = _result_n2

                # yfun(x)+
                def _item__repeat() -> ParseResult[list[Any]]:
                    return self._repeat(_yfun, True)
                _repeat: list[Any]; _result__repeat: ParseResult[list[Any]]
                _result__repeat = _item__repeat()
                if not _result__repeat: return None
                _repeat, = _result__repeat

                # yfun(x)
                def _item__yfun(n: int) -> ParseResult[Any]:
                    return yfun(x)
                _yfun: Any; _result__yfun: ParseResult[Any]
                _result__yfun = _item__yfun()
                if not _result__yfun: return None
                _yfun, = _result__yfun

                # parse succeeded
                return n+x,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar6 [list] (): (NAME | STRING* ('foo' 'foo' 'bar'))+
    @memoize
    def bar6(self) -> ParseResult[list]:
        def _rhs() -> ParseResult[list]:

            # (NAME | STRING* ('foo' 'foo' 'bar'))+
            def _alt() -> ParseResult[list]:

                # item=(NAME | STRING* ('foo' 'foo' 'bar'))+
                def _item_item() -> ParseResult[list[Any]]:
                    def _group() -> ParseResult[Any]:
                        def _rhs() -> ParseResult[Any]:

                            # NAME
                            def _alt1() -> ParseResult[Any]:

                                # NAME
                                def _item__NAME() -> ParseResult[Token]:
                                    return self._name()
                                _NAME: Token; _result__NAME: ParseResult[Token]
                                _result__NAME = _item__NAME()
                                if not _result__NAME: return None
                                _NAME, = _result__NAME

                                # parse succeeded
                                return _NAME,

                            # STRING* ('foo' 'foo' 'bar')
                            def _alt2() -> ParseResult[Any]:

                                # STRING*
                                def _item__repeat() -> ParseResult[list[Token]]:
                                    def _STRING() -> ParseResult[Token]:
                                        return self._string()
                                    return self._repeat(_STRING, False)
                                _repeat: list[Token]
                                _repeat, = _item__repeat()

                                # ('foo' 'foo' 'bar')
                                def _item__group() -> ParseResult[Any]:
                                    def _rhs() -> ParseResult[Any]:

                                        # 'foo' 'foo' 'bar'
                                        def _alt() -> ParseResult[Any]:

                                            # 'foo'
                                            def _item__keyword() -> ParseResult[Token]:
                                                return self._expect_type(504)   # keyword = 'foo'
                                            _keyword: Token; _result__keyword: ParseResult[Token]
                                            _result__keyword = _item__keyword()
                                            if not _result__keyword: return None
                                            _keyword, = _result__keyword

                                            # 'foo'
                                            def _item__keyword_1() -> ParseResult[Token]:
                                                return self._expect_type(504)   # keyword = 'foo'
                                            _keyword_1: Token; _result__keyword_1: ParseResult[Token]
                                            _result__keyword_1 = _item__keyword_1()
                                            if not _result__keyword_1: return None
                                            _keyword_1, = _result__keyword_1

                                            # 'bar'
                                            def _item__keyword_2() -> ParseResult[Token]:
                                                return self._expect_type(505)   # keyword = 'bar'
                                            _keyword_2: Token; _result__keyword_2: ParseResult[Token]
                                            _result__keyword_2 = _item__keyword_2()
                                            if not _result__keyword_2: return None
                                            _keyword_2, = _result__keyword_2

                                            # parse succeeded
                                            return [_keyword, _keyword_1, _keyword_2],

                                        _alts = [
                                            _alt,
                                        ]
                                        return self._alts(_alts)
                                    return _rhs()
                                _group: Any; _result__group: ParseResult[Any]
                                _result__group = _item__group()
                                if not _result__group: return None
                                _group, = _result__group

                                # parse succeeded
                                return [_repeat, _group],

                            _alts = [
                                _alt1,
                                _alt2,
                            ]
                            return self._alts(_alts)
                        return _rhs()
                    return self._repeat(_group, True)
                item: list[Any]; _result_item: ParseResult[list[Any]]
                _result_item = _item_item()
                if not _result_item: return None
                item, = _result_item

                # parse succeeded
                return item,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # bar7 [list] (): NAME SOFT_KEYWORD
    @memoize
    def bar7(self) -> ParseResult[list]:
        def _rhs() -> ParseResult[list]:

            # NAME SOFT_KEYWORD
            def _alt() -> ParseResult[list]:

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # SOFT_KEYWORD
                def _item__SOFT_KEYWORD() -> ParseResult[Token]:
                    return self._soft_keyword()
                _SOFT_KEYWORD: Token; _result__SOFT_KEYWORD: ParseResult[Token]
                _result__SOFT_KEYWORD = _item__SOFT_KEYWORD()
                if not _result__SOFT_KEYWORD: return None
                _SOFT_KEYWORD, = _result__SOFT_KEYWORD

                # parse succeeded
                return [_NAME, _SOFT_KEYWORD],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # xx1 (): &bar1(1)
    def xx1(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # &bar1(1)
            def _alt() -> ParseResult[Any]:

                # lk=&bar1(1)
                def _item_lk() -> ParseStatus:
                    def _atom(x: int) -> ParseResult[int]:
                        return self.bar1(1)
                    return self._lookahead(True, _atom)
                if not _item_lk(): return None

                # parse succeeded
                return lk,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # xx2 (): !bar1(1)
    def xx2(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # !bar1(1)
            def _alt() -> ParseResult[Any]:

                # lk=!bar1(1)
                def _item_lk() -> ParseStatus:
                    def _atom(x: int) -> ParseResult[int]:
                        return self.bar1(1)
                    return self._lookahead(False, _atom)
                if not _item_lk(): return None

                # parse succeeded
                return lk,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rec1 (): rec2 STRING
    # Left-recursive leader
    @memoize_left_rec
    def rec1(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # rec2 STRING
            def _alt() -> ParseResult[Any]:

                # rec2
                def _item__rec2() -> ParseResult[Any]:
                    return self.rec2()
                _rec2: Any; _result__rec2: ParseResult[Any]
                _result__rec2 = _item__rec2()
                if not _result__rec2: return None
                _rec2, = _result__rec2

                # STRING
                def _item__STRING() -> ParseResult[Token]:
                    return self._string()
                _STRING: Token; _result__STRING: ParseResult[Token]
                _result__STRING = _item__STRING()
                if not _result__STRING: return None
                _STRING, = _result__STRING

                # parse succeeded
                return [_rec2, _STRING],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rec2 (): rec3 NAME
    # Left-recursive
    @logger
    def rec2(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # rec3 NAME
            def _alt() -> ParseResult[Any]:

                # rec3
                def _item__rec3() -> ParseResult[Any]:
                    return self.rec3()
                _rec3: Any; _result__rec3: ParseResult[Any]
                _result__rec3 = _item__rec3()
                if not _result__rec3: return None
                _rec3, = _result__rec3

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # parse succeeded
                return [_rec3, _NAME],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rec3 (): rec1 NUMBER
    # Left-recursive
    @logger
    def rec3(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # rec1 NUMBER
            def _alt() -> ParseResult[Any]:

                # rec1
                def _item__rec1() -> ParseResult[Any]:
                    return self.rec1()
                _rec1: Any; _result__rec1: ParseResult[Any]
                _result__rec1 = _item__rec1()
                if not _result__rec1: return None
                _rec1, = _result__rec1

                # NUMBER
                def _item__NUMBER() -> ParseResult[Token]:
                    return self._number()
                _NUMBER: Token; _result__NUMBER: ParseResult[Token]
                _result__NUMBER = _item__NUMBER()
                if not _result__NUMBER: return None
                _NUMBER, = _result__NUMBER

                # parse succeeded
                return [_rec1, _NUMBER],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rec (): rec NAME
    # Left-recursive leader
    @memoize_left_rec
    def rec(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # rec NAME
            def _alt() -> ParseResult[Any]:

                # rec
                def _item__rec() -> ParseResult[Any]:
                    return self.rec()
                _rec: Any; _result__rec: ParseResult[Any]
                _result__rec = _item__rec()
                if not _result__rec: return None
                _rec, = _result__rec

                # NAME
                def _item__NAME() -> ParseResult[Token]:
                    return self._name()
                _NAME: Token; _result__NAME: ParseResult[Token]
                _result__NAME = _item__NAME()
                if not _result__NAME: return None
                _NAME, = _result__NAME

                # parse succeeded
                return [_rec, _NAME],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # start (): rec2
    def start(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # rec2
            def _alt() -> ParseResult[Any]:

                # rec2
                def _item__rec2() -> ParseResult[Any]:
                    return self.rec2()
                _rec2: Any; _result__rec2: ParseResult[Any]
                _result__rec2 = _item__rec2()
                if not _result__rec2: return None
                _rec2, = _result__rec2

                # parse succeeded
                return EXTRA,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # xxx (a: int, b): (b) a (a) | (a)? | [a]
    def xxx(self, a: int, b) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # (b) a (a)
            def _alt1() -> ParseResult[Any]:

                # a=(b)
                def _item_a() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # b
                        def _alt() -> ParseResult[Any]:

                            # b
                            def _item__b() -> ParseResult[Any]:
                                return b
                            _b: Any; _result__b: ParseResult[Any]
                            _result__b = _item__b()
                            if not _result__b: return None
                            _b, = _result__b

                            # parse succeeded
                            return _b,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                a: Any; _result_a: ParseResult[Any]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # a
                def _item__a() -> ParseResult[Any]:
                    return a
                _a: Any; _result__a: ParseResult[Any]
                _result__a = _item__a()
                if not _result__a: return None
                _a, = _result__a

                # (a)
                def _item__group() -> ParseResult[Any]:
                    def _rhs() -> ParseResult[Any]:

                        # a
                        def _alt() -> ParseResult[Any]:

                            # a
                            def _item__a() -> ParseResult[Any]:
                                return a
                            _a: Any; _result__a: ParseResult[Any]
                            _result__a = _item__a()
                            if not _result__a: return None
                            _a, = _result__a

                            # parse succeeded
                            return _a,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return _rhs()
                _group: Any; _result__group: ParseResult[Any]
                _result__group = _item__group()
                if not _result__group: return None
                _group, = _result__group

                # parse succeeded
                return [a, _a, _group],

            # (a)?
            def _alt2() -> ParseResult[Any]:

                # (a)?
                def _item__opt() -> ParseResult[list[Any]]:
                    def _group() -> ParseResult[Any]:
                        def _rhs() -> ParseResult[Any]:

                            # a
                            def _alt() -> ParseResult[Any]:

                                # aa=a
                                def _item_aa() -> ParseResult[int]:
                                    return a
                                aa: int; _result_aa: ParseResult[int]
                                _result_aa = _item_aa()
                                if not _result_aa: return None
                                aa, = _result_aa

                                # parse succeeded
                                return aa,

                            _alts = [
                                _alt,
                            ]
                            return self._alts(_alts)
                        return _rhs()
                    return self._opt(_group)
                _opt: list[Any]
                _opt, = _item__opt()

                # parse succeeded
                return _opt,

            # [a]
            def _alt3() -> ParseResult[Any]:

                # [a]
                def _item__opt() -> ParseResult[list[Any]]:
                    def _rhs() -> ParseResult[Any]:

                        # a
                        def _alt() -> ParseResult[Any]:

                            # aa=a
                            def _item_aa() -> ParseResult[int]:
                                return a
                            aa: int; _result_aa: ParseResult[int]
                            _result_aa = _item_aa()
                            if not _result_aa: return None
                            aa, = _result_aa

                            # parse succeeded
                            return aa,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return self._opt(_rhs)
                _opt: list[Any]
                _opt, = _item__opt()

                # parse succeeded
                return _opt,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    KEYWORDS = ('y', 'z', 'x', 'abc', 'foo', 'bar')
    SOFT_KEYWORDS = ('def',)

