#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional, Callable, cast

from pegen.parser import (
    memoize, memoize_left_rec, logger, Parser, ParseResult
    )
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    AltItem,
    AltItems,
    Arg,
    Args,
    Cut,
    Forced,
    FuncType,
    Gather0,
    Gather1,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NegativeLookahead,
    NoArgs,
    NoName,
    NoType,
    NoParams,
    ObjName,
    ObjType,
    Opt,
    OptVal,
    OptGroup,
    Param,
    Params,
    PositiveLookahead,
    Primary,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    Type,
    TypedName,
    VarItem,
)

from pegen.target_code import Code, NoCode

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    # start [Grammar] (): grammar endmarker
    def start(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:

            # grammar endmarker
            def _alt() -> ParseResult[Grammar]:

                # g=grammar
                def _item_g() -> ParseResult[Grammar]:
                    return self.grammar()
                g: Grammar; _result_g: ParseResult[Grammar]
                _result_g = _item_g()
                if not _result_g: return None
                g, = _result_g

                # endmarker
                def _item__endmarker() -> ParseResult[Any]:
                    return self.endmarker()
                _endmarker: Any; _result__endmarker: ParseResult[Any]
                _result__endmarker = _item__endmarker()
                if not _result__endmarker: return None
                _endmarker, = _result__endmarker

                # parse succeeded
                return g,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # endmarker [Any] (): $ | "END" NEWLINE
    def endmarker(self) -> ParseResult[Any]:
        def _rhs() -> ParseResult[Any]:

            # $
            def _alt1() -> ParseResult[Token]:

                # $
                def _item__ENDMARKER() -> ParseResult[Token]:
                    return self._expect_type(0)
                _ENDMARKER: Token; _result__ENDMARKER: ParseResult[Token]
                _result__ENDMARKER = _item__ENDMARKER()
                if not _result__ENDMARKER: return None
                _ENDMARKER, = _result__ENDMARKER

                # parse succeeded
                return _ENDMARKER,

            # "END" NEWLINE
            def _alt2() -> ParseResult[list]:

                # "END"
                def _item__keyword() -> ParseResult[Token]:
                    return self._expect_name("END")   # keyword = 'END'
                _keyword: Token; _result__keyword: ParseResult[Token]
                _result__keyword = _item__keyword()
                if not _result__keyword: return None
                _keyword, = _result__keyword

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # parse succeeded
                return [_keyword, _NEWLINE],

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # grammar [Grammar] (): meta* rule+
    def grammar(self) -> ParseResult[Grammar]:
        def _rhs() -> ParseResult[Grammar]:

            # meta* rule+
            def _alt() -> ParseResult[Grammar]:

                # metas=meta*
                def _item_metas() -> ParseResult[list[Meta]]:
                    def _meta() -> ParseResult[Meta]:
                        return self.meta()
                    return self._repeat(_meta, False)
                metas: list[Meta]
                metas, = _item_metas()

                # rules=rule+
                def _item_rules() -> ParseResult[list[Rule]]:
                    def _rule() -> ParseResult[Rule]:
                        return self.rule()
                    return self._repeat(_rule, True)
                rules: list[Rule]; _result_rules: ParseResult[list[Rule]]
                _result_rules = _item_rules()
                if not _result_rules: return None
                rules, = _result_rules

                # parse succeeded
                return Grammar(rules, metas),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # meta [Meta] (): "@" NAME metavalue NEWLINE
    def meta(self) -> ParseResult[Meta]:
        def _rhs() -> ParseResult[Meta]:

            # "@" NAME metavalue NEWLINE
            def _alt() -> ParseResult[Meta]:

                # "@"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(49)   # token = "@"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # name=NAME
                def _item_name() -> ParseResult[Token]:
                    return self._name()
                name: Token; _result_name: ParseResult[Token]
                _result_name = _item_name()
                if not _result_name: return None
                name, = _result_name

                # val=metavalue
                def _item_val() -> ParseResult[str]:
                    return self.metavalue()
                val: str; _result_val: ParseResult[str]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # parse succeeded
                return Meta(name.string, val),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # metavalue [str] (): NAME | STRING | <always>
    def metavalue(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:

            # NAME
            def _alt1() -> ParseResult[str]:

                # val=NAME
                def _item_val() -> ParseResult[Token]:
                    return self._name()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return val.string,

            # STRING
            def _alt2() -> ParseResult[str]:

                # val=STRING
                def _item_val() -> ParseResult[Token]:
                    return self._string()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val

                # parse succeeded
                return literal_eval(val.string),

            # <always>
            def _alt3() -> ParseResult[str]:

                # parse succeeded
                return None,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # rule [Rule] (): typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
    def rule(self) -> ParseResult[Rule]:
        def _rhs() -> ParseResult[Rule]:

            # typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
            def _alt() -> ParseResult[Rule]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # m=memoflag?
                def _item_m() -> ParseResult[list[str]]:
                    def _memoflag() -> ParseResult[str]:
                        return self.memoflag()
                    return self._opt(_memoflag)
                m: list[str]
                m, = _item_m()

                # ":"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(11)   # token = ":"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=maybe_alts?
                def _item_a() -> ParseResult[list[Rhs]]:
                    def _maybe_alts() -> ParseResult[Rhs]:
                        return self.maybe_alts()
                    return self._opt(_maybe_alts)
                a: list[Rhs]
                a, = _item_a()

                # NEWLINE
                def _item__NEWLINE() -> ParseResult[Token]:
                    return self._expect_type(4)
                _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                _result__NEWLINE = _item__NEWLINE()
                if not _result__NEWLINE: return None
                _NEWLINE, = _result__NEWLINE

                # aa=more_alts?
                def _item_aa() -> ParseResult[list[Rhs]]:
                    def _more_alts() -> ParseResult[Rhs]:
                        return self.more_alts()
                    return self._opt(_more_alts)
                aa: list[Rhs]
                aa, = _item_aa()

                # parse succeeded
                return Rule(n, Rhs([*chain(*a, *aa)]), memo=m),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # memoflag [str] (): '(' "memo" ')'
    def memoflag(self) -> ParseResult[str]:
        def _rhs() -> ParseResult[str]:

            # '(' "memo" ')'
            def _alt() -> ParseResult[str]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # "memo"
                def _item__keyword() -> ParseResult[Token]:
                    return self._expect_name("memo")   # keyword = 'memo'
                _keyword: Token; _result__keyword: ParseResult[Token]
                _result__keyword = _item__keyword()
                if not _result__keyword: return None
                _keyword, = _result__keyword

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return "memo",

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alts [Rhs] (): "|".alt+
    def alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # "|".alt+
            def _alt() -> ParseResult[Rhs]:

                # a="|".alt+
                def _item_a() -> ParseResult[list[Alt]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(_alt, _sep, True)
                a: list[Alt]; _result_a: ParseResult[list[Alt]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs(a),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # maybe_alts [Rhs] (): !NEWLINE "|".alt+ | <always>
    @memoize
    def maybe_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # !NEWLINE "|".alt+
            def _alt1() -> ParseResult[Rhs]:

                # !NEWLINE
                def _item__lookahead() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(4)
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # a="|".alt+
                def _item_a() -> ParseResult[list[Alt]]:
                    def _alt() -> ParseResult[Alt]:
                        return self.alt()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(18)   # token = "|"
                    return self._gather(_alt, _sep, True)
                a: list[Alt]; _result_a: ParseResult[list[Alt]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Rhs(a),

            # <always>
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs([]),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # more_alts [Rhs] (): INDENT ("|" alts NEWLINE)+ DEDENT | <always>
    @memoize
    def more_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> ParseResult[Rhs]:

            # INDENT ("|" alts NEWLINE)+ DEDENT
            def _alt1() -> ParseResult[Rhs]:

                # INDENT
                def _item__INDENT() -> ParseResult[Token]:
                    return self._expect_type(5)
                _INDENT: Token; _result__INDENT: ParseResult[Token]
                _result__INDENT = _item__INDENT()
                if not _result__INDENT: return None
                _INDENT, = _result__INDENT

                # a=("|" alts NEWLINE)+
                def _item_a() -> ParseResult[list[Any]]:
                    def _rhs() -> ParseResult[Any]:

                        # "|" alts NEWLINE
                        def _alt() -> ParseResult[Any]:

                            # "|"
                            def _item__literal() -> ParseResult[Token]:
                                return self._expect_type(18)   # token = "|"
                            _literal: Token; _result__literal: ParseResult[Token]
                            _result__literal = _item__literal()
                            if not _result__literal: return None
                            _literal, = _result__literal

                            # b=alts
                            def _item_b() -> ParseResult[Rhs]:
                                return self.alts()
                            b: Rhs; _result_b: ParseResult[Rhs]
                            _result_b = _item_b()
                            if not _result_b: return None
                            b, = _result_b

                            # NEWLINE
                            def _item__NEWLINE() -> ParseResult[Token]:
                                return self._expect_type(4)
                            _NEWLINE: Token; _result__NEWLINE: ParseResult[Token]
                            _result__NEWLINE = _item__NEWLINE()
                            if not _result__NEWLINE: return None
                            _NEWLINE, = _result__NEWLINE

                            # parse succeeded
                            return b,

                        _alts = [
                            _alt,
                        ]
                        return self._alts(_alts)
                    return self._repeat(_rhs, True)
                a: list[Any]; _result_a: ParseResult[list[Any]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # DEDENT
                def _item__DEDENT() -> ParseResult[Token]:
                    return self._expect_type(6)
                _DEDENT: Token; _result__DEDENT: ParseResult[Token]
                _result__DEDENT = _item__DEDENT()
                if not _result__DEDENT: return None
                _DEDENT, = _result__DEDENT

                # parse succeeded
                return Rhs([*chain(*a)]),

            # <always>
            def _alt2() -> ParseResult[Rhs]:

                # parse succeeded
                return Rhs(()),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt [Alt] (): alt_items action?
    def alt(self) -> ParseResult[Alt]:
        def _rhs() -> ParseResult[Alt]:

            # alt_items action?
            def _alt() -> ParseResult[Alt]:

                # i=alt_items
                def _item_i() -> ParseResult[AltItems]:
                    return self.alt_items()
                i: AltItems; _result_i: ParseResult[AltItems]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # a=action?
                def _item_a() -> ParseResult[list[Code]]:
                    def _action() -> ParseResult[Code]:
                        return self.action()
                    return self._opt(_action)
                a: list[Code]
                a, = _item_a()

                # parse succeeded
                return Alt(i, action=Code(a.opt)),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt_items [AltItems] (): alt_item*
    def alt_items(self) -> ParseResult[AltItems]:
        def _rhs() -> ParseResult[AltItems]:

            # alt_item*
            def _alt() -> ParseResult[AltItems]:

                # ii=alt_item*
                def _item_ii() -> ParseResult[list[AltItem]]:
                    def _alt_item() -> ParseResult[AltItem]:
                        return self.alt_item()
                    return self._repeat(_alt_item, False)
                ii: list[AltItem]
                ii, = _item_ii()

                # parse succeeded
                return AltItems(ii),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # alt_item [AltItem] (): typed_name '=' ~ item | item
    def alt_item(self) -> ParseResult[AltItem]:
        def _rhs() -> ParseResult[AltItem]:

            # typed_name '=' ~ item
            def _alt1() -> ParseResult[AltItem]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # '='
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(22)   # token = "="
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return VarItem(n, i),

            # item
            def _alt2() -> ParseResult[AltItem]:

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return VarItem(None, i),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # item [Item] (): '&' '&' ~ item | '&' ~ item | '!' ~ item | '~' | atom
    @memoize
    def item(self) -> ParseResult[Item]:
        def _rhs() -> ParseResult[Item]:

            # '&' '&' ~ item
            def _alt1() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # '&'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return Forced(i),

            # '&' ~ item
            def _alt2() -> ParseResult[Item]:

                # '&'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(19)   # token = "&"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return PositiveLookahead(i),

            # '!' ~ item
            def _alt3() -> ParseResult[Item]:

                # '!'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('!')   # token = "!"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # i=item
                def _item_i() -> ParseResult[Item]:
                    return self.item()
                i: Item; _result_i: ParseResult[Item]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i

                # parse succeeded
                return NegativeLookahead(i),

            # '~'
            def _alt4() -> ParseResult[Item]:

                # '~'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(31)   # token = "~"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Cut(),

            # atom
            def _alt5() -> ParseResult[Item]:

                # atom
                def _item__atom() -> ParseResult[Atom]:
                    return self.atom()
                _atom: Atom; _result__atom: ParseResult[Atom]
                _result__atom = _item__atom()
                if not _result__atom: return None
                _atom, = _result__atom

                # parse succeeded
                return _atom,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # atom [Atom] (): atom '?' | atom '*' | atom '+' | atom '.' primary '*' |
    #     atom '.' primary '+' | primary
    # Left-recursive leader
    @memoize_left_rec
    def atom(self) -> ParseResult[Atom]:
        def _rhs() -> ParseResult[Atom]:

            # atom '?'
            def _alt1() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '?'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_char('?')   # token = "?"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Opt(a),

            # atom '*'
            def _alt2() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '*'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat0(a),

            # atom '+'
            def _alt3() -> ParseResult[Atom]:

                # a=atom
                def _item_a() -> ParseResult[Atom]:
                    return self.atom()
                a: Atom; _result_a: ParseResult[Atom]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # '+'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # parse succeeded
                return Repeat1(a),

            # atom '.' primary '*'
            def _alt4() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '*'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather0(sep, node),

            # atom '.' primary '+'
            def _alt5() -> ParseResult[Atom]:

                # sep=atom
                def _item_sep() -> ParseResult[Atom]:
                    return self.atom()
                sep: Atom; _result_sep: ParseResult[Atom]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep

                # '.'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(23)   # token = "."
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # node=primary
                def _item_node() -> ParseResult[Primary]:
                    return self.primary()
                node: Primary; _result_node: ParseResult[Primary]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node

                # '+'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(14)   # token = "+"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Gather1(sep, node),

            # primary
            def _alt6() -> ParseResult[Atom]:

                # primary
                def _item__primary() -> ParseResult[Primary]:
                    return self.primary()
                _primary: Primary; _result__primary: ParseResult[Primary]
                _result__primary = _item__primary()
                if not _result__primary: return None
                _primary, = _result__primary

                # parse succeeded
                return _primary,

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
                _alt6,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # primary [Primary] (): '(' ~ alts ')' type? | '[' ~ alts ']' type? | NAME
    #     arguments | STRING
    @memoize
    def primary(self) -> ParseResult[Primary]:
        def _rhs() -> ParseResult[Primary]:

            # '(' ~ alts ')' type?
            def _alt1() -> ParseResult[Primary]:

                # '('
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ')'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # t=type?
                def _item_t() -> ParseResult[list[Type]]:
                    def _type() -> ParseResult[Type]:
                        return self.type()
                    return self._opt(_type)
                t: list[Type]
                t, = _item_t()

                # parse succeeded
                return Group(Rhs(a.alts), t),

            # '[' ~ alts ']' type?
            def _alt2() -> ParseResult[Primary]:

                # '['
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # ~
                def _item__cut() -> None:
                    return self._cut()
                _item__cut()

                # a=alts
                def _item_a() -> ParseResult[Rhs]:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # ']'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # t=type?
                def _item_t() -> ParseResult[list[Type]]:
                    def _type() -> ParseResult[Type]:
                        return self.type()
                    return self._opt(_type)
                t: list[Type]
                t, = _item_t()

                # parse succeeded
                return OptGroup(Rhs(a.alts), t),

            # NAME arguments
            def _alt3() -> ParseResult[Primary]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # a=arguments
                def _item_a() -> ParseResult[Args]:
                    return self.arguments()
                a: Args; _result_a: ParseResult[Args]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return NameLeaf(n, a),

            # STRING
            def _alt4() -> ParseResult[Primary]:

                # s=STRING
                def _item_s() -> ParseResult[Token]:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s

                # parse succeeded
                return StringLeaf(s),

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # name [ObjName] (): NAME
    def name(self) -> ParseResult[ObjName]:
        def _rhs() -> ParseResult[ObjName]:

            # NAME
            def _alt() -> ParseResult[ObjName]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return ObjName(n.string),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # type [Type] (): '[' annotation? params* ']'
    def type(self) -> ParseResult[Type]:
        def _rhs() -> ParseResult[Type]:

            # '[' annotation? params* ']'
            def _alt() -> ParseResult[Type]:

                # '['
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # a=annotation?
                def _item_a() -> ParseResult[list[Code]]:
                    def _annotation() -> ParseResult[Code]:
                        return self.annotation()
                    return self._opt(_annotation)
                a: list[Code]
                a, = _item_a()

                # pp=params*
                def _item_pp() -> ParseResult[list[Params]]:
                    def _params() -> ParseResult[Params]:
                        return self.params()
                    return self._repeat(_params, False)
                pp: list[Params]
                pp, = _item_pp()

                # ']'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Type(a.opt, *pp),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # param [Param] (): typed_name | type
    def param(self) -> ParseResult[Param]:
        def _rhs() -> ParseResult[Param]:

            # typed_name
            def _alt1() -> ParseResult[Param]:

                # n=typed_name
                def _item_n() -> ParseResult[TypedName]:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return Param(n),

            # type
            def _alt2() -> ParseResult[Param]:

                # t=type
                def _item_t() -> ParseResult[Type]:
                    return self.type()
                t: Type; _result_t: ParseResult[Type]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t

                # parse succeeded
                return Param(TypedName(NoName(), t)),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # params [Params] (): '<' ','.param* ','? '>' | '<' '>'
    def params(self) -> ParseResult[Params]:
        def _rhs() -> ParseResult[Params]:

            # '<' ','.param* ','? '>'
            def _alt1() -> ParseResult[Params]:

                # '<'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(20)   # token = "<"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # pp=','.param*
                def _item_pp() -> ParseResult[list[Param]]:
                    def _param() -> ParseResult[Param]:
                        return self.param()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._gather(_param, _sep, False)
                pp: list[Param]
                pp, = _item_pp()

                # ','?
                def _item__opt() -> ParseResult[list[Token]]:
                    def _literal() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._opt(_literal)
                _opt: list[Token]
                _opt, = _item__opt()

                # '>'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(21)   # token = ">"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params(pp),

            # '<' '>'
            def _alt2() -> ParseResult[Params]:

                # '<'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(20)   # token = "<"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # '>'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(21)   # token = ">"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Params([]),

            _alts = [
                _alt1,
                _alt2,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # typed_name [TypedName] (): name type?
    def typed_name(self) -> ParseResult[TypedName]:
        def _rhs() -> ParseResult[TypedName]:

            # name type?
            def _alt() -> ParseResult[TypedName]:

                # n=name
                def _item_n() -> ParseResult[ObjName]:
                    return self.name()
                n: ObjName; _result_n: ParseResult[ObjName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # typ=type?
                def _item_typ() -> ParseResult[list[Type]]:
                    def _type() -> ParseResult[Type]:
                        return self.type()
                    return self._opt(_type)
                typ: list[Type]
                typ, = _item_typ()

                # parse succeeded
                return TypedName(n, typ),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # action [Code] (): "{" target_atoms "}"
    def action(self) -> ParseResult[Code]:
        def _rhs() -> ParseResult[Code]:

            # "{" target_atoms "}"
            def _alt() -> ParseResult[Code]:

                # "{"
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(25)   # token = "{"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # t=target_atoms
                def _item_t() -> ParseResult[list[Token]]:
                    return self.target_atoms()
                t: list[Token]; _result_t: ParseResult[list[Token]]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t

                # "}"
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(26)   # token = "}"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Code(t),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # annotation [Code] (): anno_atom+
    def annotation(self) -> ParseResult[Code]:
        def _rhs() -> ParseResult[Code]:

            # anno_atom+
            def _alt() -> ParseResult[Code]:

                # aa=anno_atom+
                def _item_aa() -> ParseResult[list[list[Token]]]:
                    def _anno_atom() -> ParseResult[list[Token]]:
                        return self.anno_atom()
                    return self._repeat(_anno_atom, True)
                aa: list[list[Token]]; _result_aa: ParseResult[list[list[Token]]]
                _result_aa = _item_aa()
                if not _result_aa: return None
                aa, = _result_aa

                # parse succeeded
                return Code([*chain.from_iterable(aa)]),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arguments [Args] (): '<' ",".arg+ ","? '>' | '<' '>' | <always>
    def arguments(self) -> ParseResult[Args]:
        def _rhs() -> ParseResult[Args]:

            # '<' ",".arg+ ","? '>'
            def _alt1() -> ParseResult[Args]:

                # '<'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(20)   # token = "<"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # aa=",".arg+
                def _item_aa() -> ParseResult[list[Arg]]:
                    def _arg() -> ParseResult[Arg]:
                        return self.arg()
                    def _sep() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._gather(_arg, _sep, True)
                aa: list[Arg]; _result_aa: ParseResult[list[Arg]]
                _result_aa = _item_aa()
                if not _result_aa: return None
                aa, = _result_aa

                # ","?
                def _item__opt() -> ParseResult[list[Token]]:
                    def _literal() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._opt(_literal)
                _opt: list[Token]
                _opt, = _item__opt()

                # '>'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(21)   # token = ">"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Args(aa),

            # '<' '>'
            def _alt2() -> ParseResult[Args]:

                # '<'
                def _item__literal() -> ParseResult[Token]:
                    return self._expect_type(20)   # token = "<"
                _literal: Token; _result__literal: ParseResult[Token]
                _result__literal = _item__literal()
                if not _result__literal: return None
                _literal, = _result__literal

                # '>'
                def _item__literal_1() -> ParseResult[Token]:
                    return self._expect_type(21)   # token = ">"
                _literal_1: Token; _result__literal_1: ParseResult[Token]
                _result__literal_1 = _item__literal_1()
                if not _result__literal_1: return None
                _literal_1, = _result__literal_1

                # parse succeeded
                return Args([]),

            # <always>
            def _alt3() -> ParseResult[Args]:

                # parse succeeded
                return NoArgs(),

            _alts = [
                _alt1,
                _alt2,
                _alt3,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # anno_atom [list[Token]] (): !"<" !"]" target_atom
    def anno_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # !"<" !"]" target_atom
            def _alt() -> ParseResult[list[Token]]:

                # !"<"
                def _item__lookahead() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(20)   # token = "<"
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # !"]"
                def _item__lookahead_1() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(10)   # token = "]"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_1(): return None

                # a=target_atom
                def _item_a() -> ParseResult[list[Token]]:
                    return self.target_atom()
                a: list[Token]; _result_a: ParseResult[list[Token]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return a,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arg [Arg] (): arg_atom+
    def arg(self) -> ParseResult[Arg]:
        def _rhs() -> ParseResult[Arg]:

            # arg_atom+
            def _alt() -> ParseResult[Arg]:

                # a=arg_atom+
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _arg_atom() -> ParseResult[list[Token]]:
                        return self.arg_atom()
                    return self._repeat(_arg_atom, True)
                a: list[list[Token]]; _result_a: ParseResult[list[list[Token]]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return Arg(Code([*chain(*a)])),

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # arg_atom [list[Token]] (): !"," !">" target_atom
    def arg_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # !"," !">" target_atom
            def _alt() -> ParseResult[list[Token]]:

                # !","
                def _item__lookahead() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(12)   # token = ","
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # !">"
                def _item__lookahead_1() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(21)   # token = ">"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_1(): return None

                # a=target_atom
                def _item_a() -> ParseResult[list[Token]]:
                    return self.target_atom()
                a: list[Token]; _result_a: ParseResult[list[Token]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a

                # parse succeeded
                return a,

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # target_atoms [list[Token]] (): target_atom*
    def target_atoms(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # target_atom*
            def _alt() -> ParseResult[list[Token]]:

                # a=target_atom*
                def _item_a() -> ParseResult[list[list[Token]]]:
                    def _target_atom() -> ParseResult[list[Token]]:
                        return self.target_atom()
                    return self._repeat(_target_atom, False)
                a: list[list[Token]]
                a, = _item_a()

                # parse succeeded
                return [*chain.from_iterable(a)],

            _alts = [
                _alt,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    # target_atom [list[Token]] (): "(" target_atoms? ")" | "{" target_atoms?
    #     "}" | "[" target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?"
    #     | ":" | !")" !"}" !"]" OP
    @memoize
    def target_atom(self) -> ParseResult[list[Token]]:
        def _rhs() -> ParseResult[list[Token]]:

            # "(" target_atoms? ")"
            def _alt1() -> ParseResult[list[Token]]:

                # l="("
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(7)   # token = "("
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r=")"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(8)   # token = ")"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # "{" target_atoms? "}"
            def _alt2() -> ParseResult[list[Token]]:

                # l="{"
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(25)   # token = "{"
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r="}"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(26)   # token = "}"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # "[" target_atoms? "]"
            def _alt3() -> ParseResult[list[Token]]:

                # l="["
                def _item_l() -> ParseResult[Token]:
                    return self._expect_type(9)   # token = "["
                l: Token; _result_l: ParseResult[Token]
                _result_l = _item_l()
                if not _result_l: return None
                l, = _result_l

                # atoms=target_atoms?
                def _item_atoms() -> ParseResult[list[list[Token]]]:
                    def _target_atoms() -> ParseResult[list[Token]]:
                        return self.target_atoms()
                    return self._opt(_target_atoms)
                atoms: list[list[Token]]
                atoms, = _item_atoms()

                # r="]"
                def _item_r() -> ParseResult[Token]:
                    return self._expect_type(10)   # token = "]"
                r: Token; _result_r: ParseResult[Token]
                _result_r = _item_r()
                if not _result_r: return None
                r, = _result_r

                # parse succeeded
                return [l, *chain(*(atoms)), r],

            # NAME "*"
            def _alt4() -> ParseResult[list[Token]]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # star="*"
                def _item_star() -> ParseResult[Token]:
                    return self._expect_type(16)   # token = "*"
                star: Token; _result_star: ParseResult[Token]
                _result_star = _item_star()
                if not _result_star: return None
                star, = _result_star

                # parse succeeded
                return [n, star],

            # NAME
            def _alt5() -> ParseResult[list[Token]]:

                # n=NAME
                def _item_n() -> ParseResult[Token]:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return [n],

            # NUMBER
            def _alt6() -> ParseResult[list[Token]]:

                # n=NUMBER
                def _item_n() -> ParseResult[Token]:
                    return self._number()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n

                # parse succeeded
                return [n],

            # STRING
            def _alt7() -> ParseResult[list[Token]]:

                # s=STRING
                def _item_s() -> ParseResult[Token]:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s

                # parse succeeded
                return [s],

            # "?"
            def _alt8() -> ParseResult[list[Token]]:

                # c="?"
                def _item_c() -> ParseResult[Token]:
                    return self._expect_char('?')   # token = "?"
                c: Token; _result_c: ParseResult[Token]
                _result_c = _item_c()
                if not _result_c: return None
                c, = _result_c

                # parse succeeded
                return [c],

            # ":"
            def _alt9() -> ParseResult[list[Token]]:

                # c=":"
                def _item_c() -> ParseResult[Token]:
                    return self._expect_type(11)   # token = ":"
                c: Token; _result_c: ParseResult[Token]
                _result_c = _item_c()
                if not _result_c: return None
                c, = _result_c

                # parse succeeded
                return [c],

            # !")" !"}" !"]" OP
            def _alt10() -> ParseResult[list[Token]]:

                # !")"
                def _item__lookahead() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(8)   # token = ")"
                    return self._lookahead(False, _atom)
                if not _item__lookahead(): return None

                # !"}"
                def _item__lookahead_1() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(26)   # token = "}"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_1(): return None

                # !"]"
                def _item__lookahead_2() -> Token:
                    def _atom() -> ParseResult[Token]:
                        return self._expect_type(10)   # token = "]"
                    return self._lookahead(False, _atom)
                if not _item__lookahead_2(): return None

                # op=OP
                def _item_op() -> ParseResult[Token]:
                    return self._op()
                op: Token; _result_op: ParseResult[Token]
                _result_op = _item_op()
                if not _result_op: return None
                op, = _result_op

                # parse succeeded
                return [op],

            _alts = [
                _alt1,
                _alt2,
                _alt3,
                _alt4,
                _alt5,
                _alt6,
                _alt7,
                _alt8,
                _alt9,
                _alt10,
            ]
            return self._alts(_alts)
        return self._rule(_rhs)

    KEYWORDS = ()
    SOFT_KEYWORDS = ('END', 'memo')


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
