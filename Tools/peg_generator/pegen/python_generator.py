import os.path
import token
from typing import IO, Any, Dict, List, Optional, Sequence, Set, Text, Tuple, Type, Iterable
from dataclasses import dataclass, field, replace
from abc import abstractmethod
import re

from pegen.grammar import (
    Alt,
    Cut,
    Forced,
    Gather,
    Grammar,
    GrammarNode,
    GrammarVisitor,
    Group,
    Lookahead,
    Item,
    NamedItem,
    NameLeaf,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
)

from pegen.parser import Parser, ParseResult, Token
from pegen.parser_generator import ParserGenerator

MODULE_PREFIX = """\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser, cut_sentinel

"""
MODULE_SUFFIX = """

if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main({class_name})
"""


class InvalidNodeVisitor(GrammarVisitor):
    def visit_NameLeaf(self, node: NameLeaf) -> bool:
        name = node.value
        return name.startswith("invalid")

    def visit_StringLeaf(self, node: StringLeaf) -> bool:
        return False

    def visit_NamedItem(self, node: NamedItem) -> bool:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> bool:
        return any(self.visit(alt) for alt in node)

    def visit_Alt(self, node: Alt) -> bool:
        return any(self.visit(item) for item in node.items)

    def lookahead_call_helper(self, node: Lookahead) -> bool:
        return self.visit(node.node)

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_Opt(self, node: Opt) -> bool:
        return self.visit(node.node)

    def visit_Repeat0(self, node: Repeat0) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Repeat1(self, node: Repeat1) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Group(self, node: Group) -> bool:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> bool:
        return False

    def visit_Forced(self, node: Forced) -> bool:
        return self.visit(node.node)


# FunctionCall class.
# Has members to describe what is to be generated to produce the body of a parse function or method.
# The generate(gen) method does the actual generation, using `gen` as the output writer.
# Subclasses are variations for certain classes of parse nodes.

@dataclass
class FunctionCall:
    var: Optional[str]
    call: str
    var_type: Optional[str] = None      # The type of a designated variable for a NamedItem.
    #return_type: Optional[str] = None
    inlines: Dict[str, Item] = field(default_factory=dict)       # Local functions defined before the call.

    @property
    def inline_names(self) -> List[str]:
        return [inline.name for inline in self.inlines]

    def generate(self, gen: ParserGenerator, varname: Optional[str] = None, fail_value: str = "None"):
        gen.gen_func_body(self.call, **self.inlines)
        #gen.gen_func_old(self, varname, fail_value)


@dataclass
class FuncInfo:
    """ Info about the Parse function generated by a visit to a Node.
    This is returned by the visit() method.
    """
    name: str                       # Actual name of the function.
    varname: str                    # Actual name of assigned variable.
    type: str = None                # Name of the return type of the function.
    vartype: str = None             # Name of the type of assigned variable.

class FuncCtx:
    """ Specifies how the generation of the parse function was requested.
    Determines some properties of the generated function.
    """
    @abstractmethod
    def name(self, dflt_name: str) -> str: ...

    @abstractmethod
    def varname(self, dflt_name: str) -> str: ...

    @abstractmethod
    def type(self) -> str: ...

    @abstractmethod
    def vartype(self) -> str: ...

    def func_info(self, dflt_name: str, dflt_type: str) -> FuncInfo:
        return FuncInfo(self.name(dflt_name), self.varname(dflt_name), dflt_type, self.vartype())


class AltFuncCtx(FuncCtx):
    """ A parse function for a NamedItem in an Alt. """
    def __init__(self, item: NamedItem, gen: ParserGenerator):
        self.item = item
        self.gen = gen
        self._varname = None

    def varname(self, dflt_name: str) -> str:
        if not self._varname:
            self._varname = self.gen.dedupe(self.item.name or dflt_name)
        return self._varname

    def name(self, dflt_name: str) -> str:
        return f"_item_{self.varname(dflt_name)}"

    def type(self) -> str:
        return ""

    def vartype(self) -> str:
        return self.item.type


class InlFuncCtx(FuncCtx):
    """ A parse function for an inline node in another parse function. """
    def __init__(self, name: str):
        self._name = name

    def varname(self, dflt_name: str) -> str:
        return self._name or dflt_name

    def name(self, dflt_name: str) -> str:
        return self._name or dflt_name

    def type(self) -> str:
        return ""

    def vartype(self) -> str:
        return ""


class NodeTypeVisitor(GrammarVisitor):
    """ Returns the type which results from successfully parsing the given node.
    The parse function itself returns ParseResult[the type].
    """
    def __init__(self, gen: ParserGenerator):
        self.gen = gen

    def visit(self, node: Any, *args: Any, **kwargs: Any) -> Any:
        result = super().visit(node, *args, **kwargs)
        return result or 'Any'

    def visit_NameLeaf(self, node: NameLeaf) -> Type:
        name = node.value
        func_name = node.basic_parser_name()
        if func_name:
            method = getattr(Parser, func_name)
            method = getattr(method, '__wrapped__', method)
            type = method.__annotations__['return']
            return re.match(r'ParseResult\[(.*)]$', type).group(1)
        func_name = node.token_parser_name()
        if func_name:
            return "Token"
        # The name is a rule, parameter, or variable.
        # A rule is called as 'self.rule',
        obj: TypedName = self.gen.rules.get(name, None)
        if not obj:
            obj = self.gen.current_rule.params.get(name)
        if not obj:
            for item in self.gen.current_alt.items:
                if item is self.gen.current_item: break     # Search failed.
                if item.name == name:
                    obj = item
                    break
            else:
                assert 0, f"Name {name!r} not found in {self.gen.current_rule}"
        return obj.type


    def visit_StringLeaf(self, node: StringLeaf) -> Type:
        return "Token"

    def visit_NamedItem(self, node: NamedItem) -> Type:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> Type:
        return "Any"

    def visit_Alt(self, node: Alt) -> Type:
        return "Any"

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> Type:
        return self.visit(node.node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> Type:
        return "bool"

    def visit_Opt(self, node: Opt) -> Type:
        return f"Optional[{self.visit(node.node)}]"

    def visit_Repeat0(self, node: Repeat0) -> Type:
        return f"List[{self.visit(node.node)}]"

    def visit_Repeat1(self, node: Repeat1) -> Type:
        return f"List[{self.visit(node.node)}]"

    def visit_Gather(self, node: Gather) -> Type:
        return f"List[{self.visit(node.node)}]"

    def visit_Group(self, node: Group) -> Type:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> Type:
        return None

    def visit_Forced(self, node: Forced) -> Type:
        return self.visit(node.node)

    def generic_visit(self, node: GrammarNode) -> Type:
        print(f"--- Visiting {node!r}")
        return "Any"


class PythonParserGenerator(ParserGenerator, GrammarVisitor):
    def __init__(
        self,
        grammar: Grammar,
        file: Optional[IO[Text]],
        tokens: Set[str] = set(token.tok_name.values()),
        location_formatting: Optional[str] = None,
        unreachable_formatting: Optional[str] = None,
        verbose: bool = False,
    ):
        tokens.add("SOFT_KEYWORD")
        super().__init__(grammar, tokens, file, verbose=verbose)
        self.invalidvisitor: InvalidNodeVisitor = InvalidNodeVisitor()
        self.nodetypevisitor: NodeTypeVisitor = NodeTypeVisitor(self)
        self.unreachable_formatting = unreachable_formatting or "None  # pragma: no cover"
        self.location_formatting = (
            location_formatting
            or "lineno=start_lineno, col_offset=start_col_offset, "
            "end_lineno=end_lineno, end_col_offset=end_col_offset"
        )

    def generate(self, filename: str) -> None:
        self.collect_keywords(self.rules)
        header = self.grammar.metas.get("header", MODULE_PREFIX)
        if header is not None:
            basename = os.path.basename(filename)
            self.print(header.rstrip("\n").format(filename=basename))
        subheader = self.grammar.metas.get("subheader", "")
        if subheader:
            self.print(subheader)
        cls_name = self.grammar.metas.get("class", "GeneratedParser")
        self.print("# Keywords and soft keywords are listed at the end of the parser definition.")
        self.print(f"class {cls_name}(Parser):")
        for rule in dict(self.rules).values():
            self.print()
            with self.indent():
                self.visit(rule)

        self.print()
        with self.indent():
            self.print(f"KEYWORDS = {tuple(self.keywords)}")
            self.print(f"SOFT_KEYWORDS = {tuple(self.soft_keywords)}")

        trailer = self.grammar.metas.get("trailer", MODULE_SUFFIX.format(class_name=cls_name))
        if trailer is not None:
            self.print(trailer.rstrip("\n"))

    def alts_uses_locations(self, alts: Sequence[Alt]) -> bool:
        for alt in alts:
            if alt.action and "LOCATIONS" in alt.action:
                return True
            for n in alt.items:
                if isinstance(n.item, Group):
                    if self.alts_uses_locations(n.item.rhs): return True
        return False

    def rule_params(self, rule: Rule) -> str:
        """ The text for parameters to declare a rule. """
        params = ''.join([f', {param.name}: {self.param_type(param)}' for param in (rule.params)])
        return f"(self{params})"

    def param_type(self, param: TypedName) -> str:
        """ What is generated for the type of a parameter, following '{param.name}:'
        The name may have its own parameters, which are generated recursively.
        """
        base_type = param.type or "Any"
        if param.params and len(param.params):
            # This node is a callable type.
            subtypes = [self.param_type(subparam) for subparam in param.params]
            return f'Callable[[{", ".join(subtypes)}], {base_type}]'
        else:
            return base_type

    def visit_Rule(self, node: Rule) -> None:
        self.current_rule = node
        self.current_alt = None
        self.current_item = None

        rhs = node.flatten()
        if node.left_recursive:
            if node.leader:
                self.print("@memoize_left_rec")
            else:
                # Non-leader rules in a cycle are not memoized,
                # but they must still be logged.
                self.print("@logger")
        elif node.memo or self.verbose:
            self.print("@memoize")
        node_type = node.type or "Any"
        self.print(f"def {node.name}{self.rule_params(node)} -> ParseResult[{node_type}]:")
        with self.indent():
            self.print(f"# {node.name}: {rhs}")
        with self.indent():
            self.gen_rhs(rhs)
        self.current_rule = None

    def visit_Rhs(self, node: Rhs,
        ctx: FuncCtx,
        **kwds) -> FuncInfo:
        """ Generate function definition for the Rhs.
        Used only within a Group.  The 'n
        """
        self.print(f"def {ctx.name('_rhs')}():")
        with self.indent():
            self.gen_rhs(node)

        return ctx.func_info('_rhs', 'Any')

    def gen_rhs(self, node: Rhs) -> None:

        def gen_alt(alt: Alt, suffix: int = 0) -> str:
            name = f"_alt{f'_{suffix}' if suffix else ''}"
            self.print(f"def {name}():")
            with self.indent():
                # The body of the alternative, returns (result,) or None.
                self.visit(alt)
            return name

        alts = node
        if len(alts) == 1:
            gen_alt(alts[0])
            self.print("return self._alt(_alt)")
        else:
            names = []
            for n, alt in enumerate(node, 1):
                names.append(gen_alt(alt, n))
            self.print(f"return self._alts({', '.join(names)})")

    def visit_Alt(self, node: Alt, **kwds) -> None:
        save = self.current_alt, self.current_item
        self.current_alt = node
        self.current_item = None
        self.failed_value = "None"
        with self.local_variable_context():
            fail_value = "None"
            for item in node.items:
                self.print(f"# {item}")
                # If the item is a Cut, then there's no item name, but there's a Cut function
                if isinstance(item.item, Cut):
                    fail_value = "cut_sentinel"
                    continue
                self.gen_named_item(item, fail_value)
                self.current_item = item

            self.print("# parse succeeded")
            action = self.action(node)
            self.print(f"return ({action}),")
        self.current_alt, self.current_item = save

    # Lower level visitors.  Called via self.visit(node, ctx, **kwds).
    # The ctx is one of
    #   -- AltFuncCtx.      Generating the item within an Alt.
    #   -- InlFuncCtx.      Generating an inlined function, using given name.
    # They all call self.gen_func() with:
    #   -- default name for the function.  This varies with the node.
    #   -- call string, which is expression returned by the function.
    #   -- the ctx passed to the visitor.
    #   zero or more of:
    #   -- {inline_name}=Node.  This generates a local function 'name', which parses the Node.
    # The visitor returns a FuncInfo object.

    def visit_NameLeaf(self, node: NameLeaf, **kwds) -> FuncInfo:
        name = node.value
        func_name = node.basic_parser_name()
        if func_name:
            return self.gen_func(node, func_name, f"self.{func_name}()", **kwds)
        func_name = node.token_parser_name()
        if func_name:
            return self.gen_func(node, func_name, f"self._expect({name!r})", **kwds)
        # The name is a rule, parameter, or variable.
        # A rule is called as 'self.rule',
        return self.gen_func(node, name, f"{'self.' if name in self.rules else ''}{name}{node.args.show()}", **kwds)

    def visit_StringLeaf(self, node: StringLeaf, **kwds) -> FuncInfo:
        return self.gen_func(node, "_literal", f"self._expect({node.value})", **kwds)

    def visit_PositiveLookahead(self, node: PositiveLookahead, **kwds) -> FuncInfo:
        return self.gen_func(node, "_lookahead", "self._positive_lookahead(_atom)", _atom=node.node, **kwds)

    def visit_NegativeLookahead(self, node: NegativeLookahead, **kwds) -> FuncInfo:
        return self.gen_func(node, "_lookahead", f"self._negative_lookahead(_atom)", _atom=node.node, **kwds)

    def visit_Opt(self, node: Opt, **kwds) -> FuncInfo:
        return self.gen_func(node, "opt", "self._opt(_atom)", _atom=node.node, **kwds)

    def visit_Repeat0(self, node: Repeat0, **kwds) -> FuncInfo:
        return self.gen_func(node, "_loop0", "self._repeat0(_atom)", _atom=node.node, **kwds)

    def visit_Repeat1(self, node: Repeat1, **kwds) -> FuncInfo:
        return self.gen_func(node, "_loop1", "self._repeat1(_atom)", _atom=node.node, **kwds)

    def visit_Gather(self, node: Gather, **kwds) -> FuncInfo:
        return self.gen_func(node, "_gather", "self._gather(_elem, _sep)", _elem=node.node, _sep=node.separator, **kwds)

    def visit_Group(self, node: Group, **kwds) -> FuncInfo:
        return self.visit(node.rhs, **kwds)

    def gen_named_item(self, item: NamedItem, fail_value: str = "None") -> FuncInfo:
        """ Code which parses a single named item in an alt.
        Exits the alt if the parse fails.
        Return info of the function.
        """

        assert isinstance (item, NamedItem)

        info = self.visit(item.item, ctx=AltFuncCtx(item, self))
        name = item.name or info.varname

        item_type = info.type
        var_type = info.vartype or item_type
        rawname = f"_result_{name}"
        rawtype = f"ParseResult[{item_type}]"
        if item.item.always_true:
            self.print(f"{name}: {var_type}")
            self.print(f"{name}, = {info.name}()")
        else:
            self.print(f"{name}: {var_type}; {rawname}: {rawtype}")
            self.print(f"{rawname} = {info.name}()")
            self.print(f"if not {rawname}: return {fail_value}")
            self.print(f"{name}, = {rawname}")

        return info

    def generic_visit(self, node, **kwds) -> FuncInfo:
        """ This is for a visit function not yet directly implemented. """
        assert 0, f"PythonGenerator has no visitor for {node!r}"


    def gen_func(self,
                 node: GrammarNode,
                 dflt_name: Optional[str],
                 call: str,
                 ctx: FuncCtx,
                 # Any number of these may be given.
                 **inlines: GrammarNode
        ) -> FuncInfo:

        # Determine the name of the function from the ctx argument.

        self.print(f"def {ctx.name(dflt_name)}():")

        # Determine the return type of the function.
        return_type = self.nodetypevisitor.visit(node)

        with self.indent():
            for inline_name, inline in inlines.items():
                # Expand the inline items.
                self.visit(inline, ctx=InlFuncCtx(inline_name))
            self.print(f"return {call}")

        return ctx.func_info(dflt_name, return_type)

    def action(self, node: Alt) -> str:
        """ The action for the alt, if it succeeds. """
        action = node.action
        if not action:
            if not node.items:
                action = "True"
            elif self.invalidvisitor.visit(node):
                action = "UNREACHABLE"
            elif len(self.local_variable_names) == 1:
                action = f"{self.local_variable_names[0]}"
            else:
                action = f"[{', '.join(self.local_variable_names)}]"
        elif "LOCATIONS" in action:
            self.print("tok = self._tokenizer.get_last_non_whitespace_token()")
            self.print("end_lineno, end_col_offset = tok.end")
            action = action.replace("LOCATIONS", self.location_formatting)

        if "UNREACHABLE" in action:
            action = action.replace("UNREACHABLE", self.unreachable_formatting)

        return action
