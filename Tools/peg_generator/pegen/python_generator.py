import os.path
import token
from typing import IO, Any, Dict, List, Optional, Sequence, Set, Text, Tuple, Type, Iterable
from dataclasses import dataclass, field, replace
from abc import abstractmethod

from pegen.grammar import (
    Alt,
    Cut,
    Forced,
    Gather,
    Grammar,
    GrammarNode,
    GrammarVisitor,
    Group,
    Lookahead,
    Item,
    NamedItem,
    NameLeaf,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
)

from pegen.parser import ParseResult, Token

from pegen.parser_generator import ParserGenerator

MODULE_PREFIX = """\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser, cut_sentinel

"""
MODULE_SUFFIX = """

if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main({class_name})
"""


class InvalidNodeVisitor(GrammarVisitor):
    def visit_NameLeaf(self, node: NameLeaf) -> bool:
        name = node.value
        return name.startswith("invalid")

    def visit_StringLeaf(self, node: StringLeaf) -> bool:
        return False

    def visit_NamedItem(self, node: NamedItem) -> bool:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> bool:
        return any(self.visit(alt) for alt in node)

    def visit_Alt(self, node: Alt) -> bool:
        return any(self.visit(item) for item in node.items)

    def lookahead_call_helper(self, node: Lookahead) -> bool:
        return self.visit(node.node)

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_Opt(self, node: Opt) -> bool:
        return self.visit(node.node)

    def visit_Repeat0(self, node: Repeat0) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Repeat1(self, node: Repeat1) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Group(self, node: Group) -> bool:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> bool:
        return False

    def visit_Forced(self, node: Forced) -> bool:
        return self.visit(node.node)


# FunctionCall class.
# Has members to describe what is to be generated to produce the body of a parse function or method.
# The generate(gen) method does the actual generation, using `gen` as the output writer.
# Subclasses are variations for certain classes of parse nodes.

@dataclass
class FunctionCall:
    var: Optional[str]
    call: str
    var_type: Optional[str] = None      # The type of a designated variable for a NamedItem.
    #return_type: Optional[str] = None
    inlines: Dict[str, Item] = field(default_factory=dict)       # Local functions defined before the call.

    @property
    def inline_names(self) -> List[str]:
        return [inline.name for inline in self.inlines]

    def generate(self, gen: ParserGenerator, varname: Optional[str] = None, fail_value: str = "None"):
        gen.gen_func_body(self.call, **self.inlines)
        #gen.gen_func_old(self, varname, fail_value)


@dataclass
class FuncInfo:
    """ Info about the Parse function generated by a visit to a Node.
    This is returned by the visit() method.
    """
    name: str                       # Actual name of the function.
    varname: str                    # Actual name of assigned variable.
    type: str = None                # Name of the return type of the function.

class FuncCtx:
    """ Specifies how the generation of the parse function was requested.
    Determines some properties of the generated function.
    """
    @abstractmethod
    def name(self, default: str) -> str: ...

    @abstractmethod
    def varname(self, default: str) -> str: ...

    @abstractmethod
    def type(self) -> str: ...

    def func_info(self, default: str) -> FuncInfo:
        return FuncInfo(self.name(default), self.varname(default), self.type())


class AltFuncCtx(FuncCtx):
    """ A parse function for a NamedItem in an Alt. """
    def __init__(self, item: NamedItem, gen: ParserGenerator):
        self.item = item
        self.gen = gen
        self._varname = None

    def varname(self, default: str) -> str:
        if not self._varname:
            self._varname = self.gen.dedupe(self.item.name or default)
        return self._varname

    def name(self, default: str) -> str:
        return f"_item_{self.varname(default)}"

    def type(self) -> str:
        return ""

class InlFuncCtx(FuncCtx):
    """ A parse function for an inline node in another parse function. """
    def __init__(self, name: str):
        self._name = name

    def varname(self, default: str) -> str:
        return self._name or default

    def name(self, default: str) -> str:
        return self._name or default

    def type(self) -> str:
        return ""


class NodeTypeVisitor(GrammarVisitor):
    """ Returns the type which results from successfully parsing the given node.
    The parse function itself returns ParseResult[the type].
    """
    def visit_NameLeaf(self, node: NameLeaf) -> Type:
        name = node.value
        return name.startswith("invalid")

    def visit_StringLeaf(self, node: StringLeaf) -> Type:
        return Token

    def visit_NamedItem(self, node: NamedItem) -> Type:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> Type:
        return Any

    def visit_Alt(self, node: Alt) -> Type:
        return Any

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> Type:
        return self.visit(node.node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> Type:
        return bool

    def visit_Opt(self, node: Opt) -> Type:
        return Optional[self.visit(node.node)]

    def visit_Repeat0(self, node: Repeat0) -> Tuple[str, str]:
        return List[self.visit(node.node)]

    def visit_Repeat1(self, node: Repeat1) -> Tuple[str, str]:
        return List[self.visit(node.node)]

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Group(self, node: Group) -> Type:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> Type:
        return None

    def visit_Forced(self, node: Forced) -> Type:
        return self.visit(node.node)

    def generic_visit(self, node: GrammarNode) -> Type:
        return Any



class FunctionCallRhs (FunctionCall):
    pass

    def generate(self, gen: ParserGenerator, name: str = None):
        for inline_name, rhs in self.inlines.items():
            gen.print(f"def {name or inline_name}():")
            gen.visit(rhs)


class PythonParserGenerator(ParserGenerator, GrammarVisitor):
    def __init__(
        self,
        grammar: Grammar,
        file: Optional[IO[Text]],
        tokens: Set[str] = set(token.tok_name.values()),
        location_formatting: Optional[str] = None,
        unreachable_formatting: Optional[str] = None,
        verbose: bool = False,
    ):
        tokens.add("SOFT_KEYWORD")
        super().__init__(grammar, tokens, file, verbose=verbose)
        self.invalidvisitor: InvalidNodeVisitor = InvalidNodeVisitor()
        self.unreachable_formatting = unreachable_formatting or "None  # pragma: no cover"
        self.location_formatting = (
            location_formatting
            or "lineno=start_lineno, col_offset=start_col_offset, "
            "end_lineno=end_lineno, end_col_offset=end_col_offset"
        )

    def generate(self, filename: str) -> None:
        self.collect_keywords()
        #self.collect_rules()
        header = self.grammar.metas.get("header", MODULE_PREFIX)
        if header is not None:
            basename = os.path.basename(filename)
            self.print(header.rstrip("\n").format(filename=basename))
        subheader = self.grammar.metas.get("subheader", "")
        if subheader:
            self.print(subheader)
        cls_name = self.grammar.metas.get("class", "GeneratedParser")
        self.print("# Keywords and soft keywords are listed at the end of the parser definition.")
        self.print(f"class {cls_name}(Parser):")
        for rule in dict(self.all_rules).values():
            self.print()
            with self.indent():
                self.visit(rule)

        self.print()
        with self.indent():
            self.print(f"KEYWORDS = {tuple(self.keywords)}")
            self.print(f"SOFT_KEYWORDS = {tuple(self.soft_keywords)}")

        trailer = self.grammar.metas.get("trailer", MODULE_SUFFIX.format(class_name=cls_name))
        if trailer is not None:
            self.print(trailer.rstrip("\n"))

    def alts_uses_locations(self, alts: Sequence[Alt]) -> bool:
        for alt in alts:
            if alt.action and "LOCATIONS" in alt.action:
                return True
            for n in alt.items:
                if isinstance(n.item, Group):
                    if self.alts_uses_locations(n.item.rhs): return True
        return False

    def rule_params(self, rule: Rule) -> str:
        """ The text for parameters to declare a rule. """
        params = ''.join([f', {param.name}: {self.param_type(param)}' for param in (rule.params)])
        return f"(self{params})"

    def param_type(self, param: TypedName) -> str:
        """ What is generated for the type of a parameter, following '{param.name}:'
        The name may have its own parameters, which are generated recursively.
        """
        base_type = param.type or "Any"
        if param.params and len(param.params):
            # This node is a callable type.
            subtypes = [self.param_type(subparam) for subparam in param.params]
            return f'Callable[[{", ".join(subtypes)}], {base_type}]'
        else:
            return base_type

    def visit_Rule(self, node: Rule) -> None:
        self.current_rule = node

        rhs = node.flatten()
        if node.left_recursive:
            if node.leader:
                self.print("@memoize_left_rec")
            else:
                # Non-leader rules in a cycle are not memoized,
                # but they must still be logged.
                self.print("@logger")
        elif node.memo or self.verbose:
            self.print("@memoize")
        node_type = node.type or "Any"
        self.print(f"def {node.name}{self.rule_params(node)} -> Optional[{node_type}]:")
        with self.indent():
            self.print(f"# {node.name}: {rhs}")
        with self.indent():
            self.gen_rhs(rhs)
        self.current_rule = None

    def visit_Rhs(self, node: Rhs,
        ctx: FuncCtx,
        **kwds) -> FuncInfo:
        """ Generate function definition for the Rhs.
        Used only within a Group.  The 'n
        """
        self.print(f"def {ctx.name('_rhs')}():")
        with self.indent():
            self.gen_rhs(node)

        return ctx.func_info('_rhs')

    def gen_rhs(self, node: Rhs) -> None:

        def gen_alt(alt: Alt, suffix: int = 0) -> str:
            name = f"_alt{f'_{suffix}' if suffix else ''}"
            self.print(f"def {name}():")
            with self.indent():
                # The body of the alternative, returns (result,) or None.
                self.visit(alt)
            return name

        alts = node
        if len(alts) == 1:
            gen_alt(alts[0])
            self.print("return self._alt(_alt)")
        else:
            names = []
            for n, alt in enumerate(node, 1):
                names.append(gen_alt(alt, n))
            self.print(f"return self._alts({', '.join(names)})")

    def visit_Alt(self, node: Alt, **kwds) -> None:
        self.failed_value = "None"
        with self.local_variable_context():
            fail_value = "None"
            for item in node.items:
                self.print(f"# {item}")
                # If the item is a Cut, then there's no item name, but there's a Cut function
                if isinstance(item.item, Cut):
                    fail_value = "cut_sentinel"
                    continue
                self.gen_named_item(item, fail_value)

            self.print("# parse succeeded")
            action = self.action(node)
            self.print(f"return ({action}),")

    # Lower level visitors.  Called via self.visit(node, ctx, **kwds).
    # The ctx is one of
    #   -- AltFuncCtx.      Generating the item within an Alt.
    #   -- InlFuncCtx.      Generating an inlined function, using given name.
    # They all call self.gen_func() with:
    #   -- default name for the function.  This varies with the node.
    #   -- call string, which is expression returned by the function.
    #   -- the ctx passed to the visitor.
    #   zero or more of:
    #   -- {inline_name}=Node.  This generates a local function 'name', which parses the Node.
    # The visitor returns a FuncInfo object.

    def visit_NameLeaf(self, node: NameLeaf, **kwds) -> FuncInfo:
        name = node.value
        if name == "SOFT_KEYWORD":
            return self.gen_func("_soft_keyword", f"self._soft_keyword()", **kwds)
        if name in ("NAME", "NUMBER", "STRING", "OP", "TYPE_COMMENT"):
            name = name.lower()
            return self.gen_func(f"_{name}", f"self._{name}()", **kwds)
        if name in ("NEWLINE", "DEDENT", "INDENT", "ENDMARKER", "ASYNC", "AWAIT"):
            # Avoid using names that can be Python keywords
            return self.gen_func("_" + name.lower(), f"self._expect({name!r})", **kwds)
        return self.gen_func(name, f"self.{name}{node.args.show()}", **kwds)

    def visit_StringLeaf(self, node: StringLeaf, **kwds) -> FuncInfo:
        return self.gen_func("_literal", f"self._expect({node.value})", **kwds)

    def visit_PositiveLookahead(self, node: PositiveLookahead, **kwds) -> FuncInfo:
        return self.gen_func("_lookahead", "self._positive_lookahead(_atom)", _atom=node.node, **kwds)

    def visit_NegativeLookahead(self, node: NegativeLookahead, **kwds) -> FuncInfo:
        return self.gen_func("_lookahead", f"self._negative_lookahead(_atom)", _atom=node.node, **kwds)

    def visit_Opt(self, node: Opt, **kwds) -> FuncInfo:
        return self.gen_func("opt", "self._opt(_atom)", _atom=node.node, **kwds)

    def visit_Repeat0(self, node: Repeat0, **kwds) -> FuncInfo:
        return self.gen_func("_loop0", "self._repeat0(_atom)", _atom=node.node, **kwds)

    def visit_Repeat1(self, node: Repeat1, **kwds) -> FuncInfo:
        return self.gen_func("_loop1", "self._repeat1(_atom)", _atom=node.node, **kwds)

    def visit_Gather(self, node: Gather, **kwds) -> FuncInfo:
        return self.gen_func("_gather", "self._gather(_elem, _sep)", _elem=node.node, _sep=node.separator, **kwds)

    def visit_Group(self, node: Group, **kwds) -> FuncInfo:
        return self.visit(node.rhs, **kwds)

    def gen_named_item(self, item: NamedItem, fail_value: str = "None") -> FuncInfo:
        """ Code which parses a single named item in an alt.
        Exits the alt if the parse fails.
        Return info of the function.
        """

        assert isinstance (item, NamedItem)

        info = self.visit(item.item, ctx=AltFuncCtx(item, self))
        name = item.name or info.varname

        item_type = item.type
        #item_type = func.return_type
        if item_type is None: item_type = 'Any'
        rawname = f"_result_{name}"
        rawtype = f"Optional[Tuple[{item_type}]]"
        if isinstance(item.item, Opt):
            item_type = f"Optional[{item_type}]"
        self.print(f"{name}: {item_type}; {rawname}: {rawtype}")
        self.print(f"{rawname} = {info.name}()")
        self.print(f"if not {rawname}: return {fail_value}")
        self.print(f"{name}, = {rawname}")

        return info

    def generic_visit(self, node, **kwds) -> FuncInfo:
        """ This is for a visit function not yet directly implemented. """
        assert 0, f"PythonGenerator has no visitor for {node!r}"


    def gen_func(self,
                 dflt_name: Optional[str],
                 call: str,
                 ctx: FuncCtx,
                 # Any number of these may be given.
                 **inlines: GrammarNode
        ) -> FuncInfo:

        # Determine the name of the function from the ctx argument.

        self.print(f"def {ctx.name(dflt_name)}():")
        with self.indent():
            self.gen_func_body(call, **inlines)
        return ctx.func_info(dflt_name)

    def gen_func_body(self, call: str, **inlines: GrammarNode) -> None:
        for inline_name, inline in inlines.items():
            # Expand the inline items.
            self.visit(inline, ctx=InlFuncCtx(inline_name))
        self.print(f"return {call}")

    def action(self, node: Alt) -> str:
        """ The action for the alt, if it succeeds. """
        action = node.action
        if not action:
            if not node.items:
                action = "True"
            elif self.invalidvisitor.visit(node):
                action = "UNREACHABLE"
            elif len(self.local_variable_names) == 1:
                action = f"{self.local_variable_names[0]}"
            else:
                action = f"[{', '.join(self.local_variable_names)}]"
        elif "LOCATIONS" in action:
            self.print("tok = self._tokenizer.get_last_non_whitespace_token()")
            self.print("end_lineno, end_col_offset = tok.end")
            action = action.replace("LOCATIONS", self.location_formatting)

        if "UNREACHABLE" in action:
            action = action.replace("UNREACHABLE", self.unreachable_formatting)

        return action
