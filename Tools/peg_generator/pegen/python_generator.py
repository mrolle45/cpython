import os.path
import token
from typing import IO, Any, Dict, List, Optional, Sequence, Set, Text, Tuple, Iterable
from dataclasses import dataclass, field, replace

from pegen import grammar
from pegen.grammar import (
    Alt,
    Cut,
    Forced,
    Gather,
    GrammarNode,
    GrammarVisitor,
    Group,
    Lookahead,
    Item,
    NamedItem,
    NameLeaf,
    NegativeLookahead,
    Opt,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
)
from pegen.parser_generator import ParserGenerator

MODULE_PREFIX = """\
#!/usr/bin/env python3.8
# @generated by pegen from {filename}

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser, cut_sentinel

"""
MODULE_SUFFIX = """

if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main({class_name})
"""


class InvalidNodeVisitor(GrammarVisitor):
    def visit_NameLeaf(self, node: NameLeaf) -> bool:
        name = node.value
        return name.startswith("invalid")

    def visit_StringLeaf(self, node: StringLeaf) -> bool:
        return False

    def visit_NamedItem(self, node: NamedItem) -> bool:
        return self.visit(node.item)

    def visit_Rhs(self, node: Rhs) -> bool:
        return any(self.visit(alt) for alt in node)

    def visit_Alt(self, node: Alt) -> bool:
        return any(self.visit(item) for item in node.items)

    def lookahead_call_helper(self, node: Lookahead) -> bool:
        return self.visit(node.node)

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> bool:
        return self.lookahead_call_helper(node)

    def visit_Opt(self, node: Opt) -> bool:
        return self.visit(node.node)

    def visit_Repeat(self, node: Repeat0) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        return self.visit(node.node)

    def visit_Group(self, node: Group) -> bool:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> bool:
        return False

    def visit_Forced(self, node: Forced) -> bool:
        return self.visit(node.node)


# FunctionCall class.
# Has members to describe what is to be generated to produce the body of a parse function or method.
# The generate(gen) method does the actual generation, using `gen` as the output writer.
# Subclasses are variations for certain classes of parse nodes.

@dataclass
class FunctionCall:
    var: Optional[str]
    call: str
    var_type: Optional[str] = None      # The type of a designated variable for a NamedItem.
    return_type: Optional[str] = None
    inlines: Dict[str, Item] = field(default_factory=dict)       # Local functions defined before the call.

    @property
    def inline_names(self) -> List[str]:
        return [inline.name for inline in self.inlines]

    def generate(self, gen: ParserGenerator, varname: Optional[str] = None, fail_value: str = "None"):
        gen.gen_func_old(self, varname, fail_value)


class NamedItemFunctionCall (FunctionCall):
    pass


class FunctionCallRhs (FunctionCall):
    pass

    def generate(self, gen: ParserGenerator, varname: Optional[str] = None, fail_value: str = "None"):
        for rhs in self.inlines.values():
            gen.print(f"def {list(self.inlines)[0]}():")
            gen.visit(rhs)


class PythonCallMakerVisitor(GrammarVisitor):
    def __init__(self, parser_generator: ParserGenerator):
        self.gen = parser_generator
        self.cache: Dict[Any, Any] = {}

    def visit_NameLeaf(self, node: NameLeaf) -> Tuple[Optional[str], str]:
        # TODO:  Parse a variable/parameter as a simple callable, not a method.
        name = node.value
        if name == "SOFT_KEYWORD":
            return FunctionCall("_soft_keyword", "self._soft_keyword()")
        if name in ("NAME", "NUMBER", "STRING", "OP", "TYPE_COMMENT"):
            name = name.lower()
            return FunctionCall(f"_{name}", f"self._{name}()")
        if name in ("NEWLINE", "DEDENT", "INDENT", "ENDMARKER", "ASYNC", "AWAIT"):
            # Avoid using names that can be Python keywords
            return FunctionCall("_" + name.lower(), f"self._expect({name!r})")
        return FunctionCall(name, f"self.{name}{node.args.show()}")

    def visit_StringLeaf(self, node: StringLeaf) -> Tuple[str, str]:
        return FunctionCall("_literal", f"self._expect({node.value})")

    def visit_Rhs(self, node: Rhs) -> Tuple[Optional[str], str]:
        if node in self.cache:
            return self.cache[node]
        if len(node) == 1 and len(node[0].items) == 1:
            self.cache[node] = self.visit(node[0].items[0])
        else:
            self.cache[node] = FunctionCallRhs(
                "_rhs", "self._rhs(_group)", inlines=dict(_group=node))
            self.visit(node)
            #name = self.gen.artificial_rule_from_rhs((node))
            #self.cache[node] = FunctionCall(name, f"self.{name}{self.args_from_params()}")
        return self.cache[node]

    def visit_NamedItem(self, node: NamedItem) -> Tuple[Optional[str], str]:
        func = self.visit(node.item)
        if node.name:
            func = replace(func, var=node.name)
        return func

    def lookahead_call_helper(self, node: Lookahead, method: str) -> Tuple[str, str]:
        return FunctionCall("_lookahead", f"self.{method}(_atom)", inlines=dict(_atom=node.node))

    def visit_PositiveLookahead(self, node: PositiveLookahead) -> Tuple[None, str]:
        return self.lookahead_call_helper(node, '_positive_lookahead')

    def visit_NegativeLookahead(self, node: NegativeLookahead) -> Tuple[None, str]:
        return self.lookahead_call_helper(node, '_negative_lookahead')

    def visit_Opt(self, node: Opt) -> Tuple[str, str]:
        return FunctionCall("_lookahead", f"self._opt(_atom)", inlines=dict(_atom=node.node))
        #func = self.visit(node.node)
        #return replace(func, call=f"self._opt({func.call})")

    def visit_Repeat0(self, node: Repeat0) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        self.cache[node] = FunctionCall("_loop0", "self._repeat0(_node)", inlines=dict(_node=node.node))
        self.visit(node.node)
        return self.cache[node]

    def visit_Repeat1(self, node: Repeat1) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        self.cache[node] = FunctionCall("_loop1", "self._repeat1(_node)", inlines=dict(_node=node.node))
        self.visit(node.node)
        return self.cache[node]

    def visit_Gather(self, node: Gather) -> Tuple[str, str]:
        if node in self.cache:
            return self.cache[node]
        self.cache[node] = FunctionCall("_gather", "self._gather(_elem, _sep)", inlines=dict(_elem=node.node, _sep=node.separator))
        self.visit(node.node)
        return self.cache[node]

    def visit_Group(self, node: Group) -> Tuple[Optional[str], str]:
        return self.visit(node.rhs)

    def visit_Cut(self, node: Cut) -> Tuple[str, str]:
        return FunctionCall("cut", "cut_sentinel,")

    def visit_Forced(self, node: Forced) -> Tuple[str, str]:
        if isinstance(node.node, Group):
            _, val = self.visit(node.node.rhs)
            return FunctionCall("forced", f"self._expect_forced({val}, '''({node.node.rhs!s})''')")
        else:
            return FunctionCall(
                "forced",
                f"self._expect_forced(self._expect({node.node.value}), {node.node.value!r})",
            )

    def return_type(self, node: Any) -> str:
        """ The type resulting from calling the node. """
        return self.visit(node).type

    def args_from_params(self) -> str:
        """ Argument list to call an artificial rule using names of main Rule parameters. """
        params = self.gen.current_rule.params
        if not params: return "()"
        return f'({", ".join([param.name for param in params])})'

class PythonParserGenerator(ParserGenerator, GrammarVisitor):
    def __init__(
        self,
        grammar: grammar.Grammar,
        file: Optional[IO[Text]],
        tokens: Set[str] = set(token.tok_name.values()),
        location_formatting: Optional[str] = None,
        unreachable_formatting: Optional[str] = None,
        verbose: bool = False,
    ):
        tokens.add("SOFT_KEYWORD")
        super().__init__(grammar, tokens, file, verbose=verbose)
        self.callmakervisitor: PythonCallMakerVisitor = PythonCallMakerVisitor(self)
        self.invalidvisitor: InvalidNodeVisitor = InvalidNodeVisitor()
        self.unreachable_formatting = unreachable_formatting or "None  # pragma: no cover"
        self.location_formatting = (
            location_formatting
            or "lineno=start_lineno, col_offset=start_col_offset, "
            "end_lineno=end_lineno, end_col_offset=end_col_offset"
        )

    def generate(self, filename: str) -> None:
        self.collect_keywords()
        #self.collect_rules()
        header = self.grammar.metas.get("header", MODULE_PREFIX)
        if header is not None:
            basename = os.path.basename(filename)
            self.print(header.rstrip("\n").format(filename=basename))
        subheader = self.grammar.metas.get("subheader", "")
        if subheader:
            self.print(subheader)
        cls_name = self.grammar.metas.get("class", "GeneratedParser")
        self.print("# Keywords and soft keywords are listed at the end of the parser definition.")
        self.print(f"class {cls_name}(Parser):")
        for rule in dict(self.all_rules).values():
            self.print()
            with self.indent():
                self.visit(rule)

        self.print()
        with self.indent():
            self.print(f"KEYWORDS = {tuple(self.keywords)}")
            self.print(f"SOFT_KEYWORDS = {tuple(self.soft_keywords)}")

        trailer = self.grammar.metas.get("trailer", MODULE_SUFFIX.format(class_name=cls_name))
        if trailer is not None:
            self.print(trailer.rstrip("\n"))

    def alts_uses_locations(self, alts: Sequence[Alt]) -> bool:
        for alt in alts:
            if alt.action and "LOCATIONS" in alt.action:
                return True
            for n in alt.items:
                if isinstance(n.item, Group):
                    if self.alts_uses_locations(n.item.rhs): return True
        return False

    def rule_params(self, rule: Rule) -> str:
        """ The text for parameters to declare a rule. """
        params = ''.join([f', {param.name}: {self.param_type(param)}' for param in (rule.params)])
        return f"(self{params})"

    def param_type(self, param: TypedName) -> str:
        """ What is generated for the type of a parameter, following '{param.name}:'
        The name may have its own parameters, which are generated recursively.
        """
        base_type = param.type or "Any"
        if param.params and len(param.params):
            # This node is a callable type.
            subtypes = [self.param_type(subparam) for subparam in param.params]
            return f'Callable[[{", ".join(subtypes)}], {base_type}]'
        else:
            return base_type

    def visit_Rule(self, node: Rule) -> None:
        self.current_rule = node

        rhs = node.flatten()
        if node.left_recursive:
            if node.leader:
                self.print("@memoize_left_rec")
            else:
                # Non-leader rules in a cycle are not memoized,
                # but they must still be logged.
                self.print("@logger")
        elif node.memo or self.verbose:
            self.print("@memoize")
        node_type = node.type or "Any"
        self.print(f"def {node.name}{self.rule_params(node)} -> Optional[{node_type}]:")
        with self.indent():
            self.print(f"# {node.name}: {rhs}")
        self.visit_Rhs(rhs)
        self.current_rule = None

    def visit_Rhs(self, node: Rhs) -> None:

        def gen_alt(alt: Alt, suffix: int = 0) -> str:
            name = f"_alt{f'_{suffix}' if suffix else ''}"
            self.print(f"def {name}():")
            with self.indent():
                # The body of the alternative, returns (result,) or None.
                self.visit(alt)
            return name

        with self.indent():
            alts = node
            if len(alts) == 1:
                gen_alt(alts[0])
                self.print("return self._alt(_alt)")
            else:
                names = []
                with self.indent(0):
                    for n, alt in enumerate(node, 1):
                        names.append(gen_alt(alt, n))
                    self.print(f"return self._alts({', '.join(names)})")


    def visit_Alt(self, node: Alt) -> None:
        self.failed_value = "None"
        with self.local_variable_context():
            func_names = []
            item_names = []
            fail_value = "None"
            for item in node.items:
                self.print(f"# {item}")
                # If the item is a Cut, then there's no item name, but there's a Cut function
                if isinstance(item.item, Cut):
                    fail_value = "cut_sentinel"
                    func_names.append("cut_sentinel")
                    continue
                item_name = self.gen_named_item(item, fail_value)
                item_names.append(item_name)
                func_names.append(f"_item_{item_name}")
            if item_names:
                item_targets = f"[{', '.join(item_names)}]"
                items_call = f"self._items({', '.join(func_names)})"
                #self.print(f"_items = {items_call}")
                #self.print("if not _items: return _items")
                #self.print(f"{item_targets} = _items")

            self.print("# parse succeeded")
            action = self.action(node)
            self.print(f"return ({action}),")

    def gen_named_item(self, item: NamedItem, fail_value: str = "None") -> str:
        """ Code which parses a single named item in an alt.
        Exits the alt if the parse fails.
        Return name of the variable.  The function name is _Item_{name}
        """

        assert isinstance (item, NamedItem)

        func: FunctionCall = self.callmakervisitor.visit(item)
        if item.name:
            name = item.name
        else:
            name = func.var
        name = self.dedupe(name)
        item_type = func.return_type
        if item_type is None: item_type = 'Any'
        rawname = f"_item_{name}"
        rawtype = f"Optional[Tuple[{item_type}]]"
        if isinstance(item.item, Opt):
            item_type = f"Optional[{item_type}]"
        self.print(f"{name}: {item_type}; {rawname}: {rawtype}")
        func.generate(self, name, fail_value)

        return name

    def gen_func_old(self, func: FunctionCall, varname: str = None, fail_value: str = "None"):
        for inline_name, inline in func.inlines.items():
            # Expand the inline items.
            self.print(f"def {inline_name}():")
            with self.indent():
                inline_func = self.callmakervisitor.visit(inline)
                inline_func.generate(self)
                self.print(f"return {inline_func.call}")
        if varname:
            rawname = f"_item_{varname}"
            self.print(f"{rawname} = {func.call}")
            self.print(f"if not {rawname}: return {fail_value}")
            self.print(f"{varname}, = {rawname}")

            #self.print(f"_item = {func.call}")
            #self.print(f"nonlocal {varname}")
            #self.print(f"if _item: {varname}, = _item")
            #self.print(f"return _item")
        #else:
        #    self.print(f"return {func.call}")

    #def gen_atom(self, atom: Plain) -> str:
    #    """ Text of call to get the value of the node.
    #    Also prints defs of any other functions involved.
    #    """
    #    func = self.callmakervisitor.visit(atom)
    #    if func.call: return func.call
    #    # Expand the atom inline.
    #    self.print("def _elem():")
    #    with self.indent():
    #        _, call, _ = self.callmakervisitor.visit(atom)
    #        self.print(f"return {call}")
    #    if type(item.item) is Gather:
    #        self.print("def _sep():")
    #        with self.indent():
    #            _, call, _ = self.callmakervisitor.visit(item.item.separator)
    #            self.print(f"return {call}")
    #        return f"self._gather(_elem, _sep)"
    #    else:
    #        return f"self._{type(item.item).__name__.lower()}(_elem)"

    def action(self, node: Alt) -> str:
        """ The action for the alt, if it succeeds. """
        action = node.action
        if not action:
            if not node.items:
                action = "True"
            elif self.invalidvisitor.visit(node):
                action = "UNREACHABLE"
            elif len(self.local_variable_names) == 1:
                action = f"{self.local_variable_names[0]}"
            else:
                action = f"[{', '.join(self.local_variable_names)}]"
        elif "LOCATIONS" in action:
            self.print("tok = self._tokenizer.get_last_non_whitespace_token()")
            self.print("end_lineno, end_col_offset = tok.end")
            action = action.replace("LOCATIONS", self.location_formatting)

        if "UNREACHABLE" in action:
            action = action.replace("UNREACHABLE", self.unreachable_formatting)

        return action
