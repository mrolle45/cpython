@subheader """\
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    AltItem,
    AltItems,
    Arg,
    Args,
    Cut,
    Forced,
    Gather0,
    Gather1,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NegativeLookahead,
    Opt,
    Param,
    Params,
    PositiveLookahead,
    Primary,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
    VarItem,
)
"""

start[Grammar]: grammar=grammar ENDMARKER { grammar }

grammar[Grammar]:
    | metas=meta* rules=rule+ { Grammar(rules, metas) }

meta[Meta]:
    | "@" name=NAME val=metavalue? NEWLINE { Meta(name.string, val) }

metavalue[str]:
    | val=NAME { val.string }
    | val=STRING { literal_eval(val.string) }
    | { None }

rule[Rule]:
    | n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts? {
          Rule(n, Rhs(a + aa), memo=m) }

params[Params]:
    | !memoflag '(' n=','.param+ [','] ')' { Params(n) }
    | '(' ')' { Params([]) }

param[Param]:
    | n=typed_name { Param(n) }

typed_name[TypedName]:
    | n=NAME p=params? typ=annotation? { TypedName(n.string, typ, p) }

# In the future this may return something more complicated
memoflag[str]:
    | '(' "memo" ')' { "memo" }

# Alternatives, in various contexts.  Returns an Rhs holding the alternatives.
#   Within (...) or [...], or after indented '|'.  One or more with '|' separator.
alts[Rhs]:
    | a="|".alt+  { Rhs(a) }

#   After ':' in a rule on same line.  Zero or more with '|' separator.
maybe_alts[Rhs] (memo):
    | !NEWLINE a="|".alt+  { Rhs(a) }
    | { Rhs([]) }

#   Indented block following a rule, each line introduced by '|', or nothing.
more_alts[Rhs] (memo):
    | INDENT a=( "|" b=alts NEWLINE { b } )+ DEDENT { Rhs (chain (*a)) }
    | { Rhs(()) }

# Single alternative.  May be nothing at all.
alt[Alt]:
    | i=alt_items a=action? { Alt(i, action=a) }

alt_items[AltItems]:
    | ii=alt_item* { AltItems(ii) }

alt_item[AltItem]:
    | n=typed_name '=' ~ i=item {VarItem(n, i)}
    | item

item[Item] (memo):
    | '&' '&' ~ i=item {Forced(i)}
    | '&' ~ i=item {PositiveLookahead(i)}
    | '!' ~ i=item {NegativeLookahead(i)}
    | '~' {Cut()}
    | atom

atom[Atom] (memo):
    | a=atom '?' {Opt(a)}
    | a=atom '*' {Repeat0(a)}
    | a=atom '+' {Repeat1(a)}
    | sep=atom '.' node=primary '*' {Gather0(sep, node)}
    | sep=atom '.' node=primary '+' {Gather1(sep, node)}
    | primary

primary[Primary] (memo):
    | '(' ~ a=alts ')' typ=annotation? {Group(Rhs(a, typ))}
    | '[' ~ a=alts ']' typ=annotation? {Opt(Group(Rhs(a, typ)))}
    | n=NAME a=arguments? {NameLeaf(n.string, a) }
    | s=STRING {StringLeaf(s.string)}

# Mini-grammar for the actions and annotations and call arguments

action[str]: "{" t=target_atoms "}" { t }
annotation[str]: "[" t=target_atoms "]" { t }
arguments[Args]:
    | '(' a=arg "," b=",".arg+ ","? ')'  { Args([a] + b) }  # Multiple args, comma optional
    | '(' a=arg "," ')' { Args([a]) }                       # One arg, comma required.
    | '(' ')' { Args() }                                    # No args, no comma.
arg[Arg]: a=arg_atom+ { Arg(" ".join(a)) }
arg_atom: !"," a=target_atom { a }

target_atoms[str]:
    | a=target_atom+ { " ".join(a) }

target_atom[str] (memo):
    | "(" atoms=target_atoms? ")" { "(" + (atoms or "") + ")" }
    | "{" atoms=target_atoms? "}" { "{" + (atoms or "") + "}" }
    | "[" atoms=target_atoms? "]" { "[" + (atoms or "") + "]" }
    | n=NAME "*" { n.string + "*" }
    | n=NAME { n.string }
    | n=NUMBER { n.string }
    | s=STRING { s.string }
    | "?" { "?" }
    | ":" { ":" }
    | !")" !"}" !"]" op=OP { op.string }
