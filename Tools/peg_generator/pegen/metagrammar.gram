@subheader """\
from ast import literal_eval
from itertools import chain

from pegen.grammar import (
    Alt,
    Alts,
    Args,
    Cut,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    LookaheadOrCut,
    MetaTuple,
    MetaList,
    NameLeaf,
    NamedItem,
    NamedItemList,
    NegativeLookahead,
    Nothing,
    Opt,
    Params,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    RuleList,
    TypedName,
    Grammar,
    StringLeaf,
)
"""

start[Grammar]: grammar=grammar ENDMARKER { grammar }

grammar[Grammar]:
    | metas=meta* rules=rule+ { Grammar(rules, metas) }

meta[MetaTuple]:
    | "@" name=NAME NEWLINE { (name.string, None) }
    | "@" name=NAME val=NAME NEWLINE { (name.string, val.string) }
    | "@" name=NAME val=STRING NEWLINE { (name.string, literal_eval(val.string)) }

rule[Rule]:
    | n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts? {
          Rule(n, Rhs(a + aa), memo=m) }

params[Params]:
    | !memoflag '(' n=','.typed_name+ [','] ')' { Params(n) }
    | '(' ')' { Params([]) }

typed_name[TypedName]:
    | n=NAME p=params? a=annotation? { TypedName(n.string, p, a) }

# In the future this may return something more complicated
memoflag[str]:
    | '(' "memo" ')' { "memo" }

alts[Alts]:
    | a="|".alt+  { Alts(a) }

maybe_alts[Alts]:
    | !NEWLINE a="|".alt+  { Alts(a) }
    | NOTHING { Alts() }

more_alts[Alts]:
    | INDENT a=( "|" b=alts NEWLINE { b } )+ DEDENT { Alts (chain (*a)) }
    | NOTHING { Alts() }

alt[Alt]:
    | i=items e=enditem? a=action? { Alt(i + (e and [e] or []), action=a) }

items[NamedItemList]:
    | n=named_item* { n }

named_item[NamedItem]:
    | n=typed_name '=' ~ item {NamedItem(n, item)}
    | it=item {NamedItem(None, it)}
    | forced=forced_atom {NamedItem(None, forced)}
    | it=lookahead {NamedItem(None, it)}
    | cut=cut {NamedItem(None, cut)}

forced_atom[Forced]:
    | '&''&' ~ a=atom {Forced(a)}

lookahead[Lookahead]:
    | '&' ~ a=atom {PositiveLookahead(a)}
    | '!' ~ a=atom {NegativeLookahead(a)}

cut[Cut]:
    | '~' {Cut()}

item[Item]:
    | '[' ~ alts ']' {Opt(alts)}
    |  a=atom '?' {Opt(a)}
    |  a=atom '*' {Repeat0(a)}
    |  a=atom '+' {Repeat1(a)}
    |  sep=atom '.' node=atom '+' {Gather(sep, node)}
    |  a=atom {a}

enditem[NamedItem]:
    | '$' { NamedItem(None, NameLeaf('ENDMARKER')) }

atom[Plain]:
    | '(' ~ alts ')' {Group(Rhs(alts))}
    | n=NAME a=arguments? {NameLeaf(n.string, a) }
    | s=STRING {StringLeaf(s.string)}

# Mini-grammar for the actions and annotations and rule arguments

action[str]: "{" t=target_atoms "}" { t }
annotation[str]: "[" t=target_atoms "]" { t }
arguments[Args]:
    | '(' a=arg "," b=",".arg+ c=[","]')'  { Args([a] + b, comma=c and c.string) } # Multiple args, comma optional
    | '(' a=arg "," ')' { Args([a], comma=",") }                                   # One arg, comma required.
    | '(' ')' { Args() }                                                     # No args, no comma.
arg: a=arg_atom+ { " ".join(a) }
arg_atom: !"," a=target_atom { a }

target_atoms[str]:
    | a=target_atom+ { " ".join(a) }

target_atom[str]:
    | "(" atoms=target_atoms? ")" { "(" + (atoms or "") + ")" }
    | "{" atoms=target_atoms? "}" { "{" + (atoms or "") + "}" }
    | "[" atoms=target_atoms? "]" { "[" + (atoms or "") + "]" }
    | n=NAME "*" { n.string + "*" }
    | n=NAME { n.string }
    | n=NUMBER { n.string }
    | s=STRING { s.string }
    | "?" { "?" }
    | ":" { ":" }
    | !")" !"}" !"]" op=OP { op.string }
