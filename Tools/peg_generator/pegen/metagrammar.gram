@subheader """\
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    Args,
    Cut,
    Forced,
    Gather,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NamedItem,
    NamedItems,
    NegativeLookahead,
    Opt,
    Params,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    TypedName,
    Grammar,
    StringLeaf,
)
"""

start[Grammar]: grammar=grammar ENDMARKER { grammar }

grammar[Grammar]:
    | metas=meta* rules=rule+ { Grammar(rules, metas) }

meta[Meta]:
    | "@" name=NAME val=metavalue? NEWLINE { Meta(name.string, val) }

metavalue[Optional[str]]:
    | val=NAME { val.string }
    | val=STRING { literal_eval(val.string) }
    | { None }

rule[Rule]:
    | n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts? {
          Rule(n, Rhs(a + aa), memo=m) }

params[Params]:
    | !memoflag '(' n=','.typed_name+ [','] ')' { Params(n) }
    | '(' ')' { Params([]) }

typed_name[TypedName]:
    | n=NAME p=params? a=annotation? { TypedName(n.string, p, a) }

# In the future this may return something more complicated
memoflag[str]:
    | '(' "memo" ')' { "memo" }

# Alternatives, in various contexts.  Returns an Rhs holding the alternatives.
#   Within (...) or [...], or after indented '|'.  One or more with '|' separator.
alts[Rhs]:
    | a="|".alt+  { Rhs(a) }

#   After ':' in a rule on same line.  Zero or more with '|' separator.
maybe_alts[Rhs] (memo):
    | !NEWLINE a="|".alt+  { Rhs(a) }
    | { Rhs([]) }

#   Indented block following a rule, each line introduced by '|', or nothing.
more_alts[Rhs] (memo):
    | INDENT a=( "|" b=alts NEWLINE { b } )+ DEDENT { Rhs (chain (*a)) }
    | { Rhs() }

# Single alternative.  May be nothing at all.
alt[Alt]:
    | i=items e=endmarker a=action? { Alt(i + e, action=a) }

items[NamedItems]:
    | n=named_item* { NamedItems(n) }

named_item[NamedItem] (memo):
    | n=typed_name '=' ~ item {NamedItem(n, item)}
    | it=item {NamedItem(None, it)}
    | forced=forced_atom {NamedItem(None, forced)}
    | it=lookahead {NamedItem(None, it)}
    | cut=cut {NamedItem(None, cut)}

forced_atom[Forced]:
    | '&''&' ~ a=atom {Forced(a)}

lookahead[Lookahead]:
    | '&' ~ a=atom {PositiveLookahead(a)}
    | '!' ~ a=atom {NegativeLookahead(a)}

cut[Cut]:
    | '~' {Cut()}

item[Item] (memo):
    | '[' ~ alts ']' {Opt(alts)}
    |  a=atom '?' {Opt(a)}
    |  a=atom '*' {Repeat0(a)}
    |  a=atom '+' {Repeat1(a)}
    |  sep=atom '.' node=atom '+' {Gather(sep, node)}
    |  a=atom {a}

endmarker[NamedItems]:
    | '$' { NamedItems([NamedItem(None, NameLeaf('ENDMARKER'))]) }
    | { NamedItems() }

atom[Plain] (memo):
    | '(' ~ alts ')' {Group((alts))}
    | n=NAME a=arguments? {NameLeaf(n.string, a) }
    | s=STRING {StringLeaf(s.string)}

# Mini-grammar for the actions and annotations and rule arguments

action[str]: "{" t=target_atoms "}" { t }
annotation[str]: "[" t=target_atoms "]" { t }
arguments[Args]:
    | '(' a=arg "," b=",".arg+ c=[","]')'  { Args([a] + b, comma=c and c.string) } # Multiple args, comma optional
    | '(' a=arg "," ')' { Args([a], comma=",") }                                   # One arg, comma required.
    | '(' ')' { Args() }                                                     # No args, no comma.
arg: a=arg_atom+ { " ".join(a) }
arg_atom: !"," a=target_atom { a }

target_atoms[str]:
    | a=target_atom+ { " ".join(a) }

target_atom[str] (memo):
    | "(" atoms=target_atoms? ")" { "(" + (atoms or "") + ")" }
    | "{" atoms=target_atoms? "}" { "{" + (atoms or "") + "}" }
    | "[" atoms=target_atoms? "]" { "[" + (atoms or "") + "]" }
    | n=NAME "*" { n.string + "*" }
    | n=NAME { n.string }
    | n=NUMBER { n.string }
    | s=STRING { s.string }
    | "?" { "?" }
    | ":" { ":" }
    | !")" !"}" !"]" op=OP { op.string }
