@subheader """\
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    AltItem,
    AltItems,
    Arg,
    Args,
    Cut,
    Forced,
    FuncType,
    Gather0,
    Gather1,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NegativeLookahead,
    NoArgs,
    NoName,
    NoType,
    NoParams,
    ObjName,
    ObjType,
    Opt,
    OptVal,
    OptGroup,
    Param,
    Params,
    PositiveLookahead,
    Primary,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    Type,
    TypedName,
    VarItem,
)

from pegen.target_code import Code, NoCode
"""

start[Grammar]: g=grammar endmarker { g }

endmarker: ENDMARKER | "END" NEWLINE

grammar[Grammar]:
    | metas=meta* rules=rule+ { Grammar(rules, metas) }

meta[Meta]:
    | "@" name=NAME val=metavalue NEWLINE { Meta(name.string, val) }

metavalue[str]:
    | val=NAME { val.string }
    | val=STRING { literal_eval(val.string) }
    | { None }

rule[Rule]:
    | n=typed_name m=memoflag? ":" a=maybe_alts? NEWLINE aa=more_alts? {
          Rule(n, Rhs([*chain (*a, *aa)]), memo=m) }

# In the future this may return something more complicated
memoflag[str]:
    | '(' "memo" ')' { "memo" }

# Alternatives, in various contexts.  Returns an Rhs holding the alternatives...
#   ...Within (...) or [...], or after indented '|'.  One or more with '|' separator.
alts[Rhs]:
    | a="|".alt+  { Rhs(a) }

#   ...After ':' in a rule on same line.  Zero or more with '|' separator.
maybe_alts[Rhs] (memo):
    | !NEWLINE a="|".alt+  { Rhs(a) }
    | { Rhs([]) }

#   ...Indented block following a rule, each line introduced by '|', or nothing.
more_alts[Rhs] (memo):
    | INDENT a=( "|" b=alts NEWLINE { b } )+ DEDENT { Rhs([*chain (*a)]) }
    | { Rhs(()) }

# Single alternative.  May be nothing at all.
alt[Alt]:
    | i=alt_items a=action? { Alt(i, action=Code(a.opt)) }

alt_items[AltItems]:
    | ii=alt_item* { AltItems(ii) }

alt_item[AltItem]:
    | n=typed_name '=' ~ i=item {VarItem(n, i)}
    | i=item {VarItem(None, i)}

item[Item] (memo):
    | '&' '&' ~ i=item {Forced(i)}
    | '&' ~ i=item {PositiveLookahead(i)}
    | '!' ~ i=item {NegativeLookahead(i)}
    | '~' {Cut()}
    | atom

atom[Atom] (memo):
    | a=atom '?' {Opt(a)}
    | a=atom '*' {Repeat0(a)}
    | a=atom '+' {Repeat1(a)}
    | sep=atom '.' node=primary '*' {Gather0(sep, node)}
    | sep=atom '.' node=primary '+' {Gather1(sep, node)}
    | primary

primary[Primary] (memo):
    | '(' ~ a=alts ')' t=type? {Group(Rhs(a.alts), t)}
    | '[' ~ a=alts ']' t=type? {OptGroup(Rhs(a.alts), t)}
    | n=NAME a=arguments {NameLeaf(n, a) }
    | s=STRING {StringLeaf(s)}

# Properties of other parsed expressions:
#   name, type, param, and combinations of these.

name[ObjName]:
    | n=NAME { ObjName(n.string) }

type[Type]:
    | '[' a=annotation? pp=params* ']' { Type(a.opt, *pp) }

param[Param]:           # name and/or type required.
    | n=typed_name { Param(n) }
    | t=type { Param(TypedName(NoName(), t)) }
          
params[Params]:
    | '<' pp=','.param* ','? '>' { Params(pp) }     # One or more params, trailing comma optional
    | '<' '>' { Params([]) }                        # No params, no comma.

typed_name[TypedName]:                                      # Name with optional type.
    | n=name typ=type? { TypedName(n, typ) }

# Mini-grammar for the actions and annotations and call arguments

action[Code]: "{" t=target_atoms "}" { Code(t) }
annotation[Code]:
    | "[" t=target_atoms "]" { Code(t) }

arguments[Args]:
    | '<' aa=",".arg+ ","? '>'  { Args(aa) }  # One or more args, trailing comma optional
    | '<' '>' { Args([]) }                    # No args, no comma.
    | { NoArgs() }                            # Absent.

annotation[Code]:                                       # Target code up to an ungrouped "<" or "]".
    | aa=anno_atom+ { Code ([*chain.from_iterable(aa)]) }
anno_atom[list[Token]]: !"<" !"]" a=target_atom { a }        # Target code not beginning with "<" or "]".

arg[Arg]: a=arg_atom+ { Arg(Code([*chain(*a)])) }       # Target code up to an ungrouped "," or ">".
arg_atom[list[Token]]: !"," !">" a=target_atom { a }    # Target code not beginning with "," or ">".

target_atoms[list[Token]]:
    | a=target_atom* { [*chain.from_iterable(a)] }

target_atom[list[Token]] (memo):
    | l="(" atoms=target_atoms? r=")" { [l, *chain(*(atoms)), r] }
    | l="{" atoms=target_atoms? r="}" { [l, *chain(*(atoms)), r] }
    | l="[" atoms=target_atoms? r="]" { [l, *chain(*(atoms)), r] }
    | n=NAME star="*" { [n, star] }
    | n=NAME { [n] }
    | n=NUMBER { [n] }
    | s=STRING { [s] }
    | c="?" { [c] }
    | c=":" { [c] }
    | !")" !"}" !"]" op=OP { [op] }
