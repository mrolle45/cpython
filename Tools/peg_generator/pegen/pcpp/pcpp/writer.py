""" writer.py.
This is the code for formatting and writing the output file.
It gets its data from an iterator of PpTok objects generated by
the various source files.
"""

from __future__ import annotations

import re
import textwrap


from pcpp.common import *
from pcpp.tokens import TokIter, TokenSep

class Writer:
    """ Object which accepts an iterator of PpTok's and writes
    to the output file.
    """

    def __init__(self, prep: PreProcessor):
        self.prep = prep
        self.lexer = prep.lexer

    def write(
            self,
            tokens: Callable[[], PpTok],    # Generated by Source files
            out: TextIO,                    # Output file, already open
            ):
        self.tokens = tokens
        prep = self.prep

        # OutLoc objects currently in use, ending with the most recent.
        outlocs: Stack[OutLoc] = Stack()

        outloc: OutLoc              # Current location, in current Source.
        outloc = None
        callback: LocalCallback
        callback = None

        in_macro: OutLoc        # Most recent locator came from arg list of
                                # macro call at this location.
        in_macro = None

        ''' Overall strategy:
        self.write() takes an iterable `tokens` of PpTok's, and writes text
            to the output file `out`, using self.output().

        The input tokens come from the top level Source.  It has already done
            translation phases 1 through 4 (C99 5.1.1.2 pp 1.1-1.4), which
            means that #include'd files are likewise translated.

        There are no directives coming from the Source, except as enabled by
            various passthru command options.

        As the Standard considers the preprocessor as merely translation phase
            4, only actual preprocessing tokens are involved.  Whitespace is no
            longer relevant.  In fact, it is mostly irrelevant during the
            preprocessing itself.

        The function of PCPP is to write a preprocessed file ("filename.i",
            typically), such that if this file is given to another compiler,
            that compiler can skip translation phase 4 and generate the
            identical sequence of preprocessor tokens as it would have from the
            original source file(s) with preprocessing.

        The output file needs to have the same tokens, in textual form, as come
        from the input.  It doesn't matter if the original spelling is
        preserved, as long as it lexes to the same token.  In particular,
        trigraphs and line splices can remain as they came out of phases 1 and
        2.

        PCPP will preserve leading indentation before all nonempty source
        lines, even if altered by macros.  Otherwise, whitespace is condensed
        to single space characters.

        PCPP must separate consecutive tokens with extra whitespace when this
        affects the result of lexing the output.  This can happen when macro
        expansion results in consecutive tokens which were not originally
        consecutive.  See
        https://gcc.gnu.org/onlinedocs/cppinternals/Token-Spacing.html for how
        GCC does this.

        PCPP also preserves the (presumed) file and line number for every line
        in the output so that it is the same as where the line originated.  The
        presumed location can be altered by #line directives in the input.  The
        output file will contain #line directives as needed.

        Blank lines in small groups will be output, but larger groups will
        result in a #line directive to set the new line number.

        The Source doesn't actually generate anything for blank lines.  Rather,
        it generates a special OutLoc token at the start of each line to
        denote the line number.  It also indicates any indentation of the line.


        Items written to output() are:
            * Actual input token values.  Most tokens are written, but not all.
            * Indentation.  Several spaces in front of a non-blank line.
            * Extra newlines.
            * Line directives.

        1. An OutLoc (writer.OutLoc class) denotes the presumed file name
            and line number.  The Writer maintains the current OutLoc for
            both the input and the output.

        2. A Line (a logical line, actually) is stored in a Tokens object.
            It represents all the generated tokens up to the next newline
            token.  It has a OutLoc and a following OutLoc.  The following
            location is the line after location of the ending newline.  This
            will be two or more lines after the line location if there were
            escaped newlines which pasted physical lines into a logical line.

        3. Input tokens are collected into Lines.
            The Line location is determined as follows: * If there is a
            CPP_NEWPOS token received, which will be at the
                beginning of the Line, this sets the Line location, and is
                discarded.  It also writes the necessary #line directive, or
                newline character(s), to bring the output to that location.
            * Otherwise, the Line location is the following OutLoc of the
                previous Line.

        4. A generator method generates all the Lines, except empty ones.
            A line with only a CPP_MARK is empty, except in gcc mode.

        5. Some modifications are made to the generated Line.  These are
            concerned with whitespace, as detailed below.

        6. The Line is written to the output file by joining the values of
            all of the tokens.  The output location is set to the Line's
            following location.

        7. Space characters are added to the Line when:
            * A token has a spacing attribute, but not an indent.
            * A token and its preceding token must be separated in order to
                avoid lexing the result differently from the two tokens
                separately.  The determination is modeled after GCC's method.
                This is conservative and can sometimes indicate a separation
                when it is not actually needed.  However, it's much faster.
            In either case, the space appears just before the token.

        8. Multiple space characters are replaced by a single one.  Trailing
            whitespace is discarded.

        '''

        def tokens(toks: TokIter) -> None:
            """ Write all the tokens. """

            nonlocal outloc, callback

            # This peek runs the iterator until the first token (if any).
            # This includes the initialization code which creates a < top
            # level > Source.
            tok = toks.peek()
            top = prep.currsource
            callback = self.callback = LocalCallback()
            outloc = OutLoc(top, callback)
            outlocs.append(outloc)
            for tok in toks:
                prep.log.msg(f"Write token {tok!r}", tok)

                token(tok)

        def linedir(lineno: int, filename: str, flag: OutPosFlag = None
                    ) -> str:
            """
            Format a #line directive with presumed line and file.  Optional
            position flag to use with gcc/clang simulation.
            """
            if not prep.line_directive:
                return
            flags: str = flag and flag.flags or ""
            file = prep.fix_path_sep(filename)
            dir = f"{prep.line_directive} {lineno} \"{file}\"{flags}\n"
            return dir

        def output(text: str, count_nl: bool = True) -> None:
            """
            Writes the given string to the output file.
            """
            out.write(text)
            out.flush()

        class LocalCallback(Callback):
            """ An object which can call functions in nonlocal scopes. """
            @property
            def outloc(self) -> OutLoc:
                return outloc

            def linedir(self, lineno: int, filename: str,
                           flag: ChangePosFlag = None
                           ) -> str:
                """ Format a #line directive. """
                return linedir(lineno, filename=filename, flag=flag)

            def push(self, loc: OutLoc) -> None:
                """ Enter a new outloc. """
                nonlocal outloc
                outloc = loc
                outlocs.append(loc)

            def pop(self) -> OutLoc:
                """ Return to previous outloc. """
                nonlocal outloc
                outlocs.pop()
                outloc = outlocs.top()
                return outloc

            def newloc(self, source: Source) -> OutLoc:
                """ Creates a new OutLoc for the source file. """
                return OutLoc(source, callback)
                ...

            def output(self, text: str) -> None:
                """ Write the text, nothing else. """
                output(text)

        def token(tok: PpTok) -> None:
            """ Write whatever is required by the given token. """
            typ: TokType = tok.type
            if not typ.norm:
                if (typ.pos):
                    outloc.change_loc(pos=tok.pos, src_lineno=tok.lineno)
                    return
                if typ.passthru:
                    for tok in tok.toks:
                        token(tok)
                    return
            # Anything else.
            outloc.token(tok)

        toks = self.add_spaces(self.itertokens())
        tokens(toks)
        outloc.freshline()

    @TokIter.from_generator
    def itertokens(self) -> Iterator[Pptok]:
        """ Create line with each logical line and yield. """
        prep = self.prep
        #if prep.emulate:
        #    self.gcc_prolog(tok.source, tok)

        def expand_iters(toks: TTokIter) -> TTokIter:
            """
            Expand CPP_PASSTHRU tokens recursively and generate the results.
            """
            for tok in toks:
                if tok.type.passthru:
                    yield from expand_iters(tok.toks)
                else:
                    yield tok

        while True:
            # Loop over all tokens, from the preprocessor.
            tok: PpTok = None
            toks = TokIter(expand_iters(prep.parser))
            tok = toks.peek()
            for tok in toks:
                if tok is None:
                    continue
                typ = tok.type
                if typ.pos:
                    # NEWPOS
                    yield tok
                    continue

                if typ.ws:
                    pass
                elif typ.comment:
                    # Comment that's not whitespace.
                    # This is special to GCC mode.
                    # Strange things happen in macro replacements.
                    # C++ comments have been changed to C comments already.
                    #if '\n' in tok.value and prep.sources_active.depth > 0:
                    #    # All newlines are duplicated.
                    #    tok.value = tok.value.replace('\n', '\n\n')
                    #    # Then a newline and indent to the correct location
                    #    #   are added before the next token.  
                    #    # We have to look ahead to see it.
                    #    next = self.tokens()
                    #    #line.append(next.make_newline())
                    #    yield tok
                    #    #yield line
                    #    #line.clear()
                    #    do_loc(next.lexer.make_pos(lineno=next.lineno).pos)

                    #    tok = next.with_spacing()
                    pass
                yield tok

            if tok is None:
                break

    @TokIter.from_generator
    def add_spaces(self, toks: Iterable[PpTok], 
                   ) -> Iterator[PpTok]:
        """
        Generates the given token sequence, with some spacing and indent
        modified where needed.
        """

        # Rules for spacing and indent:

        # Tokens are processed with pairwise().  left and right are the
        # consecutive pair of tokens.  The first time, left is None and right
        # is the first token.

        # None (•) right -> right (no spacing).
        #
        # left right -> • right if left and right need separation.
        # left right -> right otherwise.
        # left • right -> • right

        # left ↑ right:
        #
        #   -> • right If right is same line as left.
        #   -> ↑ right If right is new line from left.

        # clang in one case looks at 3 consecutive tokens: two '.'s and a token
        #   beginning with '.'.  A space between the last two prevents a lexing
        #   of '...'.

        # Clang leaves right as-is if it immediately follows left in same
        # source.

        left: PpTok | None
        right: PpTok
        before_left: PpTok

        pairs: Iterable(tuple[PpTok | None, PpTok]) = (
            pairwise(itertools.chain((None, ), toks, )))
        spacing: bool = False           # Any spacing to be added to left.
        left, right = next(pairs)   # None, first token.
        before_left = left
        yield right.without_spacing()
        lex: PpLex
        with self.prep.lexer.cloned() as lex:
            for left, right in pairs:
                ltype, rtype = left.type, right.type
                # left has already been generated the last time around.

                # TODO: Use left ending position and right position.
                # If they are equal, right has no spacing and will get none.
                if rtype.norm and left == right.prev:
                    yield right
                elif right.indent:
                    if right.indent.colno == 1 and rtype.hash and right.hide:
                        right = right.with_sep(TokenSep.create(
                            indent=right.indent.copy(colno=2)))
                    if 0x00001:
                        yield right
                    elif right.lineno != left.lineno:
                        yield right
                    else:
                        yield right.with_spacing()
                elif right.spacing:
                    yield right
                elif rtype in ltype.sep_from:
                    test = ltype.sep_from[rtype]
                    if not test or test(
                            before_left, left, right):
                        yield right.with_spacing()
                    else:
                        yield right
                elif lex.separate(left.value, right.value):
                    yield right.with_spacing()
                elif rtype.err:
                    yield right.with_spacing()
                else:
                    yield right
                before_left = left

    def __repr__(self):
        return f"<Writer {self.lexer}"


class Callback:
    """
    An object which can call functions in a Writer.
    A subclass implements this with nonlocal variables in a write() method.
    This class can be used as a do-nothing callback.
    """
    def linedir(self, lineno: int, filename: str,
                    flag: ChangePosFlag = None,
                    ) -> str:
        """ Format a #line directive. """

    def newloc(self, source: Source) -> OutLoc:
        """ Create new OutLoc for the source file. """
        pass

    def output(self, text: str) -> None:
        """ Write the text, nothing else. """
        pass


class OutLoc:
    """
    Tracks the presumed line number and filename for writing to the output.
    It manages all output belonging to a Source.

    The location state is made up of
        * The presumed line number.  Initially 1.
        * The presumed file name.  Initially same as that of the source.
        * Whether the current line is blank (so far).  Initially True.
        * Difference between source and presumed line numbers.

    The state is updated by various methods.  A callback object (usually)
    performs corresponding operations on the Writer so that the state will
    correspond to what is actually written.  The callback can be temporarily
    suppressed by a context manager nowrite() method.

    The state is affected by LocPosChange objects and anything else that
    writes to the output file.

    OutLoc also used to get values for __LINE__ and __FILE__ macro tokens at
    the current location in the source file.
    """

    # Set by the constructor...
    source: Source                  # The Source.
    writer: Callback                # Performs operations on the writer.
    prep: Preprocessor              # The preprocessor object.
    # Change by various methods...
    lineno: int                     # Current line in output.
    spaces: int = 0                 # Whitespace waiting to be written.
    blank: bool                     # Nothing written yet to current line.
    addline: int = 0                # Diff between output and source.
    filename: str                   # Output filename.

    def __init__(self, source: Source, writer: Callback):
        self.source = source
        source.outloc = self
        self.writer = writer
        self.prep = source.prep
        self.lineno = 1
        self.blank = True
        self.addline = 0
        self.filename = source.filename

    def __getitem__(self, src_lineno: int) -> int:
        """ Line number corresponding to a source line of some token. """
        return src_lineno + self.addline

    def __iadd__(self, lines: int) -> Self:
        """
        Advance given number of lines, can be negative.  Changes both
        self.src_lineno and self.lineno.
        """
        if lines:
            self.lineno += lines
            self.blank = True
        return self

    def __isub__(self, lines: int) -> Self:
        """
        Back up given number of lines, can be negative.  Changes both
        self.src_lineno and self.lineno.
        """
        if lines:
            self.lineno -= lines
            self.blank = True
        return self

    def freshline(self) -> None:
        """ Advance to next line if current line is not blank. """
        if not self.blank:
            self.newline()

    def newline(self, count: int = 1) -> None:
        """
        Write one or more newlines, and adjust line number and blank.
        """
        self += count
        self.writer.output('\n' * count)

    def token(self, tok: PpTok) -> None:
        """ Write token value in its proper location in the output. """
        self.moveto(tok)
        self.output(tok.value)

    def moveto(self, tok: PpTok) -> None:
        """
        Move to where given token should be written, but don't write it.
        """
        indent = tok.indent
        if indent:
            self.to_line(indent.output_lineno)
            self.spaces = indent.colno - 1
        elif tok.spacing:
            self.spaces = 1

    def indent(self, indent: PpTok) -> None:
        self.to_line(indent.output_lineno)
        self.spaces = indent.colno - 1

    def spacing(self) -> None:
        self.spaces = 1

    def to_src_line(self, src_lineno: int = 1) -> None:
        """
        Move to start of given source line number.  If already there, do
        nothing, and output might have some text written already.
        """
        self.to_line(self[src_lineno])

    def to_line(self, lineno: int = 1) -> None:
        """
        Move to start of given output line number.  If already there, do
        nothing, and output might have some text written already.
        """
        skip = lineno - self.lineno
        if 0 < skip <= 8:
            self.newline(skip)
        elif not skip:
            return
        else: self.linedir(lineno, self.filename)
        self.lineno = lineno
        self.blank = True

    def output(self, text: str) -> None:
        """
        Write some text to the output file and adjust line number and blank.
        """
        if not text:
            self.spaces = 0
            return
        if self.spaces:
            self.writer.output(' ' * self.spaces)
            self.spaces = 0
        self.writer.output(text)
        newlines = text.count('\n')
        if newlines:
            self.lineno += newlines
            self.blank = text.endswith('\n')
        else:
            self.blank = False

    def change_loc(self, *, pos: OutPosChange, src_lineno: int) -> None:
        """
        Handle an OutPosChange object at given source location.  May change
        the writer's OutLoc (currently self), which may be self's parent, or a
        brand new OutLoc.
        """
        flag = pos.flag
        if pos.enter:
            # Entering a new Source file, creating and returning a new OutLoc.
            # Moves to given source line.  Writes a #line for line 1 of the
            # new source.  Special behavior for the top level.
            source = pos.source
            if source.parent.parent:
                self.to_src_line(src_lineno)
            else:
                flag = None
            self.linedir(1, source.filename, flag)
            newloc: OutLoc = self.writer.newloc(source)
            self.writer.push(newloc)
        elif pos.leave:
            # Leaving an included Source file, changing to its parent OutLoc.
            # Write #line for the current line and file of the parent.
            self.freshline()
            oldloc = self.writer.pop()
            oldloc += 1
            oldloc.linedir(flag=flag)
        else:
            assert pos.move
            if pos.filename:
                self.filename = pos.filename
            self.freshline()
            self.addline = pos.lineno - src_lineno - 1
            self.lineno = pos.lineno
            self.linedir()

    def linedir(self, lineno: int = None, filename: str = None,
                flag: OutPosFlag = None
                ) -> None:
        """ Write a #line directive for current location, option to specify
        different line or file.
        """
        self.freshline()
        if lineno is None: lineno = self.lineno
        self.output(
            self.writer.linedir(lineno, filename or self.filename, flag))
        self.lineno -= 1


    def set_line(self, *, lineno: int, src_lineno: int) -> None:
        """
        Set a new line number at given source location.  Changes both
        self.addline and self.lineno.
        """
        self.addline = lineno - src_lineno - 1

    @property
    def src_lineno(self) -> int:
        """ The source line number currently. """
        return self.lineno - self.addline

    def src_lineno_at(self, lineno: int) -> int:
        """ The source line number corresponding to given output line. """
        return lineno - self.addline

    def linemacro(self, macro: PpTok) -> int:
        """ Value of __LINE__ macro in this source. """
        return self[macro.phys_lineno]

    def filemacro(self) -> int:
        """ Value of __FILE__ macro in this source. """
        return self.prep.fix_path_sep(self.filename)

    @contextlib.contextmanager
    def nowrite(self, temp = Callback()) -> Iterable:
        """ Turns off the writer callback during the context. """
        writer = self.writer
        self.writer = temp
        try: yield
        finally: self.writer = writer

    def brk(self) -> bool:
        """ Break condition for debugging. """
        return break_match(line=self.lineno,
                           file=self.source and self.source.filename,
                           )

    def __repr__(self) -> str:
        srcline = self.addline and f"{self.src_lineno}/" or ""
        file = self.filename
        if file != self.source.filename:
            file = os.path.basename(self.filename)
            file = f"{self.source}/{file!r}"
        else:
            file = str(self.source)
        if self.blank:
            if self.spaces:
                space = PpTok.repr_spacing
            else:
                space = PpTok.repr_null
        else:
            space = ''
        return f"{file}:{srcline}{self.lineno}{space}"
                

class OutPosChange:
    """
    A notice of change of output location within the output file.  It
    corresponds to
      (1) entering an included Source, at line 1.
      (2) leaving an included Source, returning to the including Source.
      (3) a #line directive.  Changes the presumed line number, and optionally
          changes the presumed filename.
    It results in writing a #line directive to the output.  Also contains a
    flag indicating which of the above cases it is, also used by gcc and clang
    in the output #line.
    """
    flag: OutPosFlag            # Set below in the constructor for the flag.
    enter: bool = False
    leave: bool = False
    move: bool = False

    # Optional attributes, varying with the subclass...
    filename: str = None    # If present, represents a new source.filename.
    lineno: int = None
    source: Source = None

    @property
    def enter(self) -> bool:
        """ Has Begin position in its file. """
        return self.flag.enter

    @property
    def leave(self) -> bool:
        """ Has End position in its file. """
        return self.flag.leave

    @property
    def move(self) -> bool:
        """ Has position in the same file. """
        return self.flag.change_file

    def brk(self) -> bool:
        """ Break condition for debugging. """
        return break_match(line=self.lineno, file=self.filename)

    def __str__(self) -> str:
        name = f' -> "{self.filename}"' * bool(self.filename)
        source = f' "{self.source}"' * bool(self.source)
        lineno = f'{self.lineno}' * (self.lineno is not None)
        return (f"{lineno}{' *' * self.enter}"
                f"{source}{' *' * self.leave}"
                f"{name}"
                )

    def __repr__(self) -> str:
        return f"<{type(self).__name__} {self}>"


class OutPosEnter(OutPosChange):
    """ Notes entering a new source file. """
    enter: bool = True
    def __init__(self, source: Source):
        self.source = source


class OutPosLeave(OutPosChange):
    """ Notes leaving a source file and returning to the including file. """
    leave: bool = True


class OutPosMove(OutPosChange):
    """
    Notes a #line directive.  Sets a presumed line and possily a presumed
    filename.
    """
    move: bool = True
    def __init__(self, lineno: int, filename: str = None):
        self.lineno = lineno
        if filename:
            self.filename = filename


class OutPosFlag(enum.Enum):
    """ Where a location is with respect to the source file.
    The values correspond to what gcc or clang generates in a #line output.
    """
    Move = '', OutPosMove, dict(move=True)
    Enter = ' 1', OutPosEnter, dict(enter=True)
    # Leave designates a location in the including file.
    Leave = ' 2', OutPosLeave, dict(leave=True)

    def __init__(self, flags: str, cls: Type[OutPosChange], attrs: dict):
        self.flags = flags
        self.cls = cls
        cls.flag = self
        self.enter = self.leave = self.move = False
        self.__dict__.update(**attrs)
        self.change_file = not (self.enter or self.leave)

