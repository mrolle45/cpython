# Types in PEG Grammar

Every expression, or sub-expression, in the grammar file has a **Type**.  This is the type of the **value** produced by evaluating (*i.e.*, parsing) the expression at the current location in the input file, *provided that the expression parsing succeeds*.

The Type has a **Type Name**, which is a string in the target language of the parser file (which file is generated by a parser generator from the grammar file).  The Type Name of an expression may appear within the generated code which parses that expression.

The **parser generator** is a Python module in the `Tools/peg_generator/pegen` package.  There is one for each target language.

In earlier versions of `pegen`, the Type was found as an *annotation* in the grammar file.  This consisted of the type name enclosed in `[ ... ]` brackets.

In the new version of `pegen`, the Type is found as a *type* element in the grammar file.  This is still enclosed in `[ ... ]` brackets; however, the syntax is more complex.  It contains a type name and optional information for callable types.

## Object and Function Types

- An **Object Type** is a basic type in the target language.  It can be used to declare an identifier.

    In C, it is anything other than a function or array type.  It can include pointers and const/volatile qualifiers.  A more complex type can be represented by a typedef, which might be defined in an external file or in a @subheader metavalue.

    In Python, it is any Python type other than a Callable.

- A **Function Type** is used to declare an identifier as a function.  The function can appear alone in the grammar, or it can appear along with a set of arguments for a call to the function.

    The FunctionType is composed of a **Return Type** and a sequence (possibly empty) of parameters.  The Return Type can be any Type.  A parameter is an optional name and any Type. 

    The Return Type can be another Function Type.  In this case, calling the Function Type returns a function, which can be used as a value, or can be called with another set of parameters.  This can be repeated any number of levels.

## Syntax in the Grammar File

An Object Type appears in the form:  
`'[' typename ']'  

A Function Type appears in the form:  
`'[' typename? parameters+']'`  
If the `typename` is omitted, this means that the function does not return a value.  It is called merely for side effects, principally the parsing of some expressions.  

The function is called with the syntax:
`function<arg*>`  
Note the `< ... >` around the argument list.  This is similar to a template class in C++.

The `parameters` element specifies a list of parameters.  If the Function Type returns another Function Type, then there is another `parameters` element.  If there are more levels of function types, then there is a `parameters` element for each function, in the same order as the calling of the functions.

The syntax for `parameters` is:
`'<' parameter* '>'`

The syntax for `parameter` is:  
`'[' name? type ']'`

Example:  
`[int<c[char<l[<void *<>]]]`  
This is a function `f1` with a `char` parameter named `c`.  
`f1` returns another function `f2` with a `void *` parameter named `l`.  
`f2` returns another function `f3` with no parameters.  
`f3` returns an `int` value.

The expression `f1<3><'x'><NULL>` calls `f1<3>`, then `f2<'x'>`, then `f3<NULL>`, with an `int` result.  

The expression `f1<3><'x'>` only calls `f1<3>`, then `f2<'x'>`, with function `f3` as the result.  



