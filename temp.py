#!/usr/bin/env python3.8
# @generated by pegen from metagrammar.gram

from __future__ import annotations

import ast
import sys
import tokenize

from typing import Any, Optional

from pegen.parser import memoize, memoize_left_rec, logger, Parser, RuleAltDescr, cut_sentinel
from ast import literal_eval
from itertools import chain
import traceback

from pegen.grammar import (
    Alt,
    Arg,
    Args,
    Cut,
    Forced,
    Gather,
    Grammar,
    Group,
    Item,
    Lookahead,
    Meta,
    NameLeaf,
    NamedItem,
    NamedItems,
    NegativeLookahead,
    Opt,
    Params,
    Plain,
    PositiveLookahead,
    Repeat0,
    Repeat1,
    Rhs,
    Rule,
    StringLeaf,
    TypedName,
)

# Keywords and soft keywords are listed at the end of the parser definition.
class GeneratedParser(Parser):

    # start: grammar $
    def start(self) -> ParseResult[Grammar]:
        def _rhs() -> Any:
            def _alt() -> Any:  # grammar $
                # grammar
                def _item_grammar() -> Grammar:
                    return self.grammar()
                grammar: Grammar; _result_grammar: ParseResult[Grammar]
                _result_grammar = _item_grammar()
                if not _result_grammar: return None
                grammar, = _result_grammar
                # $
                def _item__endmarker_var() -> Token:
                    return self._expect_type(0)
                _endmarker_var: Token; _result__endmarker_var: ParseResult[Token]
                _result__endmarker_var = _item__endmarker_var()
                if not _result__endmarker_var: return None
                _endmarker_var, = _result__endmarker_var
                # parse succeeded
                return grammar,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'grammar $'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # grammar: meta* rule+
    def grammar(self) -> ParseResult[Grammar]:
        def _rhs() -> Any:
            def _alt() -> Any:  # meta* rule+
                # meta*
                def _item_metas() -> ParseResult[list]:
                    def _node() -> Meta:
                        return self.meta()
                    return self._loop(_node, None, False)
                metas: ParseResult[list]
                metas, = _item_metas()
                # rule+
                def _item_rules() -> ParseResult[list]:
                    def _node() -> Rule:
                        return self.rule()
                    return self._loop(_node, None, True)
                rules: ParseResult[list]; _result_rules: ParseResult[ParseResult[list]]
                _result_rules = _item_rules()
                if not _result_rules: return None
                rules, = _result_rules
                # parse succeeded
                return Grammar (rules , metas),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'meta* rule+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # meta: "@" NAME metavalue? NEWLINE
    def meta(self) -> ParseResult[Meta]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "@" NAME metavalue? NEWLINE
                # "@"
                def _item__literal_var() -> Token:
                    return self._expect_type(49)   # token=@
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # NAME
                def _item_name() -> Token:
                    return self._name()
                name: Token; _result_name: ParseResult[Token]
                _result_name = _item_name()
                if not _result_name: return None
                name, = _result_name
                # metavalue?
                def _item_val() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.metavalue()
                    return self._opt(_item)
                val: ParseResult[Any]
                val, = _item_val()
                # NEWLINE
                def _item__newline_var() -> Token:
                    return self._expect_type(4)
                _newline_var: Token; _result__newline_var: ParseResult[Token]
                _result__newline_var = _item__newline_var()
                if not _result__newline_var: return None
                _newline_var, = _result__newline_var
                # parse succeeded
                return Meta (name . string , val),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"@" NAME metavalue? NEWLINE'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # metavalue: NAME | STRING | <always>
    def metavalue(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # NAME
                # NAME
                def _item_val() -> Token:
                    return self._name()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val
                # parse succeeded
                return val . string,
            def _alt_2() -> Any:  # STRING
                # STRING
                def _item_val() -> Token:
                    return self._string()
                val: Token; _result_val: ParseResult[Token]
                _result_val = _item_val()
                if not _result_val: return None
                val, = _result_val
                # parse succeeded
                return literal_eval (val . string),
            def _alt_3() -> Any:  # <always>
                # parse succeeded
                return None,
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, 'NAME'),
                RuleAltDescr(_alt_2, _alt_2, 'STRING'),
                RuleAltDescr(_alt_3, _alt_3, '<always>'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # rule: typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?
    def rule(self) -> ParseResult[Rule]:
        def _rhs() -> Any:
            def _alt() -> Any:  # typed_name memoflag? ":" maybe_alts? NEWLINE
            #     more_alts?
                # typed_name
                def _item_n() -> TypedName:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # memoflag?
                def _item_m() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.memoflag()
                    return self._opt(_item)
                m: ParseResult[Any]
                m, = _item_m()
                # ":"
                def _item__literal_var() -> Token:
                    return self._expect_type(11)   # token=:
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # maybe_alts?
                def _item_a() -> ParseResult[Any]:
                    def _item() -> Rhs:
                        return self.maybe_alts()
                    return self._opt(_item)
                a: ParseResult[Any]
                a, = _item_a()
                # NEWLINE
                def _item__newline_var() -> Token:
                    return self._expect_type(4)
                _newline_var: Token; _result__newline_var: ParseResult[Token]
                _result__newline_var = _item__newline_var()
                if not _result__newline_var: return None
                _newline_var, = _result__newline_var
                # more_alts?
                def _item_aa() -> ParseResult[Any]:
                    def _item() -> Rhs:
                        return self.more_alts()
                    return self._opt(_item)
                aa: ParseResult[Any]
                aa, = _item_aa()
                # parse succeeded
                return Rule (n , Rhs (a + aa) , memo = m),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'typed_name memoflag? ":" maybe_alts? NEWLINE more_alts?'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # params: !memoflag '(' ','.typed_name+ [','] ')' | '(' ')'
    def params(self) -> ParseResult[Params]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # !memoflag '(' ','.typed_name+ [','] ')'
                # !memoflag
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> str:
                        return self.memoflag()
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                _lookahead_var, = _result__lookahead_var
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ','.typed_name+
                def _item_n() -> ParseResult[list]:
                    def _node() -> TypedName:
                        return self.typed_name()
                    def sep() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._loop(_node, sep, True)
                n: ParseResult[list]; _result_n: ParseResult[ParseResult[list]]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # [',']
                def _item_opt_var() -> ParseResult[Any]:
                    def _item() -> Any:
                        def _alt() -> Any:  # ','
                            # ','
                            def _item__literal_var() -> Token:
                                return self._expect_type(12)   # token=,
                            _literal_var: Token; _result__literal_var: ParseResult[Token]
                            _result__literal_var = _item__literal_var()
                            if not _result__literal_var: return None
                            _literal_var, = _result__literal_var
                            # parse succeeded
                            return _literal_var,
                        _alt_descriptors = [
                            RuleAltDescr(_alt, _alt, "','"),
                        ]
                        return self._alts(_alt_descriptors)
                    return self._opt(_item)
                opt_var: ParseResult[Any]
                opt_var, = _item_opt_var()
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Params (n),
            def _alt_2() -> Any:  # '(' ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Params ([]),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "!memoflag '(' ','.typed_name+ [','] ')'"),
                RuleAltDescr(_alt_2, _alt_2, "'(' ')'"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # typed_name: NAME params? annotation?
    def typed_name(self) -> ParseResult[TypedName]:
        def _rhs() -> Any:
            def _alt() -> Any:  # NAME params? annotation?
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # params?
                def _item_p() -> ParseResult[Any]:
                    def _item() -> Params:
                        return self.params()
                    return self._opt(_item)
                p: ParseResult[Any]
                p, = _item_p()
                # annotation?
                def _item_a() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.annotation()
                    return self._opt(_item)
                a: ParseResult[Any]
                a, = _item_a()
                # parse succeeded
                return TypedName (n . string , a , p),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'NAME params? annotation?'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # memoflag: '(' "memo" ')'
    def memoflag(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt() -> Any:  # '(' "memo" ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # "memo"
                def _item__keyword_var() -> Token:
                    return self._expect_name("memo")   # keyword='memo'
                _keyword_var: Token; _result__keyword_var: ParseResult[Token]
                _result__keyword_var = _item__keyword_var()
                if not _result__keyword_var: return None
                _keyword_var, = _result__keyword_var
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return "memo",
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '\'(\' "memo" \')\''),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # alts: "|".alt+
    def alts(self) -> ParseResult[Rhs]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "|".alt+
                # "|".alt+
                def _item_a() -> ParseResult[list]:
                    def _node() -> Alt:
                        return self.alt()
                    def sep() -> Token:
                        return self._expect_type(18)   # token=|
                    return self._loop(_node, sep, True)
                a: ParseResult[list]; _result_a: ParseResult[ParseResult[list]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return Rhs (a),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"|".alt+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # maybe_alts: !NEWLINE "|".alt+ | <always>
    def maybe_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # !NEWLINE "|".alt+
                # !NEWLINE
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(4)
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                _lookahead_var, = _result__lookahead_var
                # "|".alt+
                def _item_a() -> ParseResult[list]:
                    def _node() -> Alt:
                        return self.alt()
                    def sep() -> Token:
                        return self._expect_type(18)   # token=|
                    return self._loop(_node, sep, True)
                a: ParseResult[list]; _result_a: ParseResult[ParseResult[list]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return Rhs (a),
            def _alt_2() -> Any:  # <always>
                # parse succeeded
                return Rhs ([]),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, '!NEWLINE "|".alt+'),
                RuleAltDescr(_alt_2, _alt_2, '<always>'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # more_alts: INDENT (("|" alts NEWLINE))+ DEDENT | <always>
    def more_alts(self) -> ParseResult[Rhs]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # INDENT (("|" alts NEWLINE))+ DEDENT
                # INDENT
                def _item__indent_var() -> Token:
                    return self._expect_type(5)
                _indent_var: Token; _result__indent_var: ParseResult[Token]
                _result__indent_var = _item__indent_var()
                if not _result__indent_var: return None
                _indent_var, = _result__indent_var
                # (("|" alts NEWLINE))+
                def _item_a() -> ParseResult[list]:
                    def _node() -> Any:
                        def _rhs() -> Any:
                            def _alt() -> Any:  # "|" alts NEWLINE
                                # "|"
                                def _item__literal_var() -> Token:
                                    return self._expect_type(18)   # token=|
                                _literal_var: Token; _result__literal_var: ParseResult[Token]
                                _result__literal_var = _item__literal_var()
                                if not _result__literal_var: return None
                                _literal_var, = _result__literal_var
                                # alts
                                def _item_b() -> Rhs:
                                    return self.alts()
                                b: Rhs; _result_b: ParseResult[Rhs]
                                _result_b = _item_b()
                                if not _result_b: return None
                                b, = _result_b
                                # NEWLINE
                                def _item__newline_var() -> Token:
                                    return self._expect_type(4)
                                _newline_var: Token; _result__newline_var: ParseResult[Token]
                                _result__newline_var = _item__newline_var()
                                if not _result__newline_var: return None
                                _newline_var, = _result__newline_var
                                # parse succeeded
                                return b,
                            _alt_descriptors = [
                                RuleAltDescr(_alt, _alt, '"|" alts NEWLINE'),
                            ]
                            return self._alts(_alt_descriptors)
                        return self._rhs(_rhs)
                    return self._loop(_node, None, True)
                a: ParseResult[list]; _result_a: ParseResult[ParseResult[list]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # DEDENT
                def _item__dedent_var() -> Token:
                    return self._expect_type(6)
                _dedent_var: Token; _result__dedent_var: ParseResult[Token]
                _result__dedent_var = _item__dedent_var()
                if not _result__dedent_var: return None
                _dedent_var, = _result__dedent_var
                # parse succeeded
                return Rhs (chain (* a)),
            def _alt_2() -> Any:  # <always>
                # parse succeeded
                return Rhs (()),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, 'INDENT (("|" alts NEWLINE))+ DEDENT'),
                RuleAltDescr(_alt_2, _alt_2, '<always>'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # alt: items endmarker action?
    def alt(self) -> ParseResult[Alt]:
        def _rhs() -> Any:
            def _alt() -> Any:  # items endmarker action?
                # items
                def _item_i() -> NamedItems:
                    return self.items()
                i: NamedItems; _result_i: ParseResult[NamedItems]
                _result_i = _item_i()
                if not _result_i: return None
                i, = _result_i
                # endmarker
                def _item_e() -> NamedItems:
                    return self.endmarker()
                e: NamedItems; _result_e: ParseResult[NamedItems]
                _result_e = _item_e()
                if not _result_e: return None
                e, = _result_e
                # action?
                def _item_a() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.action()
                    return self._opt(_item)
                a: ParseResult[Any]
                a, = _item_a()
                # parse succeeded
                return Alt (i + e , action = a),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'items endmarker action?'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # items: named_item*
    def items(self) -> ParseResult[NamedItems]:
        def _rhs() -> Any:
            def _alt() -> Any:  # named_item*
                # named_item*
                def _item_n() -> ParseResult[list]:
                    def _node() -> NamedItem:
                        return self.named_item()
                    return self._loop(_node, None, False)
                n: ParseResult[list]
                n, = _item_n()
                # parse succeeded
                return NamedItems (n),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'named_item*'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # named_item: typed_name '=' ~ item | item | forced_atom | lookahead | cut
    def named_item(self) -> ParseResult[NamedItem]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # typed_name '=' ~ item
                # typed_name
                def _item_n() -> TypedName:
                    return self.typed_name()
                n: TypedName; _result_n: ParseResult[TypedName]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # '='
                def _item__literal_var() -> Token:
                    return self._expect_type(22)   # token==
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ~
                # item
                def _item_it() -> Item:
                    return self.item()
                it: Item; _result_it: ParseResult[Item]
                _result_it = _item_it()
                if not _result_it: return cut_sentinel
                it, = _result_it
                # parse succeeded
                return NamedItem (n , it),
            def _alt_2() -> Any:  # item
                # item
                def _item_it() -> Item:
                    return self.item()
                it: Item; _result_it: ParseResult[Item]
                _result_it = _item_it()
                if not _result_it: return None
                it, = _result_it
                # parse succeeded
                return NamedItem (None , it),
            def _alt_3() -> Any:  # forced_atom
                # forced_atom
                def _item_forced() -> Forced:
                    return self.forced_atom()
                forced: Forced; _result_forced: ParseResult[Forced]
                _result_forced = _item_forced()
                if not _result_forced: return None
                forced, = _result_forced
                # parse succeeded
                return NamedItem (None , forced),
            def _alt_4() -> Any:  # lookahead
                # lookahead
                def _item_it() -> Lookahead:
                    return self.lookahead()
                it: Lookahead; _result_it: ParseResult[Lookahead]
                _result_it = _item_it()
                if not _result_it: return None
                it, = _result_it
                # parse succeeded
                return NamedItem (None , it),
            def _alt_5() -> Any:  # cut
                # cut
                def _item_cut() -> Cut:
                    return self.cut()
                cut: Cut; _result_cut: ParseResult[Cut]
                _result_cut = _item_cut()
                if not _result_cut: return None
                cut, = _result_cut
                # parse succeeded
                return NamedItem (None , cut),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "typed_name '=' ~ item"),
                RuleAltDescr(_alt_2, _alt_2, 'item'),
                RuleAltDescr(_alt_3, _alt_3, 'forced_atom'),
                RuleAltDescr(_alt_4, _alt_4, 'lookahead'),
                RuleAltDescr(_alt_5, _alt_5, 'cut'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # forced_atom: '&' '&' ~ atom
    def forced_atom(self) -> ParseResult[Forced]:
        def _rhs() -> Any:
            def _alt() -> Any:  # '&' '&' ~ atom
                # '&'
                def _item__literal_var() -> Token:
                    return self._expect_type(19)   # token=&
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # '&'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(19)   # token=&
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # ~
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a
                # parse succeeded
                return Forced (a),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, "'&' '&' ~ atom"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # lookahead: '&' ~ atom | '!' ~ atom
    def lookahead(self) -> ParseResult[Lookahead]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '&' ~ atom
                # '&'
                def _item__literal_var() -> Token:
                    return self._expect_type(19)   # token=&
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ~
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a
                # parse succeeded
                return PositiveLookahead (a),
            def _alt_2() -> Any:  # '!' ~ atom
                # '!'
                def _item__literal_var() -> Token:
                    return self._expect_char('!')   # token=!
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ~
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a
                # parse succeeded
                return NegativeLookahead (a),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "'&' ~ atom"),
                RuleAltDescr(_alt_2, _alt_2, "'!' ~ atom"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # cut: '~'
    def cut(self) -> ParseResult[Cut]:
        def _rhs() -> Any:
            def _alt() -> Any:  # '~'
                # '~'
                def _item__literal_var() -> Token:
                    return self._expect_type(31)   # token=~
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return Cut (),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, "'~'"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+'
    #     | atom
    def item(self) -> ParseResult[Item]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '[' ~ alts ']'
                # '['
                def _item__literal_var() -> Token:
                    return self._expect_type(9)   # token=[
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ~
                # alts
                def _item_a() -> Rhs:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a
                # ']'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(10)   # token=]
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return cut_sentinel
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Opt (a),
            def _alt_2() -> Any:  # atom '?'
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # '?'
                def _item__literal_var() -> Token:
                    return self._expect_char('?')   # token=?
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return Opt (a),
            def _alt_3() -> Any:  # atom '*'
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # '*'
                def _item__literal_var() -> Token:
                    return self._expect_type(16)   # token=*
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return Repeat0 (a),
            def _alt_4() -> Any:  # atom '+'
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # '+'
                def _item__literal_var() -> Token:
                    return self._expect_type(14)   # token=+
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return Repeat1 (a),
            def _alt_5() -> Any:  # atom '.' atom '+'
                # atom
                def _item_sep() -> Plain:
                    return self.atom()
                sep: Plain; _result_sep: ParseResult[Plain]
                _result_sep = _item_sep()
                if not _result_sep: return None
                sep, = _result_sep
                # '.'
                def _item__literal_var() -> Token:
                    return self._expect_type(23)   # token=.
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # atom
                def _item_node() -> Plain:
                    return self.atom()
                node: Plain; _result_node: ParseResult[Plain]
                _result_node = _item_node()
                if not _result_node: return None
                node, = _result_node
                # '+'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(14)   # token=+
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Gather (sep , node),
            def _alt_6() -> Any:  # atom
                # atom
                def _item_a() -> Plain:
                    return self.atom()
                a: Plain; _result_a: ParseResult[Plain]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return a,
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "'[' ~ alts ']'"),
                RuleAltDescr(_alt_2, _alt_2, "atom '?'"),
                RuleAltDescr(_alt_3, _alt_3, "atom '*'"),
                RuleAltDescr(_alt_4, _alt_4, "atom '+'"),
                RuleAltDescr(_alt_5, _alt_5, "atom '.' atom '+'"),
                RuleAltDescr(_alt_6, _alt_6, 'atom'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # endmarker: '$' | <always>
    def endmarker(self) -> ParseResult[NamedItems]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '$'
                # '$'
                def _item__literal_var() -> Token:
                    return self._expect_char('$')   # token=$
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return NamedItems ([NamedItem (None , NameLeaf ('ENDMARKER'))]),
            def _alt_2() -> Any:  # <always>
                # parse succeeded
                return NamedItems (),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "'$'"),
                RuleAltDescr(_alt_2, _alt_2, '<always>'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # atom: '(' ~ alts ')' | NAME arguments? | STRING
    def atom(self) -> ParseResult[Plain]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '(' ~ alts ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ~
                # alts
                def _item_a() -> Rhs:
                    return self.alts()
                a: Rhs; _result_a: ParseResult[Rhs]
                _result_a = _item_a()
                if not _result_a: return cut_sentinel
                a, = _result_a
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return cut_sentinel
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Group ((a)),
            def _alt_2() -> Any:  # NAME arguments?
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # arguments?
                def _item_a() -> ParseResult[Any]:
                    def _item() -> Args:
                        return self.arguments()
                    return self._opt(_item)
                a: ParseResult[Any]
                a, = _item_a()
                # parse succeeded
                return NameLeaf (n . string , a),
            def _alt_3() -> Any:  # STRING
                # STRING
                def _item_s() -> Token:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s
                # parse succeeded
                return StringLeaf (s . string),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, "'(' ~ alts ')'"),
                RuleAltDescr(_alt_2, _alt_2, 'NAME arguments?'),
                RuleAltDescr(_alt_3, _alt_3, 'STRING'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # action: "{" target_atoms "}"
    def action(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "{" target_atoms "}"
                # "{"
                def _item__literal_var() -> Token:
                    return self._expect_type(25)   # token={
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms
                def _item_t() -> str:
                    return self.target_atoms()
                t: str; _result_t: ParseResult[str]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t
                # "}"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(26)   # token=}
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return t,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"{" target_atoms "}"'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # annotation: "[" target_atoms "]"
    def annotation(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt() -> Any:  # "[" target_atoms "]"
                # "["
                def _item__literal_var() -> Token:
                    return self._expect_type(9)   # token=[
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms
                def _item_t() -> str:
                    return self.target_atoms()
                t: str; _result_t: ParseResult[str]
                _result_t = _item_t()
                if not _result_t: return None
                t, = _result_t
                # "]"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(10)   # token=]
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return t,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '"[" target_atoms "]"'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # arguments: '(' arg "," ",".arg+ ","? ')' | '(' arg "," ')' | '(' ')'
    def arguments(self) -> ParseResult[Args]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # '(' arg "," ",".arg+ ","? ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # arg
                def _item_a() -> Arg:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # ","
                def _item__literal_var_1() -> Token:
                    return self._expect_type(12)   # token=,
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # ",".arg+
                def _item_b() -> ParseResult[list]:
                    def _node() -> Arg:
                        return self.arg()
                    def sep() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._loop(_node, sep, True)
                b: ParseResult[list]; _result_b: ParseResult[ParseResult[list]]
                _result_b = _item_b()
                if not _result_b: return None
                b, = _result_b
                # ","?
                def _item_opt_var() -> ParseResult[Any]:
                    def _item() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._opt(_item)
                opt_var: ParseResult[Any]
                opt_var, = _item_opt_var()
                # ')'
                def _item__literal_var_2() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_2: Token; _result__literal_var_2: ParseResult[Token]
                _result__literal_var_2 = _item__literal_var_2()
                if not _result__literal_var_2: return None
                _literal_var_2, = _result__literal_var_2
                # parse succeeded
                return Args ([a] + b),
            def _alt_2() -> Any:  # '(' arg "," ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # arg
                def _item_a() -> Arg:
                    return self.arg()
                a: Arg; _result_a: ParseResult[Arg]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # ","
                def _item__literal_var_1() -> Token:
                    return self._expect_type(12)   # token=,
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # ')'
                def _item__literal_var_2() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_2: Token; _result__literal_var_2: ParseResult[Token]
                _result__literal_var_2 = _item__literal_var_2()
                if not _result__literal_var_2: return None
                _literal_var_2, = _result__literal_var_2
                # parse succeeded
                return Args ([a]),
            def _alt_3() -> Any:  # '(' ')'
                # '('
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # ')'
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return Args (),
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, '\'(\' arg "," ",".arg+ ","? \')\''),
                RuleAltDescr(_alt_2, _alt_2, '\'(\' arg "," \')\''),
                RuleAltDescr(_alt_3, _alt_3, "'(' ')'"),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # arg: arg_atom+
    def arg(self) -> ParseResult[Arg]:
        def _rhs() -> Any:
            def _alt() -> Any:  # arg_atom+
                # arg_atom+
                def _item_a() -> ParseResult[list]:
                    def _node() -> Any:
                        return self.arg_atom()
                    return self._loop(_node, None, True)
                a: ParseResult[list]; _result_a: ParseResult[ParseResult[list]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return Arg (" " . join (a)),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'arg_atom+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # arg_atom: !"," target_atom
    def arg_atom(self) -> ParseResult[Any]:
        def _rhs() -> Any:
            def _alt() -> Any:  # !"," target_atom
                # !","
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(12)   # token=,
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                _lookahead_var, = _result__lookahead_var
                # target_atom
                def _item_a() -> str:
                    return self.target_atom()
                a: str; _result_a: ParseResult[str]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return a,
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, '!"," target_atom'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    # target_atoms: target_atom+
    def target_atoms(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt() -> Any:  # target_atom+
                # target_atom+
                def _item_a() -> ParseResult[list]:
                    def _node() -> str:
                        return self.target_atom()
                    return self._loop(_node, None, True)
                a: ParseResult[list]; _result_a: ParseResult[ParseResult[list]]
                _result_a = _item_a()
                if not _result_a: return None
                a, = _result_a
                # parse succeeded
                return " " . join (a),
            _alt_descriptors = [
                RuleAltDescr(_alt, _alt, 'target_atom+'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    @memoize
    # target_atom: "(" target_atoms? ")" | "{" target_atoms? "}" | "["
    #     target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" |
    #     !")" !"}" !"]" OP
    def target_atom(self) -> ParseResult[str]:
        def _rhs() -> Any:
            def _alt_1() -> Any:  # "(" target_atoms? ")"
                # "("
                def _item__literal_var() -> Token:
                    return self._expect_type(7)   # token=(
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: ParseResult[Any]
                atoms, = _item_atoms()
                # ")"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(8)   # token=)
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return "(" + (atoms or "") + ")",
            def _alt_2() -> Any:  # "{" target_atoms? "}"
                # "{"
                def _item__literal_var() -> Token:
                    return self._expect_type(25)   # token={
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: ParseResult[Any]
                atoms, = _item_atoms()
                # "}"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(26)   # token=}
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return "{" + (atoms or "") + "}",
            def _alt_3() -> Any:  # "[" target_atoms? "]"
                # "["
                def _item__literal_var() -> Token:
                    return self._expect_type(9)   # token=[
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # target_atoms?
                def _item_atoms() -> ParseResult[Any]:
                    def _item() -> str:
                        return self.target_atoms()
                    return self._opt(_item)
                atoms: ParseResult[Any]
                atoms, = _item_atoms()
                # "]"
                def _item__literal_var_1() -> Token:
                    return self._expect_type(10)   # token=]
                _literal_var_1: Token; _result__literal_var_1: ParseResult[Token]
                _result__literal_var_1 = _item__literal_var_1()
                if not _result__literal_var_1: return None
                _literal_var_1, = _result__literal_var_1
                # parse succeeded
                return "[" + (atoms or "") + "]",
            def _alt_4() -> Any:  # NAME "*"
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # "*"
                def _item__literal_var() -> Token:
                    return self._expect_type(16)   # token=*
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return n . string + "*",
            def _alt_5() -> Any:  # NAME
                # NAME
                def _item_n() -> Token:
                    return self._name()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # parse succeeded
                return n . string,
            def _alt_6() -> Any:  # NUMBER
                # NUMBER
                def _item_n() -> Token:
                    return self._number()
                n: Token; _result_n: ParseResult[Token]
                _result_n = _item_n()
                if not _result_n: return None
                n, = _result_n
                # parse succeeded
                return n . string,
            def _alt_7() -> Any:  # STRING
                # STRING
                def _item_s() -> Token:
                    return self._string()
                s: Token; _result_s: ParseResult[Token]
                _result_s = _item_s()
                if not _result_s: return None
                s, = _result_s
                # parse succeeded
                return s . string,
            def _alt_8() -> Any:  # "?"
                # "?"
                def _item__literal_var() -> Token:
                    return self._expect_char('?')   # token=?
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return "?",
            def _alt_9() -> Any:  # ":"
                # ":"
                def _item__literal_var() -> Token:
                    return self._expect_type(11)   # token=:
                _literal_var: Token; _result__literal_var: ParseResult[Token]
                _result__literal_var = _item__literal_var()
                if not _result__literal_var: return None
                _literal_var, = _result__literal_var
                # parse succeeded
                return ":",
            def _alt_10() -> Any:  # !")" !"}" !"]" OP
                # !")"
                def _item__lookahead_var() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(8)   # token=)
                    return self._lookahead(False, atom)
                _lookahead_var: ParseResult[bool]; _result__lookahead_var: ParseResult[ParseResult[bool]]
                _result__lookahead_var = _item__lookahead_var()
                if not _result__lookahead_var: return None
                _lookahead_var, = _result__lookahead_var
                # !"}"
                def _item__lookahead_var_1() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(26)   # token=}
                    return self._lookahead(False, atom)
                _lookahead_var_1: ParseResult[bool]; _result__lookahead_var_1: ParseResult[ParseResult[bool]]
                _result__lookahead_var_1 = _item__lookahead_var_1()
                if not _result__lookahead_var_1: return None
                _lookahead_var_1, = _result__lookahead_var_1
                # !"]"
                def _item__lookahead_var_2() -> ParseResult[bool]:
                    def atom() -> Token:
                        return self._expect_type(10)   # token=]
                    return self._lookahead(False, atom)
                _lookahead_var_2: ParseResult[bool]; _result__lookahead_var_2: ParseResult[ParseResult[bool]]
                _result__lookahead_var_2 = _item__lookahead_var_2()
                if not _result__lookahead_var_2: return None
                _lookahead_var_2, = _result__lookahead_var_2
                # OP
                def _item_op() -> Token:
                    return self._op()
                op: Token; _result_op: ParseResult[Token]
                _result_op = _item_op()
                if not _result_op: return None
                op, = _result_op
                # parse succeeded
                return op . string,
            _alt_descriptors = [
                RuleAltDescr(_alt_1, _alt_1, '"(" target_atoms? ")"'),
                RuleAltDescr(_alt_2, _alt_2, '"{" target_atoms? "}"'),
                RuleAltDescr(_alt_3, _alt_3, '"[" target_atoms? "]"'),
                RuleAltDescr(_alt_4, _alt_4, 'NAME "*"'),
                RuleAltDescr(_alt_5, _alt_5, 'NAME'),
                RuleAltDescr(_alt_6, _alt_6, 'NUMBER'),
                RuleAltDescr(_alt_7, _alt_7, 'STRING'),
                RuleAltDescr(_alt_8, _alt_8, '"?"'),
                RuleAltDescr(_alt_9, _alt_9, '":"'),
                RuleAltDescr(_alt_10, _alt_10, '!")" !"}" !"]" OP'),
            ]
            return self._alts(_alt_descriptors)
        return _rhs()

    KEYWORDS = ()
    SOFT_KEYWORDS = ('memo',)


if __name__ == '__main__':
    from pegen.parser import simple_parser_main
    simple_parser_main(GeneratedParser)
